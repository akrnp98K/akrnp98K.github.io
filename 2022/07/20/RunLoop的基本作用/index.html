<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>RunLoop的基本作用 | Remarkable</title><meta name="author" content="Small Waste"><meta name="copyright" content="Small Waste"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="RunLoop，项目中有用到吗? RunLoop内部实现逻辑. Runloop和线程的关系. timer 与 Runloop 的关系. 程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决. Runloop 是怎么响应用户操作的， 具体流程是什么样的"><link rel="shortcut icon" href="https://s2.loli.net/2022/07/21/dTarQcplR5zGN4W.png"><link rel="canonical" href="https://www.xiaojingye.top/2022/07/20/RunLoop%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%9C%E7%94%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?86771261f70d87991b3ee29ce2dac0b1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"./search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RunLoop的基本作用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-20 17:47:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="baidu-site-verification" content="codeva-j2TLeETEme" /><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/07/20/N1DLlaqMkj5fK7U.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fa-solid fa-image"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/Message/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/07/20/tOoYKRE7fMVdb6x.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Remarkable</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fa-solid fa-image"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/Message/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RunLoop的基本作用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-20T03:46:39.000Z" title="发表于 2022-07-20 11:46:39">2022-07-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-20T09:47:14.000Z" title="更新于 2022-07-20 17:47:14">2022-07-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BA%95%E5%B1%82/">底层</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RunLoop的基本作用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ol>
<li>RunLoop，项目中有用到吗?</li>
<li>RunLoop内部实现逻辑.</li>
<li>Runloop和线程的关系.</li>
<li>timer 与 Runloop 的关系.</li>
<li>程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决.</li>
<li>Runloop 是怎么响应用户操作的， 具体流程是什么样的？</li>
<li>RunLoop的几种状态</li>
<li>Runloop的mode作用是什么.</li>
</ol>
<h1 id="一-RunLoop简介"><a href="#一-RunLoop简介" class="headerlink" title="一.RunLoop简介"></a>一.RunLoop简介</h1><p>运行循环，在程序运行过程中循环做一些事情，如果没有Runloop程序执行完毕就会立即退出，如果有Runloop程序会一直运行，并且时时刻刻在等待用户的输入操作。RunLoop可以在需要的时候自己跑起来运行，在没有操作的时候就停下来休息。充分节省CPU资源，提高程序性能。</p>
<h1 id="二-RunLoop基本作用："><a href="#二-RunLoop基本作用：" class="headerlink" title="二.RunLoop基本作用："></a>二.RunLoop基本作用：</h1><ol>
<li>保持程序持续运行，程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的RunLoop,RunLoop保证主线程不会被销毁，也就保证了程序的持续运行</li>
<li>处理App中的各种事件（比如：触摸事件，定时器事件，Selector事件等）</li>
<li>节省CPU资源，提高程序性能，程序运行起来时，当什么操作都没有做的时候，RunLoop就告诉CUP，现在没有事情做，我要去休息，这时CUP就会将其资源释放出来去做其他的事情，当有事情做的时候RunLoop就会立马起来去做事情.</li>
</ol>
<p>我们先通过API内一张图片来简单看一下RunLoop内部运行原理 <img src="https://s2.loli.net/2022/07/20/hut7CfpQZmrUSKP.png" alt="RunLoop内部运行原理"><br>来自Apple developer网站</p>
<p>通过图片可以看出，RunLoop在跑圈过程中，当接收到Input sources 或者 Timer sources时就会交给对应的处理方去处理。当没有事件消息传入的时候，RunLoop就休息了。</p>
<h1 id="三-开启RunLoop"><a href="#三-开启RunLoop" class="headerlink" title="三. 开启RunLoop"></a>三. 开启RunLoop</h1><p>UIApplicationMain函数内启动了Runloop，程序不会马上退出，而是保持运行状态。因此每一个应用必须要有一个runloop， 众所周知，主线程一开起来，就会跑一个和主线程对应的RunLoop，那么RunLoop一定是在程序的入口main函数中开启。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="进入UIApplicationMain"><a href="#进入UIApplicationMain" class="headerlink" title="进入UIApplicationMain"></a>进入UIApplicationMain</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="type">int</span> <span class="built_in">UIApplicationMain</span>(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="built_in">NSString</span> * __<span class="keyword">nullable</span> principalClassName, <span class="built_in">NSString</span> * __<span class="keyword">nullable</span> delegateClassName);</span><br></pre></td></tr></table></figure>
<p>在此发现它返回的是一个int数，那么就对main函数做一些修改<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;开始&quot;</span>);</span><br><span class="line">            <span class="type">int</span> re = <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;结束&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> re;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>运行程序发现只会打印开始，并不会打印结束，这说明在UIApplicationMain函数中，开启了一个和主线程相关的RunLoop，导致UIApplicationMain不会返回，一直在运行中，也就保证了程序的持续运行。</p>
<h3 id="康康RunLoop的源码"><a href="#康康RunLoop的源码" class="headerlink" title="康康RunLoop的源码"></a>康康RunLoop的源码</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用DefaultMode启动</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="type">void</span>) &#123;   <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">        int32_t result;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">            CHECK_FOR_FORK();</span><br><span class="line">        &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>发现RunLoop确实是do while通过判断result的值实现的。因此，可以把RunLoop看成一个死循环。如果没有RunLoop，UIApplicationMain函数执行完毕之后将直接返回，也就没有程序持续运行一说了。</p>
<h1 id="四-RunLoop对象"><a href="#四-RunLoop对象" class="headerlink" title="四. RunLoop对象"></a>四. RunLoop对象</h1><p>Fundation框架 （基于CFRunLoopRef的封装） <br>NSRunLoop对象</p>
<p>CoreFoundation <br>CFRunLoopRef对象</p>
<p>因为Fundation框架是基于CFRunLoopRef的一层OC封装，这里我主要研究CFRunLoopRef源码</p>
<h3 id="如何获得RunLoop对象"><a href="#如何获得RunLoop对象" class="headerlink" title="如何获得RunLoop对象"></a>如何获得RunLoop对象</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foundation</span><br><span class="line">    [<span class="built_in">NSRunLoop</span> currentRunLoop]; <span class="comment">// 获得当前线程的RunLoop对象</span></span><br><span class="line">    [<span class="built_in">NSRunLoop</span> mainRunLoop]; <span class="comment">// 获得主线程的RunLoop对象</span></span><br><span class="line">    </span><br><span class="line">    Core Foundation</span><br><span class="line">    <span class="built_in">CFRunLoopGetCurrent</span>(); <span class="comment">// 获得当前线程的RunLoop对象</span></span><br><span class="line">    <span class="built_in">CFRunLoopGetMain</span>(); <span class="comment">// 获得主线程的RunLoop对象</span></span><br></pre></td></tr></table></figure>
<h1 id="五-RunLoop和线程间的关系"><a href="#五-RunLoop和线程间的关系" class="headerlink" title="五. RunLoop和线程间的关系"></a>五. RunLoop和线程间的关系</h1><ol>
<li>每条线程都有唯一的一个与之对应的RunLoop对象</li>
<li>RunLoop保存在一个全局的Dictionary里，线程作为key,RunLoop作为value</li>
<li>主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建</li>
<li>RunLoop在第一次获取时创建，在线程结束时销毁</li>
</ol>
<h3 id="通过源码查看上述对应"><a href="#通过源码查看上述对应" class="headerlink" title="通过源码查看上述对应"></a>通过源码查看上述对应</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到当前Runloop 调用_CFRunLoopGet0</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="type">void</span>) &#123;</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> rl = (<span class="built_in">CFRunLoopRef</span>)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">        <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">        <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看_CFRunLoopGet0方法内部</span></span><br><span class="line">    <span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">        &#125;</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">        <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">            __CFUnlock(&amp;loopsLock);</span><br><span class="line">        <span class="built_in">CFMutableDictionaryRef</span> dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        <span class="comment">// 根据传入的主线程获取主线程对应的RunLoop</span></span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        <span class="comment">// 保存主线程 将主线程-key和RunLoop-Value保存到字典中</span></span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        <span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="type">void</span> * <span class="keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(dict);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFRelease</span>(mainLoop);</span><br><span class="line">            __CFLock(&amp;loopsLock);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从字典里面拿，将线程作为key从字典里获取一个loop</span></span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果loop为空，则创建一个新的loop，所以runloop会在第一次获取的时候创建</span></span><br><span class="line">        <span class="keyword">if</span> (!loop) &#123;  </span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);</span><br><span class="line">            __CFLock(&amp;loopsLock);</span><br><span class="line">        loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建好之后，以线程为key runloop为value，一对一存储在字典中，下次获取的时候，则直接返回字典内的runloop</span></span><br><span class="line">        <span class="keyword">if</span> (!loop) &#123; </span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop = newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// don&#x27;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span></span><br><span class="line">            __CFUnlock(&amp;loopsLock);</span><br><span class="line">        <span class="built_in">CFRelease</span>(newLoop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoop, (<span class="type">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">                _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="type">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="type">void</span> (*)(<span class="type">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码看出线程和 RunLoop 之间是一一对应的，其关系是保存在一个 Dictionary 里。所以我们创建子线程RunLoop时，只需在子线程中获取当前线程的RunLoop对象即可[NSRunLoop currentRunLoop];如果不获取，那子线程就不会创建与之相关联的RunLoop，并且只能在一个线程的内部获取其 RunLoop [NSRunLoop currentRunLoop];方法调用时，会先看一下字典里有没有存子线程相对用的RunLoop，如果有则直接返回RunLoop，如果没有则会创建一个，并将与之对应的子线程存入字典中。当线程结束时，RunLoop会被销毁。</p>
<h1 id="六-RunLoop结构体"><a href="#六-RunLoop结构体" class="headerlink" title="六. RunLoop结构体"></a>六. RunLoop结构体</h1><p>通过源码找到<strong>CFRunLoop结构体<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">        <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">        pthread_mutex_t _lock;          <span class="comment">/* locked for accessing mode list */</span></span><br><span class="line">        __CFPort _wakeUpPort;           <span class="comment">// used for CFRunLoopWakeUp </span></span><br><span class="line">        Boolean _unused;</span><br><span class="line">        <span class="keyword">volatile</span> _per_run_data *_perRunData;              <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">        pthread_t _pthread;</span><br><span class="line">        uint32_t _winthread;</span><br><span class="line">        <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">        <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">        <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">        <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">        <span class="keyword">struct</span> _block_item *_blocks_head;</span><br><span class="line">        <span class="keyword">struct</span> _block_item *_blocks_tail;</span><br><span class="line">        <span class="built_in">CFAbsoluteTime</span> _runTime;</span><br><span class="line">        <span class="built_in">CFAbsoluteTime</span> _sleepTime;</span><br><span class="line">        <span class="built_in">CFTypeRef</span> _counterpart;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><br>除一些记录性属性外，主要来看一下以下两个成员变量<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br></pre></td></tr></table></figure><br>CFRunLoopModeRef 其实是指向</strong>CFRunLoopMode结构体的指针__CFRunLoopMode结构体源码如下</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoopMode *<span class="built_in">CFRunLoopModeRef</span>;</span><br><span class="line">    <span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">        <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">        pthread_mutex_t _lock;  <span class="comment">/* must have the run loop locked before locking this */</span></span><br><span class="line">        <span class="built_in">CFStringRef</span> _name;</span><br><span class="line">        Boolean _stopped;</span><br><span class="line">        <span class="type">char</span> _padding[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line">        <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line">        <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">        <span class="built_in">CFMutableArrayRef</span> _timers;</span><br><span class="line">        <span class="built_in">CFMutableDictionaryRef</span> _portToV1SourceMap;</span><br><span class="line">        __CFPortSet _portSet;</span><br><span class="line">        <span class="built_in">CFIndex</span> _observerMask;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">        dispatch_source_t _timerSource;</span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> _queue;</span><br><span class="line">        Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">        Boolean _dispatchTimerArmed;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">        mach_port_t _timerPort;</span><br><span class="line">        Boolean _mkTimerArmed;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">        DWORD _msgQMask;</span><br><span class="line">        <span class="type">void</span> (*_msgPump)(<span class="type">void</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        uint64_t _timerSoftDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">        uint64_t _timerHardDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>主要查看以下成员变量<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;</span><br></pre></td></tr></table></figure><br>通过上面分析知道CFRunLoopModeRef代表RunLoop的运行模式，一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer，而RunLoop启动时只能选择其中一个Mode作为currentMode。</p>
<h2 id="Source1-Source0-Timers-Observer分别代表什么"><a href="#Source1-Source0-Timers-Observer分别代表什么" class="headerlink" title="Source1/Source0/Timers/Observer分别代表什么?"></a>Source1/Source0/Timers/Observer分别代表什么?</h2><ol>
<li>Source1 : 基于Port的线程间通信</li>
<li>Source0 : 触摸事件，PerformSelectors</li>
</ol>
<p>通过代码验证一下<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;点击了屏幕&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>打断点之后打印堆栈信息，当xcode工具区打印的堆栈信息不全时，可以在控制台通过“bt”指令打印完整的堆栈信息，由堆栈信息中可以发现，触摸事件确实是会触发Source0事件。</p>
<p>touchesBegan堆栈信息<br>同样的方式验证performSelector堆栈信息<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><br>可以发现PerformSelectors同样是触发Source0事件</p>
<p>performSelector堆栈信息</p>
<h3 id="3-Timers-定时器，NSTimer"><a href="#3-Timers-定时器，NSTimer" class="headerlink" title="3. Timers : 定时器，NSTimer"></a>3. Timers : 定时器，NSTimer</h3><p>通过代码验证<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3.0</span> repeats:<span class="literal">NO</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;NSTimer ---- timer调用了&quot;</span>);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><br>打印完整堆栈信息</p>
<p>Timer对战信息</p>
<h3 id="4-Observer-监听器，用于监听RunLoop的状态"><a href="#4-Observer-监听器，用于监听RunLoop的状态" class="headerlink" title="4. Observer : 监听器，用于监听RunLoop的状态"></a>4. Observer : 监听器，用于监听RunLoop的状态</h3><h1 id="七-详细说明一下RunLoop相关类及作用"><a href="#七-详细说明一下RunLoop相关类及作用" class="headerlink" title="七. 详细说明一下RunLoop相关类及作用"></a>七. 详细说明一下RunLoop相关类及作用</h1><p>通过上面的分析，我们对RunLoop内部结构有了大致的了解，接下来来详细分析RunLoop的相关类。以下为Core Foundation中关于RunLoop的5个类</p>
<h4 id="CFRunLoopRef-获得当前RunLoop和主RunLoop"><a href="#CFRunLoopRef-获得当前RunLoop和主RunLoop" class="headerlink" title="CFRunLoopRef - 获得当前RunLoop和主RunLoop"></a>CFRunLoopRef - 获得当前RunLoop和主RunLoop</h4><h4 id="CFRunLoopModeRef-RunLoop-运行模式，只能选择一种，在不同模式中做不同的操作"><a href="#CFRunLoopModeRef-RunLoop-运行模式，只能选择一种，在不同模式中做不同的操作" class="headerlink" title="CFRunLoopModeRef - RunLoop 运行模式，只能选择一种，在不同模式中做不同的操作"></a>CFRunLoopModeRef - RunLoop 运行模式，只能选择一种，在不同模式中做不同的操作</h4><h4 id="CFRunLoopSourceRef-事件源，输入源"><a href="#CFRunLoopSourceRef-事件源，输入源" class="headerlink" title="CFRunLoopSourceRef - 事件源，输入源"></a>CFRunLoopSourceRef - 事件源，输入源</h4><h4 id="CFRunLoopTimerRef-定时器时间"><a href="#CFRunLoopTimerRef-定时器时间" class="headerlink" title="CFRunLoopTimerRef - 定时器时间"></a>CFRunLoopTimerRef - 定时器时间</h4><h4 id="CFRunLoopObserverRef-观察者"><a href="#CFRunLoopObserverRef-观察者" class="headerlink" title="CFRunLoopObserverRef - 观察者"></a>CFRunLoopObserverRef - 观察者</h4><h3 id="1-CFRunLoopModeRef"><a href="#1-CFRunLoopModeRef" class="headerlink" title="1. CFRunLoopModeRef"></a>1. CFRunLoopModeRef</h3><p>CFRunLoopModeRef代表RunLoop的运行模式 一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source、Timer、Observer 每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode 如果需要切换Mode，只能退出RunLoop，再重新指定一个Mode进入，这样做主要是为了分隔开不同组的Source、Timer、Observer，让其互不影响。如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出 如图所示：<br><img src="https://s2.loli.net/2022/07/20/UXweM1IboQ53Cdk.png" alt="CFRunLoopModeRef示意图"></p>
<h6 id="注意：一种Mode中可以有多个Source-事件源，输入源，基于端口事件源例键盘触摸等-Observer-观察者，观察当前RunLoop运行状态-和Timer-定时器事件源-。但是必须至少有一个Source或者Timer，因为如果Mode为空，RunLoop运行到空模式不会进行空转，就会立刻退出。"><a href="#注意：一种Mode中可以有多个Source-事件源，输入源，基于端口事件源例键盘触摸等-Observer-观察者，观察当前RunLoop运行状态-和Timer-定时器事件源-。但是必须至少有一个Source或者Timer，因为如果Mode为空，RunLoop运行到空模式不会进行空转，就会立刻退出。" class="headerlink" title="注意：一种Mode中可以有多个Source(事件源，输入源，基于端口事件源例键盘触摸等) Observer(观察者，观察当前RunLoop运行状态) 和Timer(定时器事件源)。但是必须至少有一个Source或者Timer，因为如果Mode为空，RunLoop运行到空模式不会进行空转，就会立刻退出。"></a>注意：一种Mode中可以有多个Source(事件源，输入源，基于端口事件源例键盘触摸等) Observer(观察者，观察当前RunLoop运行状态) 和Timer(定时器事件源)。但是必须至少有一个Source或者Timer，因为如果Mode为空，RunLoop运行到空模式不会进行空转，就会立刻退出。</h6><h4 id="系统默认注册的5个Mode"><a href="#系统默认注册的5个Mode" class="headerlink" title="系统默认注册的5个Mode:"></a>系统默认注册的5个Mode:</h4><p>RunLoop 有五种运行模式，其中常见的有1.2两种</p>
<ol>
<li>kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行</li>
<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用，会切换到kCFRunLoopDefaultMode</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</li>
<li>kCFRunLoopCommonModes: 这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode </li>
</ol>
<h4 id="Mode间的切换"><a href="#Mode间的切换" class="headerlink" title="Mode间的切换"></a>Mode间的切换</h4><p>平时在开发中遇到过当使用NSTimer每一段时间执行一些事情时滑动UIScrollView，NSTimer就会暂停，当我们停止滑动以后，NSTimer又会重新恢复的情况，通过一段代码来看一下<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES];</span></span><br><span class="line">        <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(show) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">        <span class="comment">// 加入到RunLoop中才可以运行</span></span><br><span class="line">        <span class="comment">// 1. 把定时器添加到RunLoop中，并且选择默认运行模式NSDefaultRunLoopMode = kCFRunLoopDefaultMode</span></span><br><span class="line">        <span class="comment">// [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span></span><br><span class="line">        <span class="comment">// 当textFiled滑动的时候，timer失效，停止滑动时，timer恢复</span></span><br><span class="line">        <span class="comment">// 原因：当textFiled滑动的时候，RunLoop的Mode会自动切换成UITrackingRunLoopMode模式，因此timer失效，当停止滑动，RunLoop又会切换回NSDefaultRunLoopMode模式，因此timer又会重新启动了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 当我们将timer添加到UITrackingRunLoopMode模式中，此时只有我们在滑动textField时timer才会运行</span></span><br><span class="line">        <span class="comment">// [[NSRunLoop mainRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 那个如何让timer在两个模式下都可以运行呢？</span></span><br><span class="line">        <span class="comment">// 3.1 在两个模式下都添加timer 是可以的，但是timer添加了两次，并不是同一个timer</span></span><br><span class="line">        <span class="comment">// 3.2 使用站位的运行模式 NSRunLoopCommonModes标记，凡是被打上NSRunLoopCommonModes标记的都可以运行，下面两种模式被打上标签</span></span><br><span class="line">        <span class="comment">//0 : &lt;CFString 0x10b7fe210 [0x10a8c7a40]&gt;&#123;contents = &quot;UITrackingRunLoopMode&quot;&#125;</span></span><br><span class="line">        <span class="comment">//2 : &lt;CFString 0x10a8e85e0 [0x10a8c7a40]&gt;&#123;contents = &quot;kCFRunLoopDefaultMode&quot;&#125;</span></span><br><span class="line">        <span class="comment">// 因此也就是说如果我们使用NSRunLoopCommonModes，timer可以在UITrackingRunLoopMode，kCFRunLoopDefaultMode两种模式下运行</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSRunLoop</span> mainRunLoop]);</span><br><span class="line">    &#125;</span><br><span class="line">    -(<span class="type">void</span>)show</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;-------&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>由上述代码可以看出，NSTimer不管用是因为Mode的切换，因为如果在主线程使用定时器，此时RunLoop的Mode为kCFRunLoopDefaultMode，即定时器属于kCFRunLoopDefaultMode，那么此时我们滑动ScrollView时，RunLoop的Mode会切换到UITrackingRunLoopMode，因此在主线程的定时器就不在管用了，调用的方法也就不再执行了，当停止滑动时，RunLoop的Mode切换回kCFRunLoopDefaultMode，所以NSTimer就又管用了。</p>
<p>同样道理的还有ImageView的显示.</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">        <span class="comment">// performSelector默认是在default模式下运行，因此在滑动ScrollView时，图片不会加载</span></span><br><span class="line">        <span class="comment">// [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;abc&quot;] afterDelay:2.0 ];</span></span><br><span class="line">        <span class="comment">// inModes: 传入Mode数组</span></span><br><span class="line">        [<span class="keyword">self</span>.imageView performSelector:<span class="keyword">@selector</span>(setImage:) withObject:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;abc&quot;</span>] afterDelay:<span class="number">2.0</span> inModes:@[<span class="built_in">NSDefaultRunLoopMode</span>,<span class="built_in">UITrackingRunLoopMode</span>]];</span><br></pre></td></tr></table></figure>
<h5 id="使用GCD也可是创建计时器，而且更为精确我们来看一下代码"><a href="#使用GCD也可是创建计时器，而且更为精确我们来看一下代码" class="headerlink" title="使用GCD也可是创建计时器，而且更为精确我们来看一下代码"></a>使用GCD也可是创建计时器，而且更为精确我们来看一下代码</h5><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//1.创建一个GCD定时器</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         第一个参数:表明创建的是一个定时器</span></span><br><span class="line"><span class="comment">         第四个参数:队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">        <span class="comment">// 需要对timer进行强引用，保证其不会被释放掉，才会按时调用block块</span></span><br><span class="line">        <span class="comment">// 局部变量，让指针强引用</span></span><br><span class="line">        <span class="keyword">self</span>.timer = timer;</span><br><span class="line">        <span class="comment">//2.设置定时器的开始时间,间隔时间,精准度</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         第1个参数:要给哪个定时器设置</span></span><br><span class="line"><span class="comment">         第2个参数:开始时间</span></span><br><span class="line"><span class="comment">         第3个参数:间隔时间</span></span><br><span class="line"><span class="comment">         第4个参数:精准度 一般为0 在允许范围内增加误差可提高程序的性能</span></span><br><span class="line"><span class="comment">         GCD的单位是纳秒 所以要*NSEC_PER_SEC</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.设置定时器要执行的事情</span></span><br><span class="line">        dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;---%@--&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        dispatch_resume(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<pre><code>### 2. CFRunLoopSourceRef事件源（输入源）

#### Source分为两种
##### Source0：非基于Port的 用于用户主动触发的事件（点击button 或点击屏幕）
</code></pre><h5 id="Source1：基于Port的-通过内核和其他线程相互发送消息（与内核相关）"><a href="#Source1：基于Port的-通过内核和其他线程相互发送消息（与内核相关）" class="headerlink" title="Source1：基于Port的 通过内核和其他线程相互发送消息（与内核相关）"></a>Source1：基于Port的 通过内核和其他线程相互发送消息（与内核相关）</h5><h5 id=""><a href="#" class="headerlink" title="#"></a>#</h5><p>触摸事件及PerformSelectors会触发Source0事件源在前文已经验证过</p>
<h3 id="3-CFRunLoopObserverRef"><a href="#3-CFRunLoopObserverRef" class="headerlink" title="3. CFRunLoopObserverRef"></a>3. CFRunLoopObserverRef</h3><h4 id="CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变"><a href="#CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变" class="headerlink" title="CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变"></a>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</h4><p>给RunLoop添加监听者，监听其运行状态:</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//创建监听者</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         第一个参数 CFAllocatorRef allocator：分配存储空间 CFAllocatorGetDefault()默认分配</span></span><br><span class="line"><span class="comment">         第二个参数 CFOptionFlags activities：要监听的状态 kCFRunLoopAllActivities 监听所有状态</span></span><br><span class="line"><span class="comment">         第三个参数 Boolean repeats：YES:持续监听 NO:不持续</span></span><br><span class="line"><span class="comment">         第四个参数 CFIndex order：优先级，一般填0即可</span></span><br><span class="line"><span class="comment">         第五个参数 ：回调 两个参数observer:监听者 activity:监听的事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         所有事件</span></span><br><span class="line"><span class="comment">         typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span></span><br><span class="line"><span class="comment">         kCFRunLoopEntry = (1UL &lt;&lt; 0),   //   即将进入RunLoop</span></span><br><span class="line"><span class="comment">         kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer</span></span><br><span class="line"><span class="comment">         kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source</span></span><br><span class="line"><span class="comment">         kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠</span></span><br><span class="line"><span class="comment">         kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒</span></span><br><span class="line"><span class="comment">         kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出RunLoop</span></span><br><span class="line"><span class="comment">         kCFRunLoopAllActivities = 0x0FFFFFFFU</span></span><br><span class="line"><span class="comment">         &#125;;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop进入&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop要处理Timers了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop要处理Sources了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop要休息了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop醒来了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop退出了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给RunLoop添加监听者</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         第一个参数 CFRunLoopRef rl：要监听哪个RunLoop,这里监听的是主线程的RunLoop</span></span><br><span class="line"><span class="comment">         第二个参数 CFRunLoopObserverRef observer 监听者</span></span><br><span class="line"><span class="comment">         第三个参数 CFStringRef mode 要监听RunLoop在哪种运行模式下的状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         CF的内存管理（Core Foundation）</span></span><br><span class="line"><span class="comment">         凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release</span></span><br><span class="line"><span class="comment">         GCD本来在iOS6.0之前也是需要我们释放的，6.0之后GCD已经纳入到了ARC中，所以我们不需要管了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>监听者监听RunLoop运行状态</p>
<p>以上可以看出，Observer确实用来监听RunLoop的状态，包括唤醒，休息，以及处理各种事件。</p>
<h1 id="八-RunLoop处理逻辑"><a href="#八-RunLoop处理逻辑" class="headerlink" title="八. RunLoop处理逻辑"></a>八. RunLoop处理逻辑</h1><p>这时我们再来分析RunLoop的处理逻辑，就会简单明了很多，现在回头看官方文档RunLoop的处理逻辑，对RunLoop的处理逻辑有新的认识。<br>)</p>
<p><img src="https://s2.loli.net/2022/07/20/QSx1BM4ApDdaPw5.png" alt="官方文档RunLoop处理逻辑"></p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="源码仅保留了主流程代码"><a href="#源码仅保留了主流程代码" class="headerlink" title="源码仅保留了主流程代码"></a>源码仅保留了主流程代码</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共外部调用的公开的CFRunLoopRun方法，其内部会调用CFRunLoopRunSpecific</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="type">void</span>) &#123;   <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">        int32_t result;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">            CHECK_FOR_FORK();</span><br><span class="line">        &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 经过精简的 CFRunLoopRunSpecific 函数代码，其内部会调用__CFRunLoopRun函数</span></span><br><span class="line">    SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 通知Observers : 进入Loop</span></span><br><span class="line">        <span class="comment">// __CFRunLoopDoObservers内部会调用 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span></span><br><span class="line">    函数</span><br><span class="line">        <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 核心的Loop逻辑</span></span><br><span class="line">        result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知Observers : 退出Loop</span></span><br><span class="line">        <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 精简后的 __CFRunLoopRun函数，保留了主要代码</span></span><br><span class="line">    <span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopModeRef</span> rlm, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class="built_in">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line">        int32_t retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 通知Observers：即将处理Timers</span></span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通知Observers：即将处理Sources</span></span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理Blocks</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理Sources0</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopDoSources0(rl, rlm, stopAfterHandle)) &#123;</span><br><span class="line">                <span class="comment">// 处理Blocks</span></span><br><span class="line">                __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果有Sources1，就跳转到handle_msg标记处</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通知Observers：即将休眠</span></span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 进入休眠，等待其他消息唤醒</span></span><br><span class="line">            __CFRunLoopSetSleeping(rl);</span><br><span class="line">            __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 醒来</span></span><br><span class="line">            __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">            __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通知Observers：已经唤醒</span></span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">            </span><br><span class="line">        handle_msg: <span class="comment">// 看看是谁唤醒了RunLoop，进行相应的处理</span></span><br><span class="line">            <span class="keyword">if</span> (被Timer唤醒的) &#123;</span><br><span class="line">                <span class="comment">// 处理Timer</span></span><br><span class="line">                __CFRunLoopDoTimers(rl, rlm, mach_absolute_time());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (被GCD唤醒的) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 被Sources1唤醒的</span></span><br><span class="line">                __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行Blocks</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据之前的执行结果，来决定怎么做，为retVal赋相应的值</span></span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">                __CFRunLoopUnsetStopped(rl);</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">                rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述源代码中，相应处理事件函数内部还会调用更底层的函数，内部调用才是真正处理事件的函数，通过上面bt打印全部堆栈信息也可以得到验证。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__CFRunLoopDoObservers 内部调用 </span><br><span class="line"></span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><br><span class="line"></span><br><span class="line">__CFRunLoopDoBlocks 内部调用 __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><br><span class="line"></span><br><span class="line">__CFRunLoopDoSources0 内部调用 </span><br><span class="line"></span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span><br><span class="line"></span><br><span class="line">__CFRunLoopDoTimers 内部调用 </span><br><span class="line"></span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span><br><span class="line">GCD 调用</span><br><span class="line">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><br><span class="line"> </span><br><span class="line">__CFRunLoopDoSource1 内部调用 </span><br><span class="line"></span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><br></pre></td></tr></table></figure></p>
<h1 id="九-RunLoop退出"><a href="#九-RunLoop退出" class="headerlink" title="九. RunLoop退出"></a>九. RunLoop退出</h1><ol>
<li>主线程销毁RunLoop退出</li>
<li>Mode中有一些Timer 、Source、 Observer，这些保证Mode不为空时保证RunLoop没有空转并且是在运行的，当Mode中为空的时候，RunLoop会立刻退出</li>
<li>在启动RunLoop的时候可以设置什么时候停止<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop]runUntilDate:&lt;#(<span class="keyword">nonnull</span> <span class="built_in">NSDate</span> *)#&gt;</span><br><span class="line">    [<span class="built_in">NSRunLoop</span> currentRunLoop]runMode:&lt;#(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)#&gt; beforeDate:&lt;#(<span class="keyword">nonnull</span> <span class="built_in">NSDate</span> *)#&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="十-RunLoop应用"><a href="#十-RunLoop应用" class="headerlink" title="十. RunLoop应用"></a>十. RunLoop应用</h1><h3 id="1-常驻线程"><a href="#1-常驻线程" class="headerlink" title="1. 常驻线程"></a>1. 常驻线程</h3><p>常驻线程的作用：我们知道，当子线程中的任务执行完毕之后就被销毁了，那么如果我们需要开启一个子线程，在程序运行过程中永远都存在，那么我们就会面临一个问题，如何让子线程永远活着，这时就要用到常驻线程：给子线程开启一个RunLoop 注意：子线程执行完操作之后就会立即释放，即使我们使用强引用引用子线程使子线程不被释放，也不能给子线程再次添加操作，或者再次开启。 子线程开启RunLoop的代码，先点击屏幕开启子线程并开启子线程RunLoop，然后点击button。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line">    <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSThread</span> *thread;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">    </span><br><span class="line">    - (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">        [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    &#125;</span><br><span class="line">    -(<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 创建子线程并开启</span></span><br><span class="line">        <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(show) object:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">self</span>.thread = thread;</span><br><span class="line">        [thread start];</span><br><span class="line">    &#125;</span><br><span class="line">    -(<span class="type">void</span>)show</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意：打印方法一定要在RunLoop创建开始运行之前，如果在RunLoop跑起来之后打印，RunLoop先运行起来，已经在跑圈了就出不来了，进入死循环也就无法执行后面的操作了。</span></span><br><span class="line">        <span class="comment">// 但是此时点击Button还是有操作的，因为Button是在RunLoop跑起来之后加入到子线程的，当Button加入到子线程RunLoop就会跑起来</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">        <span class="comment">// 1.创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入</span></span><br><span class="line">        <span class="comment">// 添加Source [NSMachPort port] 添加一个端口</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        <span class="comment">// 添加一个Timer</span></span><br><span class="line">        <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];    </span><br><span class="line">        <span class="comment">//创建监听者</span></span><br><span class="line">        <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop进入&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop要处理Timers了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop要处理Sources了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop要休息了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop醒来了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;RunLoop退出了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 给RunLoop添加监听者</span></span><br><span class="line">        <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">        <span class="comment">// 2.子线程需要开启RunLoop</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop]run];</span><br><span class="line">        <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    - (<span class="keyword">IBAction</span>)btnClick:(<span class="type">id</span>)sender &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    -(<span class="type">void</span>)test</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer-或-一个Source-保证RunLoop不会因为空转而退出，因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃"><a href="#注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer-或-一个Source-保证RunLoop不会因为空转而退出，因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃" class="headerlink" title="注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃"></a>注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃</h4><h3 id="2-自动释放池"><a href="#2-自动释放池" class="headerlink" title="2. 自动释放池"></a>2. 自动释放池</h3><p>Timer和Source也是一些变量，需要占用一部分存储空间，所以要释放掉，如果不释放掉，就会一直积累，占用的内存也就越来越大，这显然不是我们想要的。<br> #### 那么什么时候释放，怎么释放?<br> RunLoop内部有一个自动释放池，当RunLoop开启时，就会自动创建一个自动释放池，当RunLoop在休息之前会释放掉自动释放池的东西，然后重新创建一个新的空的自动释放池，当RunLoop被唤醒重新开始跑圈时，Timer,Source等新的事件就会放到新的自动释放池中，当RunLoop退出的时候也会被释放。 ##### 注意：只有主线程的RunLoop会默认启动。也就意味着会自动创建自动释放池，子线程需要在线程调度方法中手动添加自动释放池。<br><figure class="highlight obj-c"><figcaption><span>obj-c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autorelease&#123;  </span><br><span class="line">          <span class="comment">// 执行代码 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.xiaojingye.top">Small Waste</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.xiaojingye.top/2022/07/20/RunLoop%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%9C%E7%94%A8/">https://www.xiaojingye.top/2022/07/20/RunLoop%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%9C%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.xiaojingye.top" target="_blank">Remarkable</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/07/20/tOoYKRE7fMVdb6x.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/07/20/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94/"><img class="prev-cover" src="https://s2.loli.net/2022/07/20/BwJUu7anDK2EAzR.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">访问控制&amp;蝴蝶效应</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/03/checkm8-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/" title="checkm8 攻击原理浅析"><img class="cover" src="https://www.apple.com.cn/newsroom/images/product/app-store/Apple_around-the-clock-global-effort-to-keep-App-Store-users-safe_spot-illo-1_050621_inline.jpg.large_2x.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-03</div><div class="title">checkm8 攻击原理浅析</div></div></a></div><div><a href="/2022/07/21/%E5%AE%A2%E6%88%B7%E7%AB%AFXSS/" title="客户端XSS"><img class="cover" src="https://developer.apple.com/xcode/images/screen-lighter-large_2x.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="title">客户端XSS</div></div></a></div><div><a href="/2022/07/20/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94/" title="访问控制&amp;蝴蝶效应"><img class="cover" src="https://s2.loli.net/2022/07/20/BwJUu7anDK2EAzR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-20</div><div class="title">访问控制&amp;蝴蝶效应</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/07/20/N1DLlaqMkj5fK7U.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Small Waste</div><div class="author-info__description">Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/akrnp98K/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/akrnp98K" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1735409005@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1735409005&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">认真上班是不可能的，这辈子都是不可能的。 只能靠摸摸鱼来混点底薪……</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-RunLoop%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一.RunLoop简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-RunLoop%E5%9F%BA%E6%9C%AC%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">二.RunLoop基本作用：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E5%BC%80%E5%90%AFRunLoop"><span class="toc-number">3.</span> <span class="toc-text">三. 开启RunLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5UIApplicationMain"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">进入UIApplicationMain</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%B7%E5%BA%B7RunLoop%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-number">3.0.1.</span> <span class="toc-text">康康RunLoop的源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-RunLoop%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">四. RunLoop对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97RunLoop%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.0.1.</span> <span class="toc-text">如何获得RunLoop对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-RunLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.</span> <span class="toc-text">五. RunLoop和线程间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B%E4%B8%8A%E8%BF%B0%E5%AF%B9%E5%BA%94"><span class="toc-number">5.0.1.</span> <span class="toc-text">通过源码查看上述对应</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-RunLoop%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">6.</span> <span class="toc-text">六. RunLoop结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Source1-Source0-Timers-Observer%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88"><span class="toc-number">6.1.</span> <span class="toc-text">Source1&#x2F;Source0&#x2F;Timers&#x2F;Observer分别代表什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Timers-%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%8CNSTimer"><span class="toc-number">6.1.1.</span> <span class="toc-text">3. Timers : 定时器，NSTimer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Observer-%E7%9B%91%E5%90%AC%E5%99%A8%EF%BC%8C%E7%94%A8%E4%BA%8E%E7%9B%91%E5%90%ACRunLoop%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">6.1.2.</span> <span class="toc-text">4. Observer : 监听器，用于监听RunLoop的状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8BRunLoop%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">七. 详细说明一下RunLoop相关类及作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CFRunLoopRef-%E8%8E%B7%E5%BE%97%E5%BD%93%E5%89%8DRunLoop%E5%92%8C%E4%B8%BBRunLoop"><span class="toc-number">7.0.0.1.</span> <span class="toc-text">CFRunLoopRef - 获得当前RunLoop和主RunLoop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CFRunLoopModeRef-RunLoop-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8F%AA%E8%83%BD%E9%80%89%E6%8B%A9%E4%B8%80%E7%A7%8D%EF%BC%8C%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%BC%8F%E4%B8%AD%E5%81%9A%E4%B8%8D%E5%90%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">7.0.0.2.</span> <span class="toc-text">CFRunLoopModeRef - RunLoop 运行模式，只能选择一种，在不同模式中做不同的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CFRunLoopSourceRef-%E4%BA%8B%E4%BB%B6%E6%BA%90%EF%BC%8C%E8%BE%93%E5%85%A5%E6%BA%90"><span class="toc-number">7.0.0.3.</span> <span class="toc-text">CFRunLoopSourceRef - 事件源，输入源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CFRunLoopTimerRef-%E5%AE%9A%E6%97%B6%E5%99%A8%E6%97%B6%E9%97%B4"><span class="toc-number">7.0.0.4.</span> <span class="toc-text">CFRunLoopTimerRef - 定时器时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CFRunLoopObserverRef-%E8%A7%82%E5%AF%9F%E8%80%85"><span class="toc-number">7.0.0.5.</span> <span class="toc-text">CFRunLoopObserverRef - 观察者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CFRunLoopModeRef"><span class="toc-number">7.0.1.</span> <span class="toc-text">1. CFRunLoopModeRef</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E4%B8%80%E7%A7%8DMode%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AASource-%E4%BA%8B%E4%BB%B6%E6%BA%90%EF%BC%8C%E8%BE%93%E5%85%A5%E6%BA%90%EF%BC%8C%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E4%BA%8B%E4%BB%B6%E6%BA%90%E4%BE%8B%E9%94%AE%E7%9B%98%E8%A7%A6%E6%91%B8%E7%AD%89-Observer-%E8%A7%82%E5%AF%9F%E8%80%85%EF%BC%8C%E8%A7%82%E5%AF%9F%E5%BD%93%E5%89%8DRunLoop%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81-%E5%92%8CTimer-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%BA%90-%E3%80%82%E4%BD%86%E6%98%AF%E5%BF%85%E9%A1%BB%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E4%B8%AASource%E6%88%96%E8%80%85Timer%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A6%82%E6%9E%9CMode%E4%B8%BA%E7%A9%BA%EF%BC%8CRunLoop%E8%BF%90%E8%A1%8C%E5%88%B0%E7%A9%BA%E6%A8%A1%E5%BC%8F%E4%B8%8D%E4%BC%9A%E8%BF%9B%E8%A1%8C%E7%A9%BA%E8%BD%AC%EF%BC%8C%E5%B0%B1%E4%BC%9A%E7%AB%8B%E5%88%BB%E9%80%80%E5%87%BA%E3%80%82"><span class="toc-number">7.0.1.0.0.1.</span> <span class="toc-text">注意：一种Mode中可以有多个Source(事件源，输入源，基于端口事件源例键盘触摸等) Observer(观察者，观察当前RunLoop运行状态) 和Timer(定时器事件源)。但是必须至少有一个Source或者Timer，因为如果Mode为空，RunLoop运行到空模式不会进行空转，就会立刻退出。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E6%B3%A8%E5%86%8C%E7%9A%845%E4%B8%AAMode"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">系统默认注册的5个Mode:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mode%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">Mode间的切换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8GCD%E4%B9%9F%E5%8F%AF%E6%98%AF%E5%88%9B%E5%BB%BA%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%8C%E8%80%8C%E4%B8%94%E6%9B%B4%E4%B8%BA%E7%B2%BE%E7%A1%AE%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9C%8B%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">7.0.1.2.1.</span> <span class="toc-text">使用GCD也可是创建计时器，而且更为精确我们来看一下代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Source1%EF%BC%9A%E5%9F%BA%E4%BA%8EPort%E7%9A%84-%E9%80%9A%E8%BF%87%E5%86%85%E6%A0%B8%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E7%9B%B8%E4%BA%92%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%EF%BC%88%E4%B8%8E%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%EF%BC%89"><span class="toc-number">7.0.1.2.2.</span> <span class="toc-text">Source1：基于Port的 通过内核和其他线程相互发送消息（与内核相关）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">7.0.1.2.3.</span> <span class="toc-text">#</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-CFRunLoopObserverRef"><span class="toc-number">7.0.2.</span> <span class="toc-text">3. CFRunLoopObserverRef</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CFRunLoopObserverRef%E6%98%AF%E8%A7%82%E5%AF%9F%E8%80%85%EF%BC%8C%E8%83%BD%E5%A4%9F%E7%9B%91%E5%90%ACRunLoop%E7%9A%84%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-RunLoop%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-number">8.</span> <span class="toc-text">八. RunLoop处理逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">8.0.1.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E4%BB%85%E4%BF%9D%E7%95%99%E4%BA%86%E4%B8%BB%E6%B5%81%E7%A8%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">8.0.1.1.</span> <span class="toc-text">源码仅保留了主流程代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-RunLoop%E9%80%80%E5%87%BA"><span class="toc-number">9.</span> <span class="toc-text">九. RunLoop退出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81-RunLoop%E5%BA%94%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">十. RunLoop应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.0.1.</span> <span class="toc-text">1. 常驻线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84RunLoop%EF%BC%8C%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%B9%B6%E4%B8%94RunLoop%E4%B8%AD%E8%A6%81%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E4%B8%AATimer-%E6%88%96-%E4%B8%80%E4%B8%AASource-%E4%BF%9D%E8%AF%81RunLoop%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BA%E7%A9%BA%E8%BD%AC%E8%80%8C%E9%80%80%E5%87%BA%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%9C%A8%E5%88%9B%E5%BB%BA%E7%9A%84%E6%97%B6%E5%80%99%E7%9B%B4%E6%8E%A5%E5%8A%A0%E5%85%A5%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%8A%A0%E5%85%A5Timer%E6%88%96%E8%80%85Source%EF%BC%8C%E6%88%96%E8%80%85%E5%8F%AA%E5%8A%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E7%9B%91%E5%90%AC%E8%80%85%EF%BC%8C%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E4%BC%9A%E5%B4%A9%E6%BA%83"><span class="toc-number">10.0.1.1.</span> <span class="toc-text">注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0"><span class="toc-number">10.0.2.</span> <span class="toc-text">2. 自动释放池</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/02/Good-night-Mr-Lawrence/" title="Good night Mr. Lawrence"><img src="https://bu.dusays.com/2023/04/02/642994002b206.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Good night Mr. Lawrence"/></a><div class="content"><a class="title" href="/2023/04/02/Good-night-Mr-Lawrence/" title="Good night Mr. Lawrence">Good night Mr. Lawrence</a><time datetime="2023-04-02T14:45:08.000Z" title="发表于 2023-04-02 22:45:08">2023-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/23/Java-Thread%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" title="Java Thread类使用方法和注意事项"><img src="https://www.apple.com.cn/newsroom/images/live-action/wwdc-2021/Apple_Developer-Tools-hero-animation-clip_060721.jpg.landing-regular_2x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java Thread类使用方法和注意事项"/></a><div class="content"><a class="title" href="/2023/02/23/Java-Thread%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" title="Java Thread类使用方法和注意事项">Java Thread类使用方法和注意事项</a><time datetime="2023-02-22T16:08:30.000Z" title="发表于 2023-02-23 00:08:30">2023-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/25/Java%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/" title="Java安全编码-用户输入"><img src="https://www.apple.com.cn/newsroom/images/live-action/wwdc-2021/Apple_Developer-Tools-hero-animation-clip_060721.jpg.landing-regular_2x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java安全编码-用户输入"/></a><div class="content"><a class="title" href="/2023/01/25/Java%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/" title="Java安全编码-用户输入">Java安全编码-用户输入</a><time datetime="2023-01-24T16:38:06.000Z" title="发表于 2023-01-25 00:38:06">2023-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/23/Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%B7%B1%E5%85%A5%E5%88%A9%E7%94%A8%E5%8F%8A%E5%88%86%E6%9E%90/" title="Nginx解析漏洞深入利用及分析"><img src="https://www.apple.com.cn/newsroom/images/passions/education/Apple-STEAM-Day-hero_Full-Bleed-Image.jpg.large_2x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx解析漏洞深入利用及分析"/></a><div class="content"><a class="title" href="/2023/01/23/Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%B7%B1%E5%85%A5%E5%88%A9%E7%94%A8%E5%8F%8A%E5%88%86%E6%9E%90/" title="Nginx解析漏洞深入利用及分析">Nginx解析漏洞深入利用及分析</a><time datetime="2023-01-23T15:28:26.000Z" title="发表于 2023-01-23 23:28:26">2023-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/04/Chrome-V8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2022-1310/" title="Chrome V8命令执行漏洞分析（CVE-2022-1310）"><img src="https://www.apple.com.cn/newsroom/images/values/corporate/standard/Apple_google-partner-on-covid-19-contact-tracing-technology_04102020_inline.jpg.large_2x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chrome V8命令执行漏洞分析（CVE-2022-1310）"/></a><div class="content"><a class="title" href="/2022/09/04/Chrome-V8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2022-1310/" title="Chrome V8命令执行漏洞分析（CVE-2022-1310）">Chrome V8命令执行漏洞分析（CVE-2022-1310）</a><time datetime="2022-09-04T12:01:52.000Z" title="发表于 2022-09-04 20:01:52">2022-09-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/07/20/tOoYKRE7fMVdb6x.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Small Waste</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://apple.com">Developer</a><span class="footer-separator">|</span><span>主题 </span><a href="">ADD</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://www.xiaojingye.top/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://xiaojingye.zeabur.app',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://xiaojingye.zeabur.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="8556824432" data-server="tencent" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="-1"> </div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,自由,平等,公正,法制,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/issues.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>