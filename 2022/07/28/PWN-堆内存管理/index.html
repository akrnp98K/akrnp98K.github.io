<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>PWN &amp; 堆内存管理 | Remarkable</title><meta name="author" content="Small Waste"><meta name="copyright" content="Small Waste"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="分析堆的相关工具在 Phrack 的一篇文章中 《Advanced Doug Lea’s malloc exploits》, 有一小节讲到 Heap layout analysis 作者利用了 main_arena 这个静态全局变量, 进行 heap dump 工作, 这里需要注意的是, 需要安装"><link rel="shortcut icon" href="https://s2.loli.net/2022/07/21/dTarQcplR5zGN4W.png"><link rel="canonical" href="https://www.xiaojingye.top/2022/07/28/PWN-%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?86771261f70d87991b3ee29ce2dac0b1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"./search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PWN & 堆内存管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-28 14:57:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="baidu-site-verification" content="codeva-j2TLeETEme" /><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/07/20/N1DLlaqMkj5fK7U.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fa-solid fa-image"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/Message/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.apple.com.cn/newsroom/images/values/health/Apple-Health-study-July-2022-hero.jpg.landing-regular_2x.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Remarkable</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fa-solid fa-image"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/Message/"><i class="fa-fw fa-fw fas fa-comment-dots"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PWN &amp; 堆内存管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-28T05:52:51.000Z" title="发表于 2022-07-28 13:52:51">2022-07-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-28T06:57:30.000Z" title="更新于 2022-07-28 14:57:30">2022-07-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BA%95%E5%B1%82/">底层</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PWN &amp; 堆内存管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="分析堆的相关工具"><a href="#分析堆的相关工具" class="headerlink" title="分析堆的相关工具"></a>分析堆的相关工具</h1><p>在 Phrack 的一篇文章中 《Advanced Doug Lea’s malloc exploits》, 有一小节讲到 Heap layout analysis 作者利用了 main_arena 这个静态全局变量, 进行 heap dump 工作, 这里需要注意的是, 需要安装 libc6-dbg 以获取 debugging symbols, 此细节部分请查看 参考资料/glibc的调试相关.</p>
<p>介绍几个工具, 用于堆空间分配的分析.</p>
<p>几个工具大同小异, 简单介绍下原理, 都是采用 python 的 gdb 的 API。</p>
<p>之后通过 cat /proc/PID/maps 获取 heap base, 通过 gdb 的 x/ 查看内存, 通过 debugging symbols 获取 main_arena 地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/cloudburst/libheap</span><br><span class="line">https://github.com/Mipu94/peda-heap</span><br><span class="line">https://github.com/hugsy/gef</span><br><span class="line">https://github.com/pwndbg/pwndbg</span><br></pre></td></tr></table></figure>
<ul>
<li><p>ltrace:<br>通过 ltrace 函数跟踪库函数调用。大致原理是, 起一个进程执行命令后, 根据 PID 拿到可执行文件, 之后按照 ELF 解析可执行文件, 拿到符号列表, 之后使用 ptrace attach 到 PID 上, 并在所有函数符号上插入断点。</p>
</li>
<li><p>通过 LD_PRELOAD 的 hook 方式跟踪内存分配函数, 这也是 Phrack 中 《Advanced Doug Lea’s malloc exploits》 利用的方法, 缺点就是需要重新执行程序</p>
</li>
</ul>
<h1 id="堆内存分配-ptmalloc设计-的思考"><a href="#堆内存分配-ptmalloc设计-的思考" class="headerlink" title="堆内存分配(ptmalloc设计)的思考"></a>堆内存分配(ptmalloc设计)的思考</h1><blockquote>
<p>下面是个人想法</p>
</blockquote>
<h2 id="为什么需要-ptmalloc"><a href="#为什么需要-ptmalloc" class="headerlink" title="为什么需要 ptmalloc"></a>为什么需要 ptmalloc</h2><p>首先内存的分配和回收很频繁的, 这也就是其他语言希望实现高效的 GC, 针对频繁的操作, 第一个想到的解决方法就是缓存, 这也就是为什么 ptmalloc 存在各种各样的缓冲区. 假如不存在缓冲区, 每次分配都需要触发系统调用贼慢. 接下来就要引出 ptmalloc 涉及到的几种缓存, 这里只是概念性的解释几种缓存, 具体会在下文详细介绍.</p>
<h2 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h2><p>为了避免每次触发系统调用, 首先想到的解决方法就是释放的内存暂时不归还给系统, 标记为空闲, 等下一次再需要相同大小时, 直接使用这块空闲内存即可. （存储结构是双向环链表, 类似 hash 表, hash 算法就是 chunk 的长度, 用双向环链表解决 hash 冲突)</p>
<p>这涉及到, 刚刚释放的内存什么时候加到 Bins ? 相邻的两个空闲 chunk 什么时候合并? 怎么合并?</p>
<h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><p>另一个应该想到的就是, 可以先利用系统调用 brk() 分配一块比较大的内存作为缓存, 之后即使没有在 Bins 中也找不到, 也不需要每次触发系统调用, 直接切割这块大的内存即可.</p>
<p>这就涉及到 ‘这块大内存’ 什么时候重新补充大小(不断切割会导致 top 变小)? 什么时候需要缩小(归还给系统)?</p>
<h2 id="Fastbins"><a href="#Fastbins" class="headerlink" title="Fastbins"></a>Fastbins</h2><p>Bins 和 Top 缓存是最基本的, 如果想要做进一步的优化, 其实就是更细分的缓存, 也就是更准确的命中缓存, 这里 Fastbins 存在的更具体的原因是 避免 chunk 重复切割合并.</p>
<p>如果了解过 Python 源码可能会更理解, 这里的 Fastbins 类似于 Python 中整数对象 PyIntObject 的小整数 small_ints, 这里也只是理念类似, small_ints 准确的说是预先初始化, 可以一直重复使用而不被释放.</p>
<p>再回到 Fastbins 的讨论, 对于长度很小的 chunk 在释放后不会放到 Bins, 也不会标记为空闲, 这就避免了合并, 下次分配内存时首先查找 Fastbins, 这就避免了切割.</p>
<h2 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h2><p>Unsorted 是更细粒度的缓存, 属于 ‘刚刚释放的内存’与 Bins 之间的缓存.</p>
<h2 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last_remainder"></a>last_remainder</h2><p>这其实也是一个缓存, 是针对于切割时使用的, 大致就是希望一直切割同一个 chunk. 在遍历 Unsorted 时使用, 但是它的使用是有条件的.</p>
<p>以上是在ptmalloc 的缓存设计上的一些想法. 下面会具体介绍 ptmalloc 在进行堆内存用到的各种具体的数据结构.</p>
<h1 id="chunk-结构"><a href="#chunk-结构" class="headerlink" title="chunk 结构"></a>chunk 结构</h1><p>贴出一段 glibc-2.19/malloc/malloc.c 中关于 chunk 的解释. </p>
<p><code>boundary tag</code> 边界标记, 关于它下文会进行介绍<br><code>INTERNAL_SIZE_T</code> 头部损耗, 参考 <code>eglibc-2.19/malloc/malloc.c:299</code>, 其实就是 <code>size_t</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1094</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -----------------------  Chunk representations -----------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个 chunk 的完整结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   malloc_chunk details:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (The following includes lightly edited explanations by Colin Plumb.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // chunk 的内存管理采用边界标识的方法, 空闲 chunk 的 size 在该 chunk 的 size 字段和下一个 chunk 的 pre_size 字段都有记录</span></span><br><span class="line"><span class="comment">    Chunks of memory are maintained using a `boundary tag&#x27; method as</span></span><br><span class="line"><span class="comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">    survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">    in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">    size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">    in use.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 正在使用的 chunk 布局</span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Size of previous chunk, if allocated            | |</span></span><br><span class="line"><span class="comment">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Size of chunk, in bytes                       |M|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">      .                                                               .</span></span><br><span class="line"><span class="comment">      .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">      .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Size of chunk                                     |</span></span><br><span class="line"><span class="comment">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 几个术语规定, &#x27;chunk&#x27; 就是整个 chunk 开头, &#x27;mem&#x27; 就是用户数据的开始, &#x27;Nextchunk&#x27; 就是下一个 chunk 的开头</span></span><br><span class="line"><span class="comment">    Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">    the malloc code, but &quot;mem&quot; is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">    user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // chunk 是双字长对齐</span></span><br><span class="line"><span class="comment">    Chunks always begin on even word boundaries, so the mem portion</span></span><br><span class="line"><span class="comment">    (which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">    thus at least double-word aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 空闲 chunk 被存放在双向环链表</span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Size of previous chunk                            |</span></span><br><span class="line"><span class="comment">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">      |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">      .                                                               .</span></span><br><span class="line"><span class="comment">      .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:&#x27; |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // P 标志位不能放在 size 字段的低位字节, 用于表示前一个 chunk 是否在被使用, 如果为 0, 表示前一个 chunk 空闲, 同时 pre_size 也表示前一个空闲 chunk 的大小, 可以用于找到前一个 chunk 的地址, 方便合并空闲 chunk, 但 chunk 刚一开始分配时默认 P 为 1. 如果 P 标志位被设置, 也就无法获取到前一个 chunk 的 size, 也就拿不到前一个 chunk 地址, 也就无法修改正在使用的 chunk, 但是这是无法修改前一个 chunk, 但是可以通过本 chunk 的 size 获得下一个 chunk 的地址. </span></span><br><span class="line"><span class="comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">    chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">    word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">    size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">    The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">    preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">    the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">    addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Note that the `foot&#x27; of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">    as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">    deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">    to extend or adapt this code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The two exceptions to all this are</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 这里的 the trailing size 是指下一个 chunk 的 pre_size, 因为 top 位于最高地址, 不存在相邻的下一个 chunk, 同时这里也解答了上面关于 top 什么时候重新填满</span></span><br><span class="line"><span class="comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">  trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">  that would have to index off it. After initialization, `top&#x27;</span></span><br><span class="line"><span class="comment">  is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">  MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">  bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">  allocated one-by-one, each must contain its own trailing size field.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><code>P (PREV_INUSE)</code> 标志位表示前一个 chunk 是否在使用, 0 为没有在使用.</p>
<p><code>prev_size</code> 表示前一个 chunk 的大小, 仅在<code>P (PREV_INUSE)</code>为 0 时有效, 也就是前一个 chunk 为空闲状态.</p>
<p><code>size</code> 表示该整个 chunk 大小, 并非 malloc 返回值.</p>
<p><code>fd</code>, <code>bk</code>, <code>fd_nextsize</code>,<code>fd_nextsize</code>是对于空闲 chunk 而言, 对于正在使用的 chunk, 从当前位置开始就是 malloc 返回给用户可用的空间.</p>
<p><code>fd</code>, <code>bk</code> 组成了<code>Bins</code>的双向环链表</p>
<p>对于空闲的 chunk 空间布局, 见上, 是环形双向链表. 存放在空闲 chunk 容器中.</p>
<p>关于 chunk 有一些操作, 判断前一个是否在使用, 判断下一个 chunk 是否正在使用, 是不是 <code>mmap</code> 分配的, 以及对标志位 P 等的操作.</p>
<h1 id="边界标示"><a href="#边界标示" class="headerlink" title="边界标示"></a>边界标示</h1><p>对于 chunk 的空间布局组织采用边界标示的方法, chunk 的存储是一段连续的内存, 其实就是 chunk 头部保存长度信息, 可以在适当的时候获取到前一个和后一个 chunk.</p>
<p>这里涉及到 chunk 到用户请求 mem 的想换转化操作, 以及对齐操作等. </p>
<h1 id="空间复用"><a href="#空间复用" class="headerlink" title="空间复用"></a>空间复用</h1><p>对于正在使用 chunk, 它的下一个 chunk 的<code>prev_size</code>是无效的, 所以这块内存被当前 chunk 给借用了, 因此对于请求分配 chunk 大小分配公式是<code>chunk_size = (用户请求大小 + (2 - 1) * sizeof(INTERNAL_SIZE_T)) align to 2 * sizeof(size_t)</code></p>
<p>最后参考 eglibc-2.19/malloc/malloc.c:44, 会指出一些默认参数值, 以及关于 chunk 的最小 size 和 对齐的相关说明. 这里列出一小部分.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Supported pointer representation:       <span class="number">4</span> or <span class="number">8</span> bytes</span><br><span class="line">  Supported <span class="type">size_t</span>  representation:       <span class="number">4</span> or <span class="number">8</span> bytes</span><br><span class="line">       Note that <span class="type">size_t</span> is allowed to be <span class="number">4</span> bytes even <span class="keyword">if</span> pointers are <span class="number">8.</span></span><br><span class="line">       You can adjust this by defining INTERNAL_SIZE_T</span><br><span class="line"></span><br><span class="line">  Alignment:                              <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">size_t</span>) (<span class="keyword">default</span>)</span><br><span class="line">       (i.e., <span class="number">8</span> byte alignment with <span class="number">4b</span>yte <span class="type">size_t</span>). This suffices <span class="keyword">for</span></span><br><span class="line">       nearly all current machines and C compilers. However, you can</span><br><span class="line">       define MALLOC_ALIGNMENT to be wider than this <span class="keyword">if</span> necessary.</span><br><span class="line"></span><br><span class="line">  Minimum overhead per allocated chunk:   <span class="number">4</span> or <span class="number">8</span> bytes</span><br><span class="line">       Each malloced chunk has a hidden word of overhead holding size</span><br><span class="line">       and status information.</span><br><span class="line"></span><br><span class="line">  Minimum allocated size: <span class="number">4</span>-byte ptrs:  <span class="number">16</span> bytes    (including <span class="number">4</span> overhead)</span><br><span class="line">              <span class="number">8</span>-byte ptrs:  <span class="number">24</span>/<span class="number">32</span> bytes (including, <span class="number">4</span>/<span class="number">8</span> overhead)</span><br><span class="line"></span><br><span class="line">       When a chunk is freed, <span class="number">12</span> (<span class="keyword">for</span> <span class="number">4b</span>yte ptrs) or <span class="number">20</span> (<span class="keyword">for</span> <span class="number">8</span> byte</span><br><span class="line">       ptrs but <span class="number">4</span> byte size) or <span class="number">24</span> (<span class="keyword">for</span> <span class="number">8</span>/<span class="number">8</span>) additional bytes are</span><br><span class="line">       needed; <span class="number">4</span> (<span class="number">8</span>) <span class="keyword">for</span> a trailing size field and <span class="number">8</span> (<span class="number">16</span>) bytes <span class="keyword">for</span></span><br><span class="line">       <span class="built_in">free</span> <span class="built_in">list</span> pointers. Thus, the minimum allocatable size is</span><br><span class="line">       <span class="number">16</span>/<span class="number">24</span>/<span class="number">32</span> bytes.</span><br><span class="line"></span><br><span class="line">       Even a request <span class="keyword">for</span> zero <span class="title function_">bytes</span> <span class="params">(i.e., <span class="built_in">malloc</span>(<span class="number">0</span>))</span> returns a</span><br><span class="line">       pointer to something of the minimum allocatable size.</span><br><span class="line"></span><br><span class="line">       The maximum overhead <span class="title function_">wastage</span> <span class="params">(i.e., number of extra bytes</span></span><br><span class="line"><span class="params">       allocated than were requested in <span class="built_in">malloc</span>)</span> is less than or equal</span><br><span class="line">       to the minimum size, except <span class="keyword">for</span> requests &gt;= mmap_threshold that</span><br><span class="line">       are serviced via <span class="title function_">mmap</span><span class="params">()</span>, where the worst <span class="keyword">case</span> wastage is 2 *</span><br><span class="line">       <span class="title function_">sizeof</span><span class="params">(<span class="type">size_t</span>)</span> bytes plus the remainder from a system <span class="title function_">page</span> <span class="params">(the</span></span><br><span class="line"><span class="params">       minimal mmap unit)</span>; typically <span class="number">4096</span> or <span class="number">8192</span> bytes.</span><br></pre></td></tr></table></figure><br>翻译几个关键的点, chunk 的大小需要按照 Alignment 进行对齐, 每一个被分配的 chunk 都有一个字的头部消耗, 包含该 chunk 的大小以及状态信息, 具体会在 chunk 结构和边界标示说明.</p>
<h1 id="空闲容器-缓存"><a href="#空闲容器-缓存" class="headerlink" title="空闲容器(缓存)"></a>空闲容器(缓存)</h1><p>下面会介绍 ptmalloc 中存在的各种空闲容器</p>
<p>Bins<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1341</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   -------------------- Internal data structures --------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   All internal state is held in an instance of malloc_state defined</span></span><br><span class="line"><span class="comment">   below. There are no other static variables, except in two optional</span></span><br><span class="line"><span class="comment">   cases:</span></span><br><span class="line"><span class="comment"> * If USE_MALLOC_LOCK is defined, the mALLOC_MUTEx declared above.</span></span><br><span class="line"><span class="comment"> * If mmap doesn&#x27;t support MAP_ANONYMOUS, a dummy file descriptor</span></span><br><span class="line"><span class="comment">     for mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Beware of lots of tricks that minimize the total bookkeeping space</span></span><br><span class="line"><span class="comment">   requirements. The result is a little over 1K bytes (for 4byte</span></span><br><span class="line"><span class="comment">   pointers and size_t.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bins</span></span><br><span class="line"><span class="comment">    // Bins 就是由空闲 chunk - bin 组成数组, 每一个 bin 都是双向链表. Bin 存放是整理过的 chunks, 并且 bin 中合并过的空闲 chunk 是不存在相邻的, 所以 bin 中的每一个 chunk 都是可以被使用, 并且都是紧挨着正在使用的 chunk 或者 heap  内存末尾.</span></span><br><span class="line"><span class="comment">    An array of bin headers for free chunks. Each bin is doubly</span></span><br><span class="line"><span class="comment">    linked.  The bins are approximately proportionally (log) spaced.</span></span><br><span class="line"><span class="comment">    There are a lot of these bins (128). This may look excessive, but</span></span><br><span class="line"><span class="comment">    works very well in practice.  Most bins hold sizes that are</span></span><br><span class="line"><span class="comment">    unusual as malloc request sizes, but are more usual for fragments</span></span><br><span class="line"><span class="comment">    and consolidated sets of chunks, which is what these bins hold, so</span></span><br><span class="line"><span class="comment">    they can be found quickly.  All procedures maintain the invariant</span></span><br><span class="line"><span class="comment">    that no consolidated chunk physically borders another one, so each</span></span><br><span class="line"><span class="comment">    chunk in a list is known to be preceeded and followed by either</span></span><br><span class="line"><span class="comment">    inuse chunks or the ends of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // bins 中的 chunk 是按照大小排序的. FIFO, small bins 是不存在按大小排序的, 因为每一个 small bin 都是相同 size 的. 但是对于 large bin 是需要按照顺序插入的. 这样可以在内存分配时很快查找到合适内存.</span></span><br><span class="line"><span class="comment">    Chunks in bins are kept in size order, with ties going to the</span></span><br><span class="line"><span class="comment">    approximately least recently used chunk. Ordering isn&#x27;t needed</span></span><br><span class="line"><span class="comment">    for the small bins, which all contain the same-sized chunks, but</span></span><br><span class="line"><span class="comment">    facilitates best-fit allocation for larger chunks. These lists</span></span><br><span class="line"><span class="comment">    are just sequential. Keeping them in order almost never requires</span></span><br><span class="line"><span class="comment">    enough traversal to warrant using fancier ordered data</span></span><br><span class="line"><span class="comment">    structures.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // FIFO, 从头部插入节点, 尾部取节点. 这样有个特定就是更容易内存的合并.</span></span><br><span class="line"><span class="comment">    Chunks of the same size are linked with the most</span></span><br><span class="line"><span class="comment">    recently freed at the front, and allocations are taken from the</span></span><br><span class="line"><span class="comment">    back.  This results in LRU (FIFO) allocation order, which tends</span></span><br><span class="line"><span class="comment">    to give each chunk an equal opportunity to be consolidated with</span></span><br><span class="line"><span class="comment">    adjacent freed chunks, resulting in larger free chunks and less</span></span><br><span class="line"><span class="comment">    fragmentation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To simplify use in double-linked lists, each bin header acts</span></span><br><span class="line"><span class="comment">    as a malloc_chunk. This avoids special-casing for headers.</span></span><br><span class="line"><span class="comment">    But to conserve space and improve locality, we allocate</span></span><br><span class="line"><span class="comment">    only the fd/bk pointers of bins, and then use repositioning tricks</span></span><br><span class="line"><span class="comment">    to treat these as the fields of a malloc_chunk*.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><br>ptmalloc 采用分箱式管理空闲 chunk, 也就是 Bins. Bins 本身就是一个数组, 每一个存放的是一个对应长度的 chunk 双向环链表的头结点和尾节点. 相同 Size 的 chunk 才能组成一个环,Bins 是按大小依次进行存放.</p>
<p>关于 Bins 为什么定义为 <code>mchunkptr bins[NBINS * 2 - 2]</code>而不是 <code>mchunkptr bins[NBINS * 4 - 2]</code>, 是如何少一倍的空间实现的双向链表,大致说一下, 对于双向环的的标志头节点, 它的 <code>prev_size</code> 和 <code>size</code> 是无用的, 所以直接省略, 但是还要把它当成正确的 chunk 结构. 这里的<code>trick</code>就在于 <code>bin_at</code> 宏, 返回了伪造的 fake chunk 的地址, 这里和<code>Double Free</code>以及 <code>unlink</code>绕过的利用手法类似.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))               \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure></p>
<p>举一个例子, 只摘取一部分, 完整的例子, 在下方的 ptmalloc 利用部分.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查看 unsorted bin 的地址, 其实也就是 bin[<span class="number">1</span>] 的地址</span><br><span class="line">(gdb) heap -b</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">unsorted bin @ <span class="number">0x7ffff7dd1b88</span></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602160</span> - size <span class="number">0x90</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x6020b0</span> - size <span class="number">0x90</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602000</span> - size <span class="number">0x90</span></span><br><span class="line"># 这里的 <span class="number">0x7ffff7dd1B78</span> 也就是 bin_at 返回的地址, 返回了一个伪造的 chunk 的地址</span><br><span class="line"># 其实这里的 fd 和 bk 才真正属于 bin[<span class="number">1</span>] 的内容.</span><br><span class="line">(gdb) p *(mfastbinptr)<span class="number">0x7ffff7dd1B78</span></span><br><span class="line">$<span class="number">17</span> = &#123;prev_size = <span class="number">6300176</span>, size = <span class="number">0</span>, fd = <span class="number">0x602160</span>, bk = <span class="number">0x602000</span>, fd_nextsize = <span class="number">0x7ffff7dd1b88</span> &lt;main_arena+<span class="number">104</span>&gt;, bk_nextsize = <span class="number">0x7ffff7dd1b88</span> &lt;main_arena+<span class="number">104</span>&gt;&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="small-bins-large-bins"><a href="#small-bins-large-bins" class="headerlink" title="small bins, large bins"></a>small bins, large bins</h1><p>对于 chunk <code>size &lt; 512</code>, 是存放在 small bins, 有 64 个, 每个 bin 是以 8 bytes 作为分割边界, 也就相当于等差序列, 举个例子: small bins 中存放的第一个<code>chunk 双向环链表</code>全部都是由 size 为 16 bytes 大小的 chunk 组成的, 第二个<code>chunk 双向环链表</code>都是由 size 为 16+8 bytes 大小的 chunk 组成的. 但是对于 large bins, 分割边界是递增的, 举个简单例子: 前 32 个 large bins 的分割边界都是 64 bytes, 之后 16 个 large bins 的分割边界是 512 bytes. 以上仅为字长为 32 位的情况下, 具体请参考如下.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1436</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>large bin 有些特殊, 空闲 chunk 的存放需要排序, large_bin-&gt;bk 为最小 size 的 chunk, large_bin-&gt;fd 为最大 size 的 chunk.</p>
<h1 id="Fastbins-1"><a href="#Fastbins-1" class="headerlink" title="Fastbins"></a>Fastbins</h1><p>关于 Fastbins 的介绍, 可以参考:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Fastbins</span></span><br><span class="line"><span class="comment">    // 单向链表, LIFO 规则</span></span><br><span class="line"><span class="comment">    An array of lists holding recently freed small chunks.  Fastbins</span></span><br><span class="line"><span class="comment">    are not doubly linked.  It is faster to single-link them, and</span></span><br><span class="line"><span class="comment">    since chunks are never removed from the middles of these lists,</span></span><br><span class="line"><span class="comment">    double linking is not necessary. Also, unlike regular bins, they</span></span><br><span class="line"><span class="comment">    are not even processed in FIFO order (they use faster LIFO) since</span></span><br><span class="line"><span class="comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span></span><br><span class="line"><span class="comment">    fastbins are normally used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">    other free chunks.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>当进行内存分配时先从 Fastbins 中进行查找, 之后才在 Bins 进行查找; 释放内存时, 当<code>chunk size &lt; max_fast</code>会先存放到 Fastbins.</p>
<p>另一个需要注意的点就是 Fastbins 的合并(清空), 也就是 <code>malloc_consolidate</code>这个函数的工作.</p>
<ul>
<li><p>何时会触发 malloc_consolidate(仅对 _int_malloc 函数而言) ?</p>
</li>
<li><p>small bins 尚未初始化</p>
</li>
<li><p>需要 size 大于 small bins</p>
</li>
<li><p><code>malloc_consolidate</code> 如何进行合并 ?</p>
</li>
</ul>
<p>遍历 Fastbins 中的 chunk, 设置每个 chunk 的空闲标志位为 0, 并合并相邻的空闲 chunk, 之后把该 chunk 存放到 unsorted bin 中.</p>
<p>Fastbins 是单向链表, 可以通过 <code>fastbin-&gt;fd</code>遍历 Fastbins.</p>
<h1 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h1><p>只有一个 <code>unsorted bin</code>, 进行内存分配查找时先在 Fastbins, small bins 中查找, 之后会在 unsorted bin 中进行查找, 并整理 unsorted bin 中所有的 chunk 到 Bins 中对应的 Bin. unsorted bin 位于<code>bin[1]</code>.</p>
<p><code>unsorted_bin-&gt;fd</code> 指向双向环链表的头结点, <code>unsorted_bin-&gt;bk</code>指向双向环链表的尾节点, 在头部插入新的节点.</p>
<h1 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h1><p>以下引用来自 《glibc内存管理ptmalloc源代码分析》。</p>
<blockquote>
<p>对于非主分配区会预先从 mmap 区域分配一块较大的空闲内存模拟 sub-heap,通过管 理 sub-heap 来响应用户的需求,因为内存是按地址从低向高进行分配的,在空闲内存的最 高处,必然存在着一块空闲 chunk,叫做 top chunk.当 bins 和 fast bins 都不能满足分配需 要的时候,ptmalloc 会设法在 top chunk 中分出一块内存给用户,如果 top chunk 本身不够大, 分配程序会重新分配一个 sub-heap,并将 top chunk 迁移到新的 sub-heap 上, 新的 sub-heap 与已有的 sub-heap 用单向链表连接起来,然后在新的 top chunk 上分配所需的内存以满足分配的需要,实际上,top chunk 在分配时总是在 fast bins 和 bins 之后被考虑,所以,不论 top chunk 有多大,它都不会被放到 fast bins 或者是 bins 中. top chunk 的大小是随着分配和回 收不停变换的,如果从 top chunk 分配内存会导致 top chunk 减小,如果回收的 chunk 恰好 与 top chunk 相邻,那么这两个 chunk 就会合并成新的 top chunk,从而使 top chunk 变大. 如果在 free 时回收的内存大于某个阈值,并且 top chunk 的大小也超过了收缩阈值,ptmalloc 会收缩 sub-heap,如果 top-chunk 包含了整个 sub-heap,ptmalloc 会调用 munmap 把整个 sub-heap 的内存返回给操作系统.</p>
<p>由于主分配区是唯一能够映射进程 heap 区域的分配区,它可以通过 sbrk()来增大或是 收缩进程 heap 的大小,ptmalloc 在开始时会预先分配一块较大的空闲内存 (也就是所谓的 heap), 主分配区的 top chunk 在第一次调用 mallocd 时会分配一块(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap,用户从 top chunk 分配内存时,可以直接取出一块内 存给用户.在回收内存时,回收的内存恰好与 top chunk 相邻则合并成新的 top chunk,当该次回收的空闲内存大小达到某个阈值,并且 top chunk 的大小也超过了收缩阈值,会执行内 存收缩,减小 top chunk 的大小,但至少要保留一个页大小的空闲内存,从而把内存归还给 操作系统.如果向主分配区的 top chunk 申请内存,而 top chunk 中没有空闲内存, ptmalloc 会调用 sbrk()将的进程 heap 的边界 brk 上移, 然后修改 top chunk 的大小.</p>
</blockquote>
<p>top chunk 位于最高地址.</p>
<h1 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h1><blockquote>
<p>当需要分配的 chunk 足够大,而且 fast bins 和 bins 都不能满足要求,甚至 top chunk 本 身也不能满足分配需求时,ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空 间.这样分配的 chunk 在被 free 时将直接解除映射,于是就将内存归还给了操作系统,再 次对这样的内存区的引用将导致 segmentation fault 错误.这样的 chunk 也不会包含在任何 bin 中.</p>
</blockquote>
<h1 id="Last-remainder"><a href="#Last-remainder" class="headerlink" title="Last remainder"></a>Last remainder</h1><blockquote>
<p>Last remainder 是另外一种特殊的 chunk,就像 top chunk 和 mmaped chunk 一样,不会 在任何 bins 中找到这种 chunk.当需要分配一个 small chunk, 但在 small bins 中找不到合适 的 chunk, 如果 last remainder chunk 的大小大于所需的 small chunk 大小,last remainder chunk 被分裂成两个 chunk, 其中一个 chunk 返回给用户, 另一个 chunk 变成新的 last remainder chuk.</p>
</blockquote>
<h1 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h1><p>只存在一个主分区, 但是允许多个非主分区, 主分配区域可以访问 heap 区域 和 mmap 区域, 非主分区只能访问 mmap 区域, 每次用 mmap 分配一块大小的内存当做 sub-heap, 用于模拟 heap. 每次进行内存分配必须加锁请求一个分配区.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1663</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ----------- Internal state representation and initialization -----------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> THREAD_STATS</span></span><br><span class="line">  <span class="comment">/* Statistics for locking.  Only used if THREAD_STATS is defined.  */</span></span><br><span class="line">  <span class="type">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于 <code>malloc_init_state</code>的定义在:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">1768</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Initialize a malloc_state struct.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This is called only from within malloc_consolidate, which needs</span></span><br><span class="line"><span class="comment">   be called in the same contexts anyway.  It is never called directly</span></span><br><span class="line"><span class="comment">   outside of malloc_consolidate because some optimizing compilers try</span></span><br><span class="line"><span class="comment">   to inline it at all call points, which turns out not to be an</span></span><br><span class="line"><span class="comment">   optimization at all. (Inlining it in malloc_consolidate is fine though.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><br>在 <code>eglibc-2.19/malloc/malloc.c:1741</code>有一个已经初始化的主分配区 main_arena, 根据 ELF 的结构解析, 已初始化的全局变量存放在 .data 段, 下图作为实践.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">33</span> 是 Section 的 Index</span><br><span class="line">λ : readelf -s /usr/lib/debug<span class="comment">//lib/x86_64-linux-gnu/libc-2.23.so | grep main_arena </span></span><br><span class="line">   <span class="number">915</span>: <span class="number">00000000003</span>c3b20  <span class="number">2192</span> OBJECT  LOCAL  DEFAULT   <span class="number">33</span> main_arena</span><br><span class="line"># 对应 <span class="number">33</span> 的 Section 恰好为 .data</span><br><span class="line">λ : readelf -S /usr/lib/debug<span class="comment">//lib/x86_64-linux-gnu/libc-2.23.so | grep .data</span></span><br><span class="line">  [<span class="number">16</span>] .rodata           NOBITS           <span class="number">0000000000174720</span>  <span class="number">000002b</span>4</span><br><span class="line">  [<span class="number">23</span>] .tdata            NOBITS           <span class="number">00000000003b</span>f7c0  <span class="number">001b</span>f7c0</span><br><span class="line">  [<span class="number">29</span>] .data.rel.ro      NOBITS           <span class="number">00000000003b</span>f900  <span class="number">001b</span>f7c0</span><br><span class="line">  [<span class="number">33</span>] .data             NOBITS           <span class="number">00000000003</span>c3080  <span class="number">001b</span>f7c0</span><br></pre></td></tr></table></figure></p>
<h1 id="int-malloc-分析"><a href="#int-malloc-分析" class="headerlink" title="_int_malloc() 分析"></a>_int_malloc() 分析</h1><p>先获取分配区指针, 这个过程设计到分配区初始化和分配区加锁, 之后使用 <code>_int_malloc</code> 进行核心的内存分配.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">3295</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ------------------------------ malloc ------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>这一段分析来自 《glibc内存管理ptmalloc源代码分析》 但是对其中几个步骤做了补充和添加, 可以对比看一下 (以下针对 32 位字长)</p>
<p>ptmalloc 的响应用户内存分配要求的具体步骤为:</p>
<ol>
<li><p>获取分配区的锁, 为了防止多个线程同时访问同一个分配区, 在进行分配之前需要取得分配区域的锁. 线程先查看线程私有实例中是否已经存在一个分配区, 如果存 在尝试对该分配区加锁, 如果加锁成功, 使用该分配区分配内存, 否则, 该线程搜 索分配区循环链表试图获得一个空闲（没有加锁）的分配区. 如果所有的分配区都 已经加锁, 那么 ptmalloc 会开辟一个新的分配区, 把该分配区加入到全局分配区循 环链表和线程的私有实例中并加锁, 然后使用该分配区进行分配操作. 开辟出来的 新分配区一定为非主分配区, 因为主分配区是从父进程那里继承来的. 开辟非主分配区时会调用 mmap()创建一个 sub-heap, 并设置好 top chunk.</p>
</li>
<li><p>将用户的请求大小转换为实际需要分配的 chunk 空间大小. 具体查看 request2size 宏 (malloc.c:3332)</p>
</li>
<li><p>判断所需分配 chunk 的大小是否满足 chunk_size &lt;= max_fast (max_fast 默认为 64B), 如果是的话, 则转下一步, 否则跳到第 5 步. (malloc.c:3340)</p>
</li>
<li><p>首先尝试在 Fastbins 中查找所需大小的 chunk 分配给用户. 如果可以找到, 则分配结束. 否则转到下一步. (malloc.c:3340)</p>
</li>
<li><p>判断所需大小是否处在 small bins 中, 即判断 chunk_size &lt; 512B 是否成立. 如果 chunk 大小处在 small bins 中, 则转下一步, 否则转到第 7 步. (malloc.c:3377)</p>
</li>
<li><p>根据所需分配的 chunk 的大小, 找到具体所在的某个 small bin, 从该 Bin 的尾部摘取一个恰好满足大小的 chunk. 若成功, 则分配结束, 否则, 转到 8. (malloc.c:3377)</p>
</li>
<li><p>到了这一步, 说明需要分配的是一块大的内存, 于是, ptmalloc 首先会遍历 Fastbins 中的 chunk, 将相邻的空闲 chunk 进行合并, 并链接到 unsorted bin 中. 对于 Fastbins 的合并是由 malloc_consolidate 做处理. (malloc.c:3421)</p>
</li>
<li><p>遍历 unsorted bin 中的 chunk, 如果请求的 chunk 是一个 small chunk, 且 unsorted bin 只有一个 chunk, 并且这个 chunk 在上次分配时被使用过(也就是 last_remainder), 并且 chunk 的大小大于 (分配的大小 + MINSIZE), 这种情况下就直接将该 chunk 进行切割, 分配结束, 否则继续遍历, 如果发现一个 unsorted bin 的 size 恰好等于需要分配的 size, 命中缓存, 分配结束, 否则将根据 chunk 的空间大小将其放入对应的 small bins 或是 large bins 中, 遍历完成后, 转入下一步. (malloc.c:3442)</p>
</li>
<li><p>到了这一步说明需要分配的是一块大的内存, 并且 Fastbins 和 unsorted bin 中所有的 chunk 都清除干净 了. 从 large bins 中按照 “smallest-first, best-fit”(最小&amp;合适, 也就是说大于或等于所需 size 的最小 chunk) 原则, 找一个合适的 chunk, 从中划分一块合适大小的 chunk 进行切割, 并将剩下的部分放到 unsorted bin, 若操作成功, 则分配结束, 否则转到下一步. (malloc.c:3576)</p>
</li>
<li><p>到了这一步说明在对应的 bin 上没有找到合适的大小, 无论是 small bin 还是 large bin, 对于 small bin, 如果没有对应大小的 small bin, 只能 idx+1. 对于 large bin,在上一步的 large bin 并不一定能找到合适的 chunk 进行切割, 因为 large bins 间隔是很大的, 假如当前的 idx 的 large bin 只有一个 chunk, 但是所需 size 大于该 chunk, 这就导致找不到合适的, 只能继续 idx+1, 最后都需要根据 bitmap 找到之后第一个非空闲的 bin. 在这两种情况下找到的 bin 中的 chunk 一定可以进行切割或者全部分配(剩余的 size &lt; MINSIZE) (malloc.c:3649)</p>
</li>
<li><p>如果仍然都没有找到合适的 chunk, 那么就需要操作 top chunk 来进行分配了. 判断 top chunk 大小是否满足所需 chunk 的大小, 如果是, 则从 top chunk 中分出一块来. 否则转到下一步. (malloc.c:3749)</p>
</li>
<li><p>到了这一步, 说明 top chunk 也不能满足分配要求, 所以, 于是就有了两个选择: 如果是主分配区, 调用 sbrk(), 增加 top chunk 大小；如果是非主分配区, 调用 mmap 来分配一个新的 sub-heap, 增加 top chunk 大小；或者使用 mmap()来直接分配. 在这里, 需要依靠 chunk 的大小来决定到底使用哪种方法. 判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值, 如果是的话, 则转下一步, 调用 mmap 分配, 否则跳到第 13 步, 增加 top chunk 的大小. (malloc.c:3800)</p>
</li>
<li><p>使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间. 然后将内存指针返回给用户.</p>
</li>
<li><p>判断是否为第一次调用 malloc, 若是主分配区, 则需要进行一次初始化工作, 分配一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap. 若已经初始化过了, 主分配区则调用 sbrk()增加 heap 空间, 分主分配区则在 top chunk 中切割出一个 chunk, 使之满足分配需求, 并将内存指针返回给用户.</p>
</li>
</ol>
<h1 id="int-free-分析"><a href="#int-free-分析" class="headerlink" title="_int_free() 分析"></a>_int_free() 分析</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c:<span class="number">3808</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ------------------------------ free ------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>下面分析具体过程(针对 32 位字长)</p>
<ol>
<li><p>free()函数同样首先需要获取分配区的锁, 来保证线程安全.</p>
</li>
<li><p>判断传入的指针是否为 0, 如果为 0, 则什么都不做, 直接 return.否则转下一步.</p>
</li>
<li><p>判断 chunk 的大小和所处的位置, 若 chunk_size &lt;= max_fast, 并且 chunk 并不位于 heap 的顶部, 也就是说并不与 Top chunk 相邻, 则转到下一步, 否则跳到第 5 步.（因为与 top chunk 相邻的 chunk(fastbin) ,会与 top chunk 进行合并, 所以这里不仅需要判断大小, 还需要判断相邻情况）</p>
</li>
<li><p>将 chunk 放到 Fastbins 中, chunk 放入到 Fastbins 中时, 并不修改该 chunk 使用状 态位 P.也不与相邻的 chunk 进行合并.只是放进去, 如此而已.这一步做完之后 释放便结束了, 程序从 free()函数中返回.</p>
</li>
<li><p>判断所需释放的 chunk 是否为 mmaped chunk, 如果是, 则调用 munmap()释放 mmaped chunk, 解除内存空间映射, 该该空间不再有效.如果开启了 mmap 分配 阈值的动态调整机制, 并且当前回收的 chunk 大小大于 mmap 分配阈值, 将 mmap 分配阈值设置为该 chunk 的大小, 将 mmap 收缩阈值设定为 mmap 分配阈值的 2 倍, 释放完成, 否则跳到下一步.</p>
</li>
<li><p>判断前一个 chunk 是否处在使用中, 如果前一个块也是空闲块, 则合并.并转下一步.</p>
</li>
<li><p>判断当前释放 chunk 的下一个块是否为 top chunk, 如果是, 则转第 9 步, 否则转 下一步.</p>
</li>
<li><p>判断下一个 chunk 是否处在使用中, 如果下一个 chunk 也是空闲的, 则合并, 并将合并后的 chunk 放到 unsorted bin 中.注意, 这里在合并的过程中, 要更新 chunk 的大小, 以反映合并后的 chunk 的大小.并转到第 10 步.</p>
</li>
<li><p>如果执行到这一步, 说明释放了一个与 top chunk 相邻的 chunk.则无论它有多大, 都将它与 top chunk 合并, 并更新 top chunk 的大小等信息.转下一步.</p>
</li>
<li><p>判断合并后的 chunk 的大小是否大于 FASTBIN_CONSOLIDATION_THRESHOLD（默认 64KB）, 如果是的话, 则会触发进行 Fastbins 的合并操作(malloc_consolidate), Fastbins 中的 chunk 将被遍历, 并与相邻的空闲 chunk 进行合并, 合并后的 chunk 会被放到 unsorted bin 中. Fastbins 将变为空, 操作完成之后转下一步.</p>
</li>
<li><p>判断 top chunk 的大小是否大于 mmap 收缩阈值（默认为 128KB）, 如果是的话, 对于主分配区, 则会试图归还 top chunk 中的一部分给操作系统.但是最先分配的 128KB 空间是不会归还的, ptmalloc 会一直管理这部分内存, 用于响应用户的分配 请求；如果为非主分配区, 会进行 sub-heap 收缩, 将 top chunk 的一部分返回给操 作系统, 如果 top chunk 为整个 sub-heap, 会把整个 sub-heap 还回给操作系统.做 完这一步之后, 释放结束, 从 free() 函数退出.可以看出, 收缩堆的条件是当前 free 的 chunk 大小加上前后能合并 chunk 的大小大于 64k, 并且要 top chunk 的大 小要达到 mmap 收缩阈值, 才有可能收缩堆.</p>
</li>
</ol>
<h1 id="特殊的分配情况举例说明"><a href="#特殊的分配情况举例说明" class="headerlink" title="特殊的分配情况举例说明"></a>特殊的分配情况举例说明</h1><p>下面几个的演示例子中没有使用到一些 heap 分析插件, 会在 ptmalloc 的利用那一步使用到 heap 分析的插件.</p>
<h2 id="下面一段表明小于-Fastbins的size-在释放后不会进行合并-如果使用-gdb-查看-chunk-信息可以看到-P-标志位为-1-这里需要注意的是看下一个-chunk-的-P-标志位-而不是当前-chunk-的标志位-这里就不进行演示了"><a href="#下面一段表明小于-Fastbins的size-在释放后不会进行合并-如果使用-gdb-查看-chunk-信息可以看到-P-标志位为-1-这里需要注意的是看下一个-chunk-的-P-标志位-而不是当前-chunk-的标志位-这里就不进行演示了" class="headerlink" title="下面一段表明小于 Fastbins的size 在释放后不会进行合并, 如果使用 gdb 查看 chunk 信息可以看到 P 标志位为 1, 这里需要注意的是看下一个 chunk 的 P 标志位, 而不是当前 chunk 的标志位, 这里就不进行演示了."></a>下面一段表明小于 Fastbins的size 在释放后不会进行合并, 如果使用 gdb 查看 chunk 信息可以看到 P 标志位为 1, 这里需要注意的是看下一个 chunk 的 P 标志位, 而不是当前 chunk 的标志位, 这里就不进行演示了.</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">  <span class="type">void</span> * ms[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">200</span>; t++)</span><br><span class="line">    ms[t] = <span class="built_in">malloc</span>(<span class="number">120</span>); <span class="comment">// default fastbin size</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">200</span>; t++)</span><br><span class="line">    <span class="built_in">free</span>(ms[t]);</span><br><span class="line">  <span class="type">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,m1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line">λ : gcc -g -o test2 test2.c &amp;&amp; ./test2</span><br><span class="line"><span class="number">0x17c2010</span></span><br><span class="line"><span class="number">0x17c8450</span></span><br></pre></td></tr></table></figure>
<h2 id="下面例子表明-当-fast-bin-的相邻为空闲-chunk-以及相邻-top-chunk-的情况-都不会进行合并-但是对于-top-chunk-的情况有些特殊"><a href="#下面例子表明-当-fast-bin-的相邻为空闲-chunk-以及相邻-top-chunk-的情况-都不会进行合并-但是对于-top-chunk-的情况有些特殊" class="headerlink" title="下面例子表明, 当 fast bin 的相邻为空闲 chunk, 以及相邻 top chunk 的情况, 都不会进行合并, 但是对于 top chunk 的情况有些特殊."></a>下面例子表明, 当 fast bin 的相邻为空闲 chunk, 以及相邻 top chunk 的情况, 都不会进行合并, 但是对于 top chunk 的情况有些特殊.</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  TRIM_FASTBINS controls whether free() of a very small chunk can</span></span><br><span class="line"><span class="comment">  immediately lead to trimming. Setting to true (1) can reduce memory</span></span><br><span class="line"><span class="comment">  footprint, but will almost always slow down programs that use a lot</span></span><br><span class="line"><span class="comment">  of small chunks.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Define this only if you are willing to give up some speed to more</span></span><br><span class="line"><span class="comment">  aggressively reduce system-level memory footprint when releasing</span></span><br><span class="line"><span class="comment">  memory in programs that use many small chunks.  You can get</span></span><br><span class="line"><span class="comment">  essentially the same effect by setting MXFAST to 0, but this can</span></span><br><span class="line"><span class="comment">  lead to even greater slowdowns in programs using many small chunks.</span></span><br><span class="line"><span class="comment">  TRIM_FASTBINS is an in-between compile-time option, that disables</span></span><br><span class="line"><span class="comment">  only those chunks bordering topmost memory from being placed in</span></span><br><span class="line"><span class="comment">  fastbins.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>当设置 TRIM_FASTBINS=1 fast bin 会与相邻的 top chunk 进行合并</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">λ : cat test5.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line">    <span class="type">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">void</span> *m3 = <span class="built_in">malloc</span>(<span class="number">80</span>);</span><br><span class="line">    <span class="built_in">free</span>(m1);</span><br><span class="line">    <span class="built_in">free</span>(m2);</span><br><span class="line">    <span class="type">void</span> *m4 = <span class="built_in">malloc</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(m3);</span><br><span class="line">    <span class="type">void</span> *m5 = <span class="built_in">malloc</span>(<span class="number">80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1, %p\n&quot;</span>,m1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m2, %p\n&quot;</span>,m2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m3, %p\n&quot;</span>,m3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m4, %p\n&quot;</span>,m4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m5, %p\n&quot;</span>,m5);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line">λ : gcc -g -o test5 test5.c &amp;&amp; ./test5</span><br><span class="line">m1, <span class="number">0x8b1010</span></span><br><span class="line">m2, <span class="number">0x8b1210</span></span><br><span class="line">m3, <span class="number">0x8b1260</span></span><br><span class="line">m4, <span class="number">0x8b1210</span></span><br><span class="line">m5, <span class="number">0x8b1260</span></span><br></pre></td></tr></table></figure>
<h2 id="下面的例子表明-small-bin-在释放后会相邻合并的例子"><a href="#下面的例子表明-small-bin-在释放后会相邻合并的例子" class="headerlink" title="下面的例子表明 small bin 在释放后会相邻合并的例子."></a>下面的例子表明 small bin 在释放后会相邻合并的例子.</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">  <span class="type">void</span> * ms[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">200</span>; t++)</span><br><span class="line">    ms[t] = <span class="built_in">malloc</span>(<span class="number">121</span>); <span class="comment">// small bin size</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; <span class="number">200</span>; t++)</span><br><span class="line">    <span class="built_in">free</span>(ms[t]);</span><br><span class="line">  <span class="type">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,m1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line">λ : gcc -g -o test2 test2.c &amp;&amp; ./test2</span><br><span class="line"><span class="number">0xeab010</span></span><br><span class="line"><span class="number">0xeab030</span></span><br></pre></td></tr></table></figure>
<h2 id="举例说明-malloc-consolidate-的作用-以及如何触发-malloc-consolidate"><a href="#举例说明-malloc-consolidate-的作用-以及如何触发-malloc-consolidate" class="headerlink" title="举例说明 malloc_consolidate 的作用, 以及如何触发 malloc_consolidate."></a>举例说明 malloc_consolidate 的作用, 以及如何触发 malloc_consolidate.</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">void</span> *m0 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">        <span class="type">void</span> *m1 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">        <span class="type">void</span> *m2 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">        <span class="type">void</span> *m3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">        <span class="type">void</span> *m4 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">        <span class="type">void</span> *m5 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">121</span>);</span><br><span class="line">        <span class="built_in">free</span>(m0);</span><br><span class="line">        <span class="built_in">free</span>(m1);</span><br><span class="line">        <span class="built_in">free</span>(m2);</span><br><span class="line">        <span class="built_in">free</span>(m3);</span><br><span class="line">        <span class="built_in">free</span>(m4);</span><br><span class="line">        <span class="built_in">free</span>(m5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x350</span>);</span><br><span class="line">        <span class="type">void</span> *m6 = <span class="built_in">malloc</span>(<span class="number">0x360</span>);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">1210</span>); <span class="comment">// 触发 Fastbins 合并</span></span><br><span class="line">        <span class="type">void</span> *m7 = <span class="built_in">malloc</span>(<span class="number">0x360</span>);</span><br><span class="line">        <span class="type">void</span> *m8 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m0,%p\n&quot;</span>, m0);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m1,%p\n&quot;</span>, m1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m2,%p\n&quot;</span>, m2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m3,%p\n&quot;</span>, m3);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m4,%p\n&quot;</span>, m4);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m5,%p\n&quot;</span>, m5);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m6,%p\n&quot;</span>, m6);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m7,%p\n&quot;</span>, m7);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;m8,%p\n&quot;</span>, m8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line">λ : gcc -g -o test3 test3.c &amp;&amp; ./test3</span><br><span class="line">m0,<span class="number">0x1bf7010</span></span><br><span class="line">m1,<span class="number">0x1bf7030</span></span><br><span class="line">m2,<span class="number">0x1bf7050</span></span><br><span class="line">m3,<span class="number">0x1bf7260</span></span><br><span class="line">m4,<span class="number">0x1bf7370</span></span><br><span class="line">m5,<span class="number">0x1bf7390</span></span><br><span class="line">m6,<span class="number">0x1bf77a0</span></span><br><span class="line">m7,<span class="number">0x1bf7010</span></span><br><span class="line">m8,<span class="number">0x1bf7380</span></span><br></pre></td></tr></table></figure>
<h2 id="下面举例说明-当-small-bins-和-large-bins-没有找到对应合适-size-的-Bin-需要切割的情况"><a href="#下面举例说明-当-small-bins-和-large-bins-没有找到对应合适-size-的-Bin-需要切割的情况" class="headerlink" title="下面举例说明, 当 small bins 和 large bins 没有找到对应合适 size 的 Bin, 需要切割的情况."></a>下面举例说明, 当 small bins 和 large bins 没有找到对应合适 size 的 Bin, 需要切割的情况.</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * m1 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">121</span>);</span><br><span class="line">    <span class="type">void</span> * m2 = <span class="built_in">malloc</span>(<span class="number">0x401</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">121</span>);</span><br><span class="line">    <span class="built_in">free</span>(m2);</span><br><span class="line">    <span class="type">void</span> * m3 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">free</span>(m1);</span><br><span class="line">    <span class="type">void</span> * m4 = <span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1, %p\n&quot;</span>, m1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m2, %p\n&quot;</span>, m2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m3, %p\n&quot;</span>, m3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m4, %p\n&quot;</span>, m4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(size_t) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line">λ : gcc -g -o test1 test1.c &amp;&amp; ./test1</span><br><span class="line">m1, <span class="number">0x1a66010</span></span><br><span class="line">m2, <span class="number">0x1a662b0</span></span><br><span class="line">m3, <span class="number">0x1a662b0</span> <span class="comment">//切割 small bins</span></span><br><span class="line">m4, <span class="number">0x1a66010</span> <span class="comment">//切割 large bins</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">size_t</span>) = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h1 id="exploit-在-ptmalloc-中"><a href="#exploit-在-ptmalloc-中" class="headerlink" title="exploit 在 ptmalloc 中"></a>exploit 在 ptmalloc 中</h1><p>首先明确大部分的关注点, 是在 leak infomation 和 aa4bmo.</p>
<p>对于 leak infomation, 需要所 dump 的地址内存放关键信息, 比如: 释放后的 chunk 的 fd 和 bk.</p>
<p>对于 aa4bmo, 这一块在另一篇《PWN之堆触发》有完善的介绍和总结.</p>
<p>下面的一些分析实例会用到 heap 的分析插件, 并且会提到一些具体的实践以对应之前的理论.</p>
<h1 id="Leak-Information-泄露关键信息"><a href="#Leak-Information-泄露关键信息" class="headerlink" title="Leak Information (泄露关键信息)"></a>Leak Information (泄露关键信息)</h1><p>Q: 什么是关键信息?</p>
<p>A: libc 地址, heap 地址</p>
<p>通过 ptmalloc 获得的内存 chunk 在释放后会变成上面提到的几种缓存类型, 这里主要提一下 Fastbins, Bins 能够泄漏什么关键信息.</p>
<p>分配区 <code>main_arena</code> 是已经初始化静态全局变量存放在 <code>libc.so.6</code> 的 <code>.data</code> 位置, 可以通过 <code>main_arena</code> 泄露 libc 的基址.</p>
<h2 id="下面是一个关于-Fastbins-的例子-Fastbins-是单向链表-通过-fd-指针进行遍历-每次插入链表头位置-可以通过已经释放的-Fastbin-chunk-的-fd-指针-dump-到-heap-地址"><a href="#下面是一个关于-Fastbins-的例子-Fastbins-是单向链表-通过-fd-指针进行遍历-每次插入链表头位置-可以通过已经释放的-Fastbin-chunk-的-fd-指针-dump-到-heap-地址" class="headerlink" title="下面是一个关于 Fastbins 的例子, Fastbins 是单向链表, 通过 fd 指针进行遍历, 每次插入链表头位置, 可以通过已经释放的 Fastbin chunk 的 fd 指针 dump 到 heap 地址."></a>下面是一个关于 Fastbins 的例子, Fastbins 是单向链表, 通过 fd 指针进行遍历, 每次插入链表头位置, 可以通过已经释放的 Fastbin chunk 的 fd 指针 dump 到 heap 地址.</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>                                                                                                                                                                                                  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>                                                                                                                                                                                                 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span>                                                                                                                                                                                                 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>                                                                                                                                                                                                        </span><br><span class="line">&#123;                                                                                                                                                                                                                  </span><br><span class="line">    <span class="type">void</span> * m1 = <span class="built_in">malloc</span>(<span class="number">0x80</span><span class="number">-8</span>);                                                                                                                                                                                    </span><br><span class="line">    <span class="type">void</span> * m2 = <span class="built_in">malloc</span>(<span class="number">0x80</span><span class="number">-8</span>);                                                                                                                                                                                    </span><br><span class="line">    <span class="built_in">memset</span>(m1, <span class="number">65</span>, <span class="number">0x80</span><span class="number">-8</span>);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">memset</span>(m2, <span class="number">65</span>, <span class="number">0x80</span><span class="number">-8</span>);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);                                                                                                                                                                                                     </span><br><span class="line">    <span class="built_in">free</span>(m1);                                                                                                                                                                                                      </span><br><span class="line">    <span class="built_in">free</span>(m2);                                                                                                                                                                                                      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1: %p\n&quot;</span>, m1);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m2: %p\n&quot;</span>, m2);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(size_t): %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));                                                                                                                                                               </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 主分配区</span><br><span class="line">(gdb) P &amp;main_arena </span><br><span class="line">$<span class="number">3</span> = (<span class="keyword">struct</span> malloc_state *) <span class="number">0x7ffff7dd1b20</span> &lt;main_arena&gt;</span><br><span class="line">(gdb) p main_arena </span><br><span class="line">$<span class="number">2</span> = &#123;mutex = <span class="number">0</span>, flags = <span class="number">0</span>, fastbinsY = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x602080</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;, top = <span class="number">0x602120</span>, last_remainder = <span class="number">0x0</span>, bins = &#123;...more... &#125;, binmap = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, next = <span class="number">0x7ffff7dd1b20</span> &lt;main_arena&gt;, next_free = <span class="number">0x0</span>, attached_threads = <span class="number">1</span>, system_mem = <span class="number">135168</span>, max_system_mem = <span class="number">135168</span>&#125;</span><br><span class="line"># 同上</span><br><span class="line">(gdb) heap</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">Arena(s) found:</span><br><span class="line">         arena @ <span class="number">0x7ffff7dd1b20</span></span><br><span class="line"># Fastbins 在释放后, P 标志位不会被清空</span><br><span class="line">(gdb) heap -l</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">          ADDR             SIZE         STATUS</span><br><span class="line">sbrk_base <span class="number">0x602000</span></span><br><span class="line">chunk     <span class="number">0x602000</span>         <span class="number">0x80</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602080</span>         <span class="number">0x80</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602100</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602120</span>         <span class="number">0x20ee0</span>      (top)</span><br><span class="line">sbrk_end  <span class="number">0x602001</span></span><br><span class="line"># 查看 bins</span><br><span class="line">(gdb) heap -b</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line">fast bin <span class="number">6</span> @ <span class="number">0x602080</span></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602080</span> - size <span class="number">0x80</span> </span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602000</span> - size <span class="number">0x80</span> </span><br><span class="line"># 通过观察源码和这里 Fastbins 的顺序应该可以发现 Fastbins 是头插入</span><br><span class="line">(gdb) heap -f</span><br><span class="line">====================================Fastbins====================================</span><br><span class="line"></span><br><span class="line">[ fb <span class="number">0</span> ] <span class="number">0x7ffff7dd1b28</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">1</span> ] <span class="number">0x7ffff7dd1b30</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">2</span> ] <span class="number">0x7ffff7dd1b38</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">3</span> ] <span class="number">0x7ffff7dd1b40</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">4</span> ] <span class="number">0x7ffff7dd1b48</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">5</span> ] <span class="number">0x7ffff7dd1b50</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">6</span> ] <span class="number">0x7ffff7dd1b58</span>  -&gt; [ <span class="number">0x602080</span> ] (<span class="number">128</span>)</span><br><span class="line">                              [ <span class="number">0x602000</span> ] (<span class="number">128</span>)</span><br><span class="line">[ fb <span class="number">7</span> ] <span class="number">0x7ffff7dd1b60</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">8</span> ] <span class="number">0x7ffff7dd1b68</span>  -&gt; [ <span class="number">0x0</span> ] </span><br><span class="line">[ fb <span class="number">9</span> ] <span class="number">0x7ffff7dd1b70</span>  -&gt; [ <span class="number">0x0</span> ]</span><br><span class="line"># Fastbins 是根据 fd 指针进行遍历</span><br><span class="line">(gdb) p *(mchunkptr)<span class="number">0x602080</span></span><br><span class="line">$<span class="number">4</span> = &#123;prev_size = <span class="number">4702111234474983745</span>, size = <span class="number">129</span>, fd = <span class="number">0x602000</span>, bk = <span class="number">0x4141414141414141</span>, fd_nextsize = <span class="number">0x4141414141414141</span>, bk_nextsize = <span class="number">0x4141414141414141</span>&#125;</span><br><span class="line"># 这里 dump 之前 chunk 的内容可以拿到 heap 的地址</span><br><span class="line">(gdb) x/wx <span class="number">0x602090</span></span><br><span class="line"><span class="number">0x602090</span>:       <span class="number">0x00602000</span></span><br></pre></td></tr></table></figure>
<p>下面是一个关于 Bins 的例子, Bins 是双向环链表, 头插入, 可以通过已经释放的 Bin chunk 泄漏 libc 和 heap 地址.</p>
<p>这里需要理解一下由<code>malloc(0xB0-8)</code>; 的作用, 以及 Unstored bin 转为 small bins 的过程. 这里如果不清楚可以对应 libc 源码查看上面提到的 <code>_int_malloc()</code>的过程.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>                                                                                                                                                                                                  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>                                                                                                                                                                                                 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span>                                                                                                                                                                                                 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>                                                                                                                                                                                                        </span><br><span class="line">&#123;                                                                                                                                                                                                                  </span><br><span class="line">    <span class="type">void</span> * m1 = <span class="built_in">malloc</span>(<span class="number">0x90</span><span class="number">-8</span>);                                                                                                                                                                                    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);                                                                                                                                                                                                     </span><br><span class="line">    <span class="type">void</span> * m2 = <span class="built_in">malloc</span>(<span class="number">0x90</span><span class="number">-8</span>);                                                                                                                                                                                    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);                                                                                                                                                                                                     </span><br><span class="line">    <span class="type">void</span> * m3 = <span class="built_in">malloc</span>(<span class="number">0xA0</span><span class="number">-8</span>);                                                                                                                                                                                    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);                                                                                                                                                                                                     </span><br><span class="line">    <span class="built_in">memset</span>(m1, <span class="number">65</span>, <span class="number">0x90</span><span class="number">-8</span>);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">memset</span>(m2, <span class="number">65</span>, <span class="number">0x90</span><span class="number">-8</span>);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">memset</span>(m3, <span class="number">65</span>, <span class="number">0xA0</span><span class="number">-8</span>);                                                                                                                                                                                        </span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(m1);                                                                                                                                                                                                      </span><br><span class="line">    <span class="built_in">free</span>(m2);                                                                                                                                                                                                      </span><br><span class="line">    <span class="built_in">free</span>(m3);                                                                                                                                                                                                      </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xB0</span><span class="number">-8</span>);                                                                                                                                                                                                </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m1: %p\n&quot;</span>, m1);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m2: %p\n&quot;</span>, m2);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m3: %p\n&quot;</span>, m3);                                                                                                                                                                                        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(size_t): %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));                                                                                                                                                               </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">λ : gdb -q test2</span><br><span class="line">Reading symbols from test2...done.</span><br><span class="line">(gdb) b <span class="number">19</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x4006ac</span>: file test2.c, line <span class="number">19.</span></span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/spiderzz/Desktop/pwn/<span class="built_in">malloc</span>/test2 </span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, main () at test2.c:<span class="number">19</span></span><br><span class="line"><span class="number">19</span>          <span class="built_in">malloc</span>(<span class="number">0xB0</span><span class="number">-8</span>);</span><br><span class="line">(gdb) heap</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">Arena(s) found:</span><br><span class="line">         arena @ <span class="number">0x7ffff7dd1b20</span></span><br><span class="line"></span><br><span class="line"># Unsorted bin 是双向环链表, 这里需要观察, 双向环链表的两个端点 chunk 的 FD 和 BK 的地址不同之处, 因为一个在 libc 的空间, 一个在 heap 的空间.</span><br><span class="line">(gdb) heap -l</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">          ADDR             SIZE         STATUS</span><br><span class="line">sbrk_base <span class="number">0x602000</span></span><br><span class="line">chunk     <span class="number">0x602000</span>         <span class="number">0x90</span>         (F) FD <span class="number">0x7ffff7dd1b78</span> BK <span class="number">0x6020b0</span> </span><br><span class="line">chunk     <span class="number">0x602090</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x6020b0</span>         <span class="number">0x90</span>         (F) FD <span class="number">0x602000</span> BK <span class="number">0x602160</span> </span><br><span class="line">chunk     <span class="number">0x602140</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602160</span>         <span class="number">0xa0</span>         (F) FD <span class="number">0x6020b0</span> BK <span class="number">0x7ffff7dd1b78</span> </span><br><span class="line">chunk     <span class="number">0x602200</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602220</span>         <span class="number">0x20de0</span>      (top)</span><br><span class="line">sbrk_end  <span class="number">0x602001</span></span><br><span class="line">(gdb) heap -b</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">unsorted bin @ <span class="number">0x7ffff7dd1b88</span></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602160</span> - size <span class="number">0xa0</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x6020b0</span> - size <span class="number">0x90</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602000</span> - size <span class="number">0x90</span></span><br><span class="line"># 这个也就是返回的 fake chunk 的地址, 这地址其实就是 bin_at 的返回值</span><br><span class="line">(gdb) p *(mfastbinptr)<span class="number">0x7ffff7dd1B78</span></span><br><span class="line">$<span class="number">1</span> = &#123;prev_size = <span class="number">6300192</span>, size = <span class="number">0</span>, fd = <span class="number">0x602160</span>, bk = <span class="number">0x602000</span>, fd_nextsize = <span class="number">0x7ffff7dd1b88</span> &lt;main_arena+<span class="number">104</span>&gt;, bk_nextsize = <span class="number">0x7ffff7dd1b88</span> &lt;main_arena+<span class="number">104</span>&gt;&#125;         </span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">20</span>          <span class="built_in">printf</span>(<span class="string">&quot;m1: %p\n&quot;</span>, m1);</span><br><span class="line"># 这里需要理解 Bins 的 FD 和 BK.</span><br><span class="line">(gdb) heap -l</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">          ADDR             SIZE         STATUS</span><br><span class="line">sbrk_base <span class="number">0x602000</span></span><br><span class="line">chunk     <span class="number">0x602000</span>         <span class="number">0x90</span>         (F) FD <span class="number">0x7ffff7dd1bf8</span> BK <span class="number">0x6020b0</span> </span><br><span class="line">chunk     <span class="number">0x602090</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x6020b0</span>         <span class="number">0x90</span>         (F) FD <span class="number">0x602000</span> BK <span class="number">0x7ffff7dd1bf8</span> </span><br><span class="line">chunk     <span class="number">0x602140</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602160</span>         <span class="number">0xa0</span>         (F) FD <span class="number">0x7ffff7dd1c08</span> BK <span class="number">0x7ffff7dd1c08</span> (LC)</span><br><span class="line">chunk     <span class="number">0x602200</span>         <span class="number">0x20</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x602220</span>         <span class="number">0xb0</span>         (inuse)</span><br><span class="line">chunk     <span class="number">0x6022d0</span>         <span class="number">0x20d30</span>      (top)</span><br><span class="line">sbrk_end  <span class="number">0x602001</span></span><br><span class="line"># 这里需要理解 Unsorted bin 是如何变为 small bin</span><br><span class="line">(gdb) heap -b</span><br><span class="line">===================================Heap Dump===================================</span><br><span class="line"></span><br><span class="line">small bin <span class="number">9</span> @ <span class="number">0x7ffff7dd1c08</span></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x6020b0</span> - size <span class="number">0x90</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602000</span> - size <span class="number">0x90</span></span><br><span class="line">small bin <span class="number">10</span> @ <span class="number">0x7ffff7dd1c18</span></span><br><span class="line">        <span class="built_in">free</span> chunk @ <span class="number">0x602160</span> - size <span class="number">0xa0</span></span><br><span class="line"># bin_at 的返回, 需要联合上面的两条命令返回的结果一起理解</span><br><span class="line">(gdb) p *(mfastbinptr)<span class="number">0x7ffff7dd1BF8</span> </span><br><span class="line">$<span class="number">3</span> = &#123;prev_size = <span class="number">140737351850984</span>, size = <span class="number">140737351850984</span>, fd = <span class="number">0x6020b0</span>, bk = <span class="number">0x602000</span>, fd_nextsize = <span class="number">0x602160</span>, bk_nextsize = <span class="number">0x602160</span>&#125;</span><br><span class="line"># bin_at 的返回, 需要联合上面的两条命令返回的结果一起理解</span><br><span class="line">(gdb) p *(mfastbinptr)<span class="number">0x7ffff7dd1C08</span></span><br><span class="line">$<span class="number">2</span> = &#123;prev_size = <span class="number">6299824</span>, size = <span class="number">6299648</span>, fd = <span class="number">0x602160</span>, bk = <span class="number">0x602160</span>, fd_nextsize = <span class="number">0x7ffff7dd1c18</span> &lt;main_arena+<span class="number">248</span>&gt;, bk_nextsize = <span class="number">0x7ffff7dd1c18</span> &lt;main_arena+<span class="number">248</span>&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到如何使用 Bins 泄露 libc 和 heap 的地址, 这一部分其实在 Phrack 的<code>&lt;Advanced Doug Lea&#39;s malloc exploits&gt;</code> 的<code>4.5 Abusing the leaked information</code>一小部分有提到. 可以通过 “find a lonely chunk in the heap” 去泄露, 相当于上面例子中的 m3, 位于 small bin 10, 释放后会修改 FD, BK 为该 Bin 的地址, 进而泄露 libc 的地址. 还有一种方法就是 “find the first or last chunk of a bin”, 相当于上面例子中的 m1, m2, 释放后, 会造成 FD 和 BK 一个在 <code>ptr_2_libc&#39;s_memory</code>, 一个在 <code>ptr_2_process&#39;_heap</code>.</p>
<p>下面说明如何使用一个<code>lonely chunk</code>, 拿到关键函数的地址, 在 <code>&lt;Advanced Doug Lea&#39;s malloc exploits&gt;</code>中使用的是 <code>__morecore</code>这个函数指针, 它指向 <code>__default_morecore</code>, 也就是系统用于增加内存的函数, 默认为 <code>brk()</code>, 这里简单提一下.</p>
<p>这里直接使用上面的 m3 作为例子举例,<code>m3</code>在释放后变为 <code>lonely chunk</code>, 位于 <code>small bin 10</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">0.</span>这里已知该 chunk 所在 bin 的地址 (t0 = <span class="number">0x7ffff7dd1c08</span>+<span class="number">0x10</span>)(对于为什么需要加 <span class="number">0x10</span>, 是因为 fake chunk, 具体参考上面)</span><br><span class="line">#<span class="number">1.</span>根据 chunk 的 size, 取得对应 bin index, 这里其实也就是 <span class="number">10</span>, 可以查看 bin_index 宏, 查看对应具体实现</span><br><span class="line">#<span class="number">2.</span>根据 bin index, 获取到该 bin 与 main_arena 的地址差, 从而获得 main_arena 的地址.</span><br><span class="line">t0 = <span class="number">0x7ffff7dd1c08</span> + <span class="number">0x10</span></span><br><span class="line">t1 = (<span class="type">long</span>)&amp;main_arena.bins - (<span class="type">long</span>)&amp;main_arena</span><br><span class="line">t2 = (<span class="type">long</span>)&amp;__morecore - (<span class="type">long</span>)&amp;(main_arena)</span><br><span class="line">t3 = (<span class="number">10</span><span class="number">-1</span>)*<span class="number">2</span>*<span class="number">8</span> <span class="comment">//至于为什么这么算, 请参考源码 bin_at 宏</span></span><br><span class="line">&amp;main_arena = t0 - (t3+t1) = <span class="number">0x7ffff7dd1b20</span></span><br><span class="line">#<span class="number">3.</span>根据 _morecore 与 main_arena 的地址差, 得到 _morecore 的地址</span><br><span class="line">&amp;__morecore = &amp;main_arena + t2</span><br></pre></td></tr></table></figure></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.xiaojingye.top">Small Waste</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.xiaojingye.top/2022/07/28/PWN-%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">https://www.xiaojingye.top/2022/07/28/PWN-%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.xiaojingye.top" target="_blank">Remarkable</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E5%BA%95%E5%B1%82/">底层</a></div><div class="post_share"><div class="social-share" data-image="https://www.apple.com.cn/newsroom/images/values/health/Apple-Health-study-July-2022-hero.jpg.landing-regular_2x.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/03/checkm8-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"><img class="prev-cover" src="https://www.apple.com.cn/newsroom/images/product/app-store/Apple_around-the-clock-global-effort-to-keep-App-Store-users-safe_spot-illo-1_050621_inline.jpg.large_2x.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">checkm8 攻击原理浅析</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/24/Nginx-%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/"><img class="next-cover" src="https://www.apple.com.cn/newsroom/images/product/app-store/Apple_Tech-Talks-2021_10202021_big.jpg.large_2x.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Nginx 加权轮询算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/22/Linked-list-foundation-C-language-description/" title="Linked list foundation - C language description"><img class="cover" src="https://s2.loli.net/2022/07/22/crACJQ1HYVb5tm8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-22</div><div class="title">Linked list foundation - C language description</div></div></a></div><div><a href="/2022/07/24/Nginx-%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/" title="Nginx 加权轮询算法"><img class="cover" src="https://www.apple.com.cn/newsroom/images/product/app-store/Apple_Tech-Talks-2021_10202021_big.jpg.large_2x.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-24</div><div class="title">Nginx 加权轮询算法</div></div></a></div><div><a href="/2022/08/03/checkm8-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/" title="checkm8 攻击原理浅析"><img class="cover" src="https://www.apple.com.cn/newsroom/images/product/app-store/Apple_around-the-clock-global-effort-to-keep-App-Store-users-safe_spot-illo-1_050621_inline.jpg.large_2x.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-03</div><div class="title">checkm8 攻击原理浅析</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/07/20/N1DLlaqMkj5fK7U.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Small Waste</div><div class="author-info__description">Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/akrnp98K/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/akrnp98K" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1735409005@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1735409005&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">认真上班是不可能的，这辈子都是不可能的。 只能靠摸摸鱼来混点底薪……</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%A0%86%E7%9A%84%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7"><span class="toc-number">1.</span> <span class="toc-text">分析堆的相关工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-ptmalloc%E8%AE%BE%E8%AE%A1-%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">2.</span> <span class="toc-text">堆内存分配(ptmalloc设计)的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-ptmalloc"><span class="toc-number">2.1.</span> <span class="toc-text">为什么需要 ptmalloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bins"><span class="toc-number">2.2.</span> <span class="toc-text">Bins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Top"><span class="toc-number">2.3.</span> <span class="toc-text">Top</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastbins"><span class="toc-number">2.4.</span> <span class="toc-text">Fastbins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsorted-bin"><span class="toc-number">2.5.</span> <span class="toc-text">Unsorted bin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#last-remainder"><span class="toc-number">2.6.</span> <span class="toc-text">last_remainder</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chunk-%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">chunk 结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E6%A0%87%E7%A4%BA"><span class="toc-number">4.</span> <span class="toc-text">边界标示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">空间复用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E5%AE%B9%E5%99%A8-%E7%BC%93%E5%AD%98"><span class="toc-number">6.</span> <span class="toc-text">空闲容器(缓存)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#small-bins-large-bins"><span class="toc-number">7.</span> <span class="toc-text">small bins, large bins</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fastbins-1"><span class="toc-number">8.</span> <span class="toc-text">Fastbins</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unsorted-bin"><span class="toc-number">9.</span> <span class="toc-text">unsorted bin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#top-chunk"><span class="toc-number">10.</span> <span class="toc-text">top chunk</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mmaped-chunk"><span class="toc-number">11.</span> <span class="toc-text">mmaped chunk</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Last-remainder"><span class="toc-number">12.</span> <span class="toc-text">Last remainder</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#malloc-state"><span class="toc-number">13.</span> <span class="toc-text">malloc_state</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#int-malloc-%E5%88%86%E6%9E%90"><span class="toc-number">14.</span> <span class="toc-text">_int_malloc() 分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#int-free-%E5%88%86%E6%9E%90"><span class="toc-number">15.</span> <span class="toc-text">_int_free() 分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%88%86%E9%85%8D%E6%83%85%E5%86%B5%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">16.</span> <span class="toc-text">特殊的分配情况举例说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E4%B8%80%E6%AE%B5%E8%A1%A8%E6%98%8E%E5%B0%8F%E4%BA%8E-Fastbins%E7%9A%84size-%E5%9C%A8%E9%87%8A%E6%94%BE%E5%90%8E%E4%B8%8D%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6-%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8-gdb-%E6%9F%A5%E7%9C%8B-chunk-%E4%BF%A1%E6%81%AF%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0-P-%E6%A0%87%E5%BF%97%E4%BD%8D%E4%B8%BA-1-%E8%BF%99%E9%87%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%E7%9C%8B%E4%B8%8B%E4%B8%80%E4%B8%AA-chunk-%E7%9A%84-P-%E6%A0%87%E5%BF%97%E4%BD%8D-%E8%80%8C%E4%B8%8D%E6%98%AF%E5%BD%93%E5%89%8D-chunk-%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D-%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E8%BF%9B%E8%A1%8C%E6%BC%94%E7%A4%BA%E4%BA%86"><span class="toc-number">16.1.</span> <span class="toc-text">下面一段表明小于 Fastbins的size 在释放后不会进行合并, 如果使用 gdb 查看 chunk 信息可以看到 P 标志位为 1, 这里需要注意的是看下一个 chunk 的 P 标志位, 而不是当前 chunk 的标志位, 这里就不进行演示了.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E4%BE%8B%E5%AD%90%E8%A1%A8%E6%98%8E-%E5%BD%93-fast-bin-%E7%9A%84%E7%9B%B8%E9%82%BB%E4%B8%BA%E7%A9%BA%E9%97%B2-chunk-%E4%BB%A5%E5%8F%8A%E7%9B%B8%E9%82%BB-top-chunk-%E7%9A%84%E6%83%85%E5%86%B5-%E9%83%BD%E4%B8%8D%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6-%E4%BD%86%E6%98%AF%E5%AF%B9%E4%BA%8E-top-chunk-%E7%9A%84%E6%83%85%E5%86%B5%E6%9C%89%E4%BA%9B%E7%89%B9%E6%AE%8A"><span class="toc-number">16.2.</span> <span class="toc-text">下面例子表明, 当 fast bin 的相邻为空闲 chunk, 以及相邻 top chunk 的情况, 都不会进行合并, 但是对于 top chunk 的情况有些特殊.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BE%8B%E5%AD%90%E8%A1%A8%E6%98%8E-small-bin-%E5%9C%A8%E9%87%8A%E6%94%BE%E5%90%8E%E4%BC%9A%E7%9B%B8%E9%82%BB%E5%90%88%E5%B9%B6%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">16.3.</span> <span class="toc-text">下面的例子表明 small bin 在释放后会相邻合并的例子.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E-malloc-consolidate-%E7%9A%84%E4%BD%9C%E7%94%A8-%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91-malloc-consolidate"><span class="toc-number">16.4.</span> <span class="toc-text">举例说明 malloc_consolidate 的作用, 以及如何触发 malloc_consolidate.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E-%E5%BD%93-small-bins-%E5%92%8C-large-bins-%E6%B2%A1%E6%9C%89%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E5%90%88%E9%80%82-size-%E7%9A%84-Bin-%E9%9C%80%E8%A6%81%E5%88%87%E5%89%B2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">16.5.</span> <span class="toc-text">下面举例说明, 当 small bins 和 large bins 没有找到对应合适 size 的 Bin, 需要切割的情况.</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#exploit-%E5%9C%A8-ptmalloc-%E4%B8%AD"><span class="toc-number">17.</span> <span class="toc-text">exploit 在 ptmalloc 中</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Leak-Information-%E6%B3%84%E9%9C%B2%E5%85%B3%E9%94%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">18.</span> <span class="toc-text">Leak Information (泄露关键信息)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E-Fastbins-%E7%9A%84%E4%BE%8B%E5%AD%90-Fastbins-%E6%98%AF%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E9%80%9A%E8%BF%87-fd-%E6%8C%87%E9%92%88%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86-%E6%AF%8F%E6%AC%A1%E6%8F%92%E5%85%A5%E9%93%BE%E8%A1%A8%E5%A4%B4%E4%BD%8D%E7%BD%AE-%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%B7%B2%E7%BB%8F%E9%87%8A%E6%94%BE%E7%9A%84-Fastbin-chunk-%E7%9A%84-fd-%E6%8C%87%E9%92%88-dump-%E5%88%B0-heap-%E5%9C%B0%E5%9D%80"><span class="toc-number">18.1.</span> <span class="toc-text">下面是一个关于 Fastbins 的例子, Fastbins 是单向链表, 通过 fd 指针进行遍历, 每次插入链表头位置, 可以通过已经释放的 Fastbin chunk 的 fd 指针 dump 到 heap 地址.</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/02/Good-night-Mr-Lawrence/" title="Good night Mr. Lawrence"><img src="https://bu.dusays.com/2023/04/02/642994002b206.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Good night Mr. Lawrence"/></a><div class="content"><a class="title" href="/2023/04/02/Good-night-Mr-Lawrence/" title="Good night Mr. Lawrence">Good night Mr. Lawrence</a><time datetime="2023-04-02T14:45:08.000Z" title="发表于 2023-04-02 22:45:08">2023-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/23/Java-Thread%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" title="Java Thread类使用方法和注意事项"><img src="https://www.apple.com.cn/newsroom/images/live-action/wwdc-2021/Apple_Developer-Tools-hero-animation-clip_060721.jpg.landing-regular_2x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java Thread类使用方法和注意事项"/></a><div class="content"><a class="title" href="/2023/02/23/Java-Thread%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" title="Java Thread类使用方法和注意事项">Java Thread类使用方法和注意事项</a><time datetime="2023-02-22T16:08:30.000Z" title="发表于 2023-02-23 00:08:30">2023-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/25/Java%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/" title="Java安全编码-用户输入"><img src="https://www.apple.com.cn/newsroom/images/live-action/wwdc-2021/Apple_Developer-Tools-hero-animation-clip_060721.jpg.landing-regular_2x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java安全编码-用户输入"/></a><div class="content"><a class="title" href="/2023/01/25/Java%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5/" title="Java安全编码-用户输入">Java安全编码-用户输入</a><time datetime="2023-01-24T16:38:06.000Z" title="发表于 2023-01-25 00:38:06">2023-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/23/Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%B7%B1%E5%85%A5%E5%88%A9%E7%94%A8%E5%8F%8A%E5%88%86%E6%9E%90/" title="Nginx解析漏洞深入利用及分析"><img src="https://www.apple.com.cn/newsroom/images/passions/education/Apple-STEAM-Day-hero_Full-Bleed-Image.jpg.large_2x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx解析漏洞深入利用及分析"/></a><div class="content"><a class="title" href="/2023/01/23/Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%B7%B1%E5%85%A5%E5%88%A9%E7%94%A8%E5%8F%8A%E5%88%86%E6%9E%90/" title="Nginx解析漏洞深入利用及分析">Nginx解析漏洞深入利用及分析</a><time datetime="2023-01-23T15:28:26.000Z" title="发表于 2023-01-23 23:28:26">2023-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/04/Chrome-V8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2022-1310/" title="Chrome V8命令执行漏洞分析（CVE-2022-1310）"><img src="https://www.apple.com.cn/newsroom/images/values/corporate/standard/Apple_google-partner-on-covid-19-contact-tracing-technology_04102020_inline.jpg.large_2x.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chrome V8命令执行漏洞分析（CVE-2022-1310）"/></a><div class="content"><a class="title" href="/2022/09/04/Chrome-V8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2022-1310/" title="Chrome V8命令执行漏洞分析（CVE-2022-1310）">Chrome V8命令执行漏洞分析（CVE-2022-1310）</a><time datetime="2022-09-04T12:01:52.000Z" title="发表于 2022-09-04 20:01:52">2022-09-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://www.apple.com.cn/newsroom/images/values/health/Apple-Health-study-July-2022-hero.jpg.landing-regular_2x.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Small Waste</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://apple.com">Developer</a><span class="footer-separator">|</span><span>主题 </span><a href="">ADD</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://www.xiaojingye.top/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://blog-eight-silk.vercel.app',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://blog-eight-silk.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="8556824432" data-server="tencent" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="-1"> </div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,自由,平等,公正,法制,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/issues.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>